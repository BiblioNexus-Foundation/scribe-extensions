(self["webpackChunkbrowser_app"] = self["webpackChunkbrowser_app"] || []).push([["vendors-node_modules_theia_debug_lib_common_debug-uri-utils_js-node_modules_theia_plugin-ext_-28ca15"],{

/***/ "../node_modules/@theia/core/shared/vscode-uri/index.js":
/*!**************************************************************!*\
  !*** ../node_modules/@theia/core/shared/vscode-uri/index.js ***!
  \**************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

module.exports = __webpack_require__(/*! vscode-uri */ "../node_modules/vscode-uri/lib/esm/index.js");


/***/ }),

/***/ "../node_modules/@theia/debug/lib/common/debug-uri-utils.js":
/*!******************************************************************!*\
  !*** ../node_modules/@theia/debug/lib/common/debug-uri-utils.js ***!
  \******************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

/********************************************************************************
 * Copyright (C) 2022 STMicroelectronics and others.
 *
 * This program and the accompanying materials are made available under the
 * terms of the Eclipse Public License v. 2.0 which is available at
 * http://www.eclipse.org/legal/epl-2.0.
 *
 * This Source Code may also be made available under the following Secondary
 * Licenses when the conditions for such availability set forth in the Eclipse
 * Public License v. 2.0 are satisfied: GNU General Public License, version 2
 * with the GNU Classpath Exception which is available at
 * https://www.gnu.org/software/classpath/license.html.
 *
 * SPDX-License-Identifier: EPL-2.0 OR GPL-2.0-only WITH Classpath-exception-2.0
 ********************************************************************************/
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.SCHEME_PATTERN = exports.DEBUG_SCHEME = void 0;
/**
 * The URI scheme for debug URIs.
 */
exports.DEBUG_SCHEME = 'debug';
/**
 * The pattern for URI schemes.
 */
exports.SCHEME_PATTERN = /^[a-zA-Z][a-zA-Z0-9\+\-\.]+:/;


/***/ }),

/***/ "../node_modules/@theia/notebook/lib/common/index.js":
/*!***********************************************************!*\
  !*** ../node_modules/@theia/notebook/lib/common/index.js ***!
  \***********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

// *****************************************************************************
// Copyright (C) 2023 TypeFox and others.
//
// This program and the accompanying materials are made available under the
// terms of the Eclipse Public License v. 2.0 which is available at
// http://www.eclipse.org/legal/epl-2.0.
//
// This Source Code may also be made available under the following Secondary
// Licenses when the conditions for such availability set forth in the Eclipse
// Public License v. 2.0 are satisfied: GNU General Public License, version 2
// with the GNU Classpath Exception which is available at
// https://www.gnu.org/software/classpath/license.html.
//
// SPDX-License-Identifier: EPL-2.0 OR GPL-2.0-only WITH Classpath-exception-2.0
// *****************************************************************************
Object.defineProperty(exports, "__esModule", ({ value: true }));
const tslib_1 = __webpack_require__(/*! tslib */ "../node_modules/tslib/tslib.es6.mjs");
tslib_1.__exportStar(__webpack_require__(/*! ./notebook-common */ "../node_modules/@theia/notebook/lib/common/notebook-common.js"), exports);
tslib_1.__exportStar(__webpack_require__(/*! ./notebook-range */ "../node_modules/@theia/notebook/lib/common/notebook-range.js"), exports);


/***/ }),

/***/ "../node_modules/@theia/notebook/lib/common/notebook-common.js":
/*!*********************************************************************!*\
  !*** ../node_modules/@theia/notebook/lib/common/notebook-common.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
/* provided dependency */ var Buffer = __webpack_require__(/*! buffer */ "../node_modules/buffer/index.js")["Buffer"];

// *****************************************************************************
// Copyright (C) 2023 TypeFox and others.
//
// This program and the accompanying materials are made available under the
// terms of the Eclipse Public License v. 2.0 which is available at
// http://www.eclipse.org/legal/epl-2.0.
//
// This Source Code may also be made available under the following Secondary
// Licenses when the conditions for such availability set forth in the Eclipse
// Public License v. 2.0 are satisfied: GNU General Public License, version 2
// with the GNU Classpath Exception which is available at
// https://www.gnu.org/software/classpath/license.html.
//
// SPDX-License-Identifier: EPL-2.0 OR GPL-2.0-only WITH Classpath-exception-2.0
// *****************************************************************************
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.CellUri = exports.isTextStreamMime = exports.CellExecutionUpdateType = exports.NotebookCellExecutionState = exports.NotebookCellModelResource = exports.NotebookModelResource = exports.NotebookCellsChangeType = exports.CellKind = void 0;
const core_1 = __webpack_require__(/*! @theia/core */ "../node_modules/@theia/core/lib/common/index.js");
const buffer_1 = __webpack_require__(/*! @theia/core/lib/common/buffer */ "../node_modules/@theia/core/lib/common/buffer.js");
var CellKind;
(function (CellKind) {
    CellKind[CellKind["Markup"] = 1] = "Markup";
    CellKind[CellKind["Code"] = 2] = "Code";
})(CellKind || (exports.CellKind = CellKind = {}));
;
var NotebookCellsChangeType;
(function (NotebookCellsChangeType) {
    NotebookCellsChangeType[NotebookCellsChangeType["ModelChange"] = 1] = "ModelChange";
    NotebookCellsChangeType[NotebookCellsChangeType["Move"] = 2] = "Move";
    NotebookCellsChangeType[NotebookCellsChangeType["ChangeCellLanguage"] = 5] = "ChangeCellLanguage";
    NotebookCellsChangeType[NotebookCellsChangeType["Initialize"] = 6] = "Initialize";
    NotebookCellsChangeType[NotebookCellsChangeType["ChangeCellMetadata"] = 7] = "ChangeCellMetadata";
    NotebookCellsChangeType[NotebookCellsChangeType["Output"] = 8] = "Output";
    NotebookCellsChangeType[NotebookCellsChangeType["OutputItem"] = 9] = "OutputItem";
    NotebookCellsChangeType[NotebookCellsChangeType["ChangeCellContent"] = 10] = "ChangeCellContent";
    NotebookCellsChangeType[NotebookCellsChangeType["ChangeDocumentMetadata"] = 11] = "ChangeDocumentMetadata";
    NotebookCellsChangeType[NotebookCellsChangeType["ChangeCellInternalMetadata"] = 12] = "ChangeCellInternalMetadata";
    // ChangeCellMime = 13,
    NotebookCellsChangeType[NotebookCellsChangeType["Unknown"] = 100] = "Unknown";
})(NotebookCellsChangeType || (exports.NotebookCellsChangeType = NotebookCellsChangeType = {}));
var NotebookModelResource;
(function (NotebookModelResource) {
    function is(item) {
        return (0, core_1.isObject)(item) && item.notebookModelUri instanceof core_1.URI;
    }
    NotebookModelResource.is = is;
    function create(uri) {
        return { notebookModelUri: uri };
    }
    NotebookModelResource.create = create;
})(NotebookModelResource || (exports.NotebookModelResource = NotebookModelResource = {}));
var NotebookCellModelResource;
(function (NotebookCellModelResource) {
    function is(item) {
        return (0, core_1.isObject)(item) && item.notebookCellModelUri instanceof core_1.URI;
    }
    NotebookCellModelResource.is = is;
    function create(uri) {
        return { notebookCellModelUri: uri };
    }
    NotebookCellModelResource.create = create;
})(NotebookCellModelResource || (exports.NotebookCellModelResource = NotebookCellModelResource = {}));
var NotebookCellExecutionState;
(function (NotebookCellExecutionState) {
    NotebookCellExecutionState[NotebookCellExecutionState["Unconfirmed"] = 1] = "Unconfirmed";
    NotebookCellExecutionState[NotebookCellExecutionState["Pending"] = 2] = "Pending";
    NotebookCellExecutionState[NotebookCellExecutionState["Executing"] = 3] = "Executing";
})(NotebookCellExecutionState || (exports.NotebookCellExecutionState = NotebookCellExecutionState = {}));
var CellExecutionUpdateType;
(function (CellExecutionUpdateType) {
    CellExecutionUpdateType[CellExecutionUpdateType["Output"] = 1] = "Output";
    CellExecutionUpdateType[CellExecutionUpdateType["OutputItems"] = 2] = "OutputItems";
    CellExecutionUpdateType[CellExecutionUpdateType["ExecutionState"] = 3] = "ExecutionState";
})(CellExecutionUpdateType || (exports.CellExecutionUpdateType = CellExecutionUpdateType = {}));
/**
 * Whether the provided mime type is a text stream like `stdout`, `stderr`.
 */
function isTextStreamMime(mimeType) {
    return ['application/vnd.code.notebook.stdout', 'application/vnd.code.notebook.stderr'].includes(mimeType);
}
exports.isTextStreamMime = isTextStreamMime;
var CellUri;
(function (CellUri) {
    CellUri.cellUriScheme = 'vscode-notebook-cell';
    CellUri.outputUriScheme = 'vscode-notebook-cell-output';
    const _lengths = ['W', 'X', 'Y', 'Z', 'a', 'b', 'c', 'd', 'e', 'f'];
    const _padRegexp = new RegExp(`^[${_lengths.join('')}]+`);
    const _radix = 7;
    function generate(notebook, handle) {
        const s = handle.toString(_radix);
        const p = s.length < _lengths.length ? _lengths[s.length - 1] : 'z';
        const fragment = `${p}${s}s${Buffer.from(buffer_1.BinaryBuffer.fromString(notebook.scheme).buffer).toString('base64')}`;
        return notebook.withScheme(CellUri.cellUriScheme).withFragment(fragment);
    }
    CellUri.generate = generate;
    function parse(cell) {
        if (cell.scheme !== CellUri.cellUriScheme) {
            return undefined;
        }
        const idx = cell.fragment.indexOf('s');
        if (idx < 0) {
            return undefined;
        }
        const handle = parseInt(cell.fragment.substring(0, idx).replace(_padRegexp, ''), _radix);
        const parsedScheme = Buffer.from(cell.fragment.substring(idx + 1), 'base64').toString();
        if (isNaN(handle)) {
            return undefined;
        }
        return {
            handle,
            notebook: cell.withScheme(parsedScheme).withoutFragment()
        };
    }
    CellUri.parse = parse;
    function generateCellOutputUri(notebook, outputId) {
        return notebook
            .withScheme(CellUri.outputUriScheme)
            .withQuery(`op${outputId !== null && outputId !== void 0 ? outputId : ''},${notebook.scheme !== 'file' ? notebook.scheme : ''}`);
    }
    CellUri.generateCellOutputUri = generateCellOutputUri;
    ;
    function parseCellOutputUri(uri) {
        if (uri.scheme !== CellUri.outputUriScheme) {
            return;
        }
        const match = /^op([0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12})?\,(.*)$/i.exec(uri.query);
        if (!match) {
            return undefined;
        }
        const outputId = match[1] || undefined;
        const scheme = match[2];
        return {
            outputId,
            notebook: uri.withScheme(scheme || 'file').withoutQuery()
        };
    }
    CellUri.parseCellOutputUri = parseCellOutputUri;
    function generateCellPropertyUri(notebook, handle, cellScheme) {
        return CellUri.generate(notebook, handle).withScheme(cellScheme);
    }
    CellUri.generateCellPropertyUri = generateCellPropertyUri;
    function parseCellPropertyUri(uri, propertyScheme) {
        if (uri.scheme !== propertyScheme) {
            return undefined;
        }
        return CellUri.parse(uri.withScheme(CellUri.cellUriScheme));
    }
    CellUri.parseCellPropertyUri = parseCellPropertyUri;
})(CellUri || (exports.CellUri = CellUri = {}));


/***/ }),

/***/ "../node_modules/@theia/notebook/lib/common/notebook-range.js":
/*!********************************************************************!*\
  !*** ../node_modules/@theia/notebook/lib/common/notebook-range.js ***!
  \********************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

// *****************************************************************************
// Copyright (C) 2023 Typefox and others.
//
// This program and the accompanying materials are made available under the
// terms of the Eclipse Public License v. 2.0 which is available at
// http://www.eclipse.org/legal/epl-2.0.
//
// This Source Code may also be made available under the following Secondary
// Licenses when the conditions for such availability set forth in the Eclipse
// Public License v. 2.0 are satisfied: GNU General Public License, version 2
// with the GNU Classpath Exception which is available at
// https://www.gnu.org/software/classpath/license.html.
//
// SPDX-License-Identifier: EPL-2.0 OR GPL-2.0-only WITH Classpath-exception-2.0
// *****************************************************************************
Object.defineProperty(exports, "__esModule", ({ value: true }));


/***/ }),

/***/ "../node_modules/@theia/plugin-ext/lib/common/arrays.js":
/*!**************************************************************!*\
  !*** ../node_modules/@theia/plugin-ext/lib/common/arrays.js ***!
  \**************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

// *****************************************************************************
// Copyright (C) 2020 TypeFox and others.
//
// This program and the accompanying materials are made available under the
// terms of the Eclipse Public License v. 2.0 which is available at
// http://www.eclipse.org/legal/epl-2.0.
//
// This Source Code may also be made available under the following Secondary
// Licenses when the conditions for such availability set forth in the Eclipse
// Public License v. 2.0 are satisfied: GNU General Public License, version 2
// with the GNU Classpath Exception which is available at
// https://www.gnu.org/software/classpath/license.html.
//
// SPDX-License-Identifier: EPL-2.0 OR GPL-2.0-only WITH Classpath-exception-2.0
// *****************************************************************************
/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
// based on https://github.com/microsoft/vscode/blob/04c36be045a94fee58e5f8992d3e3fd980294a84/src/vs/base/common/arrays.ts
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.mapFind = exports.isReadonlyArray = exports.flatten = exports.isNonEmptyArray = exports.coalesce = void 0;
/**
 * @returns New array with all falsy values removed. The original array IS NOT modified.
 */
function coalesce(array) {
    return array.filter(e => !!e);
}
exports.coalesce = coalesce;
function isNonEmptyArray(obj) {
    return Array.isArray(obj) && obj.length > 0;
}
exports.isNonEmptyArray = isNonEmptyArray;
function flatten(arr) {
    return [].concat(...arr);
}
exports.flatten = flatten;
/**
 * @returns 'true' if the 'arg' is a 'ReadonlyArray'.
 */
function isReadonlyArray(arg) {
    // Since Typescript does not properly narrow down typings for 'ReadonlyArray' we need to help it.
    return Array.isArray(arg);
}
exports.isReadonlyArray = isReadonlyArray;
// Copied from https://github.com/microsoft/vscode/blob/1.72.2/src/vs/base/common/arrays.ts
/**
 * Returns the first mapped value of the array which is not undefined.
 */
function mapFind(array, mapFn) {
    for (const value of array) {
        const mapped = mapFn(value);
        if (mapped !== undefined) {
            return mapped;
        }
    }
    return undefined;
}
exports.mapFind = mapFind;


/***/ }),

/***/ "../node_modules/@theia/plugin-ext/lib/common/disposable-util.js":
/*!***********************************************************************!*\
  !*** ../node_modules/@theia/plugin-ext/lib/common/disposable-util.js ***!
  \***********************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

// *****************************************************************************
// Copyright (C) 2018 Red Hat, Inc. and others.
//
// This program and the accompanying materials are made available under the
// terms of the Eclipse Public License v. 2.0 which is available at
// http://www.eclipse.org/legal/epl-2.0.
//
// This Source Code may also be made available under the following Secondary
// Licenses when the conditions for such availability set forth in the Eclipse
// Public License v. 2.0 are satisfied: GNU General Public License, version 2
// with the GNU Classpath Exception which is available at
// https://www.gnu.org/software/classpath/license.html.
//
// SPDX-License-Identifier: EPL-2.0 OR GPL-2.0-only WITH Classpath-exception-2.0
// *****************************************************************************
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.dispose = void 0;
function dispose(first, ...rest) {
    if (Array.isArray(first)) {
        first.forEach(d => d && d.dispose());
        return [];
    }
    else if (rest.length === 0) {
        if (first) {
            first.dispose();
            return first;
        }
        return undefined;
    }
    else {
        dispose(first);
        dispose(rest);
        return [];
    }
}
exports.dispose = dispose;


/***/ }),

/***/ "../node_modules/@theia/plugin-ext/lib/common/errors.js":
/*!**************************************************************!*\
  !*** ../node_modules/@theia/plugin-ext/lib/common/errors.js ***!
  \**************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

// *****************************************************************************
// Copyright (C) 2018 Red Hat, Inc. and others.
//
// This program and the accompanying materials are made available under the
// terms of the Eclipse Public License v. 2.0 which is available at
// http://www.eclipse.org/legal/epl-2.0.
//
// This Source Code may also be made available under the following Secondary
// Licenses when the conditions for such availability set forth in the Eclipse
// Public License v. 2.0 are satisfied: GNU General Public License, version 2
// with the GNU Classpath Exception which is available at
// https://www.gnu.org/software/classpath/license.html.
//
// SPDX-License-Identifier: EPL-2.0 OR GPL-2.0-only WITH Classpath-exception-2.0
// *****************************************************************************
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.isENOENT = exports.disposed = exports.readonly = exports.illegalArgument = void 0;
const types_1 = __webpack_require__(/*! @theia/core/lib/common/types */ "../node_modules/@theia/core/lib/common/types.js");
function illegalArgument(message) {
    if (message) {
        return new Error(`Illegal argument: ${message}`);
    }
    else {
        return new Error('Illegal argument');
    }
}
exports.illegalArgument = illegalArgument;
function readonly(name) {
    if (name) {
        return new Error(`readonly property '${name} cannot be changed'`);
    }
    else {
        return new Error('readonly property cannot be changed');
    }
}
exports.readonly = readonly;
function disposed(what) {
    const result = new Error(`${what} has been disposed`);
    result.name = 'DISPOSED';
    return result;
}
exports.disposed = disposed;
const ENOENT = 'ENOENT';
function isErrnoException(arg) {
    return arg instanceof Error
        && (0, types_1.isObject)(arg)
        && typeof arg.code === 'string'
        && typeof arg.errno === 'number';
}
/**
 * _(No such file or directory)_: Commonly raised by `fs` operations to indicate that a component of the specified pathname does not exist â€” no entity (file or directory) could be
 * found by the given path.
 */
function isENOENT(arg) {
    return isErrnoException(arg) && arg.code === ENOENT;
}
exports.isENOENT = isENOENT;


/***/ }),

/***/ "../node_modules/@theia/plugin-ext/lib/common/index.js":
/*!*************************************************************!*\
  !*** ../node_modules/@theia/plugin-ext/lib/common/index.js ***!
  \*************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

// *****************************************************************************
// Copyright (C) 2018 Red Hat, Inc. and others.
//
// This program and the accompanying materials are made available under the
// terms of the Eclipse Public License v. 2.0 which is available at
// http://www.eclipse.org/legal/epl-2.0.
//
// This Source Code may also be made available under the following Secondary
// Licenses when the conditions for such availability set forth in the Eclipse
// Public License v. 2.0 are satisfied: GNU General Public License, version 2
// with the GNU Classpath Exception which is available at
// https://www.gnu.org/software/classpath/license.html.
//
// SPDX-License-Identifier: EPL-2.0 OR GPL-2.0-only WITH Classpath-exception-2.0
// *****************************************************************************
Object.defineProperty(exports, "__esModule", ({ value: true }));
const tslib_1 = __webpack_require__(/*! tslib */ "../node_modules/tslib/tslib.es6.mjs");
// Here we expose types from @theia/plugin, so it becomes a direct dependency
tslib_1.__exportStar(__webpack_require__(/*! ./plugin-protocol */ "../node_modules/@theia/plugin-ext/lib/common/plugin-protocol.js"), exports);
tslib_1.__exportStar(__webpack_require__(/*! ./plugin-api-rpc */ "../node_modules/@theia/plugin-ext/lib/common/plugin-api-rpc.js"), exports);
tslib_1.__exportStar(__webpack_require__(/*! ./plugin-ext-api-contribution */ "../node_modules/@theia/plugin-ext/lib/common/plugin-ext-api-contribution.js"), exports);
const rpc_protocol_1 = __webpack_require__(/*! ./rpc-protocol */ "../node_modules/@theia/plugin-ext/lib/common/rpc-protocol.js");
(0, rpc_protocol_1.registerMsgPackExtensions)();


/***/ }),

/***/ "../node_modules/@theia/plugin-ext/lib/common/paths-util.js":
/*!******************************************************************!*\
  !*** ../node_modules/@theia/plugin-ext/lib/common/paths-util.js ***!
  \******************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

// *****************************************************************************
// Copyright (C) 2018 Red Hat, Inc. and others.
//
// This program and the accompanying materials are made available under the
// terms of the Eclipse Public License v. 2.0 which is available at
// http://www.eclipse.org/legal/epl-2.0.
//
// This Source Code may also be made available under the following Secondary
// Licenses when the conditions for such availability set forth in the Eclipse
// Public License v. 2.0 are satisfied: GNU General Public License, version 2
// with the GNU Classpath Exception which is available at
// https://www.gnu.org/software/classpath/license.html.
//
// SPDX-License-Identifier: EPL-2.0 OR GPL-2.0-only WITH Classpath-exception-2.0
// *****************************************************************************
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.normalize = exports.relative = exports.resolve = void 0;
// file copied from https://github.com/wjordan/browser-path/blob/master/src/node_path.ts
// Original license:
/*
====

Copyright (c) 2015 John Vilk and other contributors.

Permission is hereby granted, free of charge, to any person obtaining a copy of
this software and associated documentation files (the "Software"), to deal in
the Software without restriction, including without limitation the rights to
use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies
of the Software, and to permit persons to whom the Software is furnished to do
so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.

====
*/
const paths_1 = __webpack_require__(/*! @theia/core/lib/common/paths */ "../node_modules/@theia/core/lib/common/paths.js");
const replaceRegex = new RegExp('//+', 'g');
function resolve(...paths) {
    let processed = [];
    for (const p of paths) {
        if (typeof p !== 'string') {
            throw new TypeError('Invalid argument type to path.join: ' + (typeof p));
        }
        else if (p !== '') {
            if (p.charAt(0) === paths_1.sep) {
                processed = [];
            }
            processed.push(p);
        }
    }
    const resolved = normalize(processed.join(paths_1.sep));
    if (resolved.length > 1 && resolved.charAt(resolved.length - 1) === paths_1.sep) {
        return resolved.substring(0, resolved.length - 1);
    }
    return resolved;
}
exports.resolve = resolve;
function relative(from, to) {
    let i;
    from = resolve(from);
    to = resolve(to);
    const fromSegments = from.split(paths_1.sep);
    const toSegments = to.split(paths_1.sep);
    toSegments.shift();
    fromSegments.shift();
    let upCount = 0;
    let downSegments = [];
    for (i = 0; i < fromSegments.length; i++) {
        const seg = fromSegments[i];
        if (seg === toSegments[i]) {
            continue;
        }
        upCount = fromSegments.length - i;
        break;
    }
    downSegments = toSegments.slice(i);
    if (fromSegments.length === 1 && fromSegments[0] === '') {
        upCount = 0;
    }
    if (upCount > fromSegments.length) {
        upCount = fromSegments.length;
    }
    let rv = '';
    for (i = 0; i < upCount; i++) {
        rv += '../';
    }
    rv += downSegments.join(paths_1.sep);
    if (rv.length > 1 && rv.charAt(rv.length - 1) === paths_1.sep) {
        rv = rv.substring(0, rv.length - 1);
    }
    return rv;
}
exports.relative = relative;
function normalize(p) {
    if (p === '') {
        p = '.';
    }
    const absolute = p.charAt(0) === paths_1.sep;
    p = removeDuplicateSeparators(p);
    const components = p.split(paths_1.sep);
    const goodComponents = [];
    for (const c of components) {
        if (c === '.') {
            continue;
        }
        else if (c === '..' && (absolute || (!absolute && goodComponents.length > 0 && goodComponents[0] !== '..'))) {
            goodComponents.pop();
        }
        else {
            goodComponents.push(c);
        }
    }
    if (!absolute && goodComponents.length < 2) {
        switch (goodComponents.length) {
            case 1:
                if (goodComponents[0] === '') {
                    goodComponents.unshift('.');
                }
                break;
            default:
                goodComponents.push('.');
        }
    }
    p = goodComponents.join(paths_1.sep);
    if (absolute && p.charAt(0) !== paths_1.sep) {
        p = paths_1.sep + p;
    }
    return p;
}
exports.normalize = normalize;
function removeDuplicateSeparators(p) {
    p = p.replace(replaceRegex, paths_1.sep);
    return p;
}


/***/ }),

/***/ "../node_modules/@theia/plugin-ext/lib/common/plugin-api-rpc-model.js":
/*!****************************************************************************!*\
  !*** ../node_modules/@theia/plugin-ext/lib/common/plugin-api-rpc-model.js ***!
  \****************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

// *****************************************************************************
// Copyright (C) 2018 Red Hat, Inc. and others.
//
// This program and the accompanying materials are made available under the
// terms of the Eclipse Public License v. 2.0 which is available at
// http://www.eclipse.org/legal/epl-2.0.
//
// This Source Code may also be made available under the following Secondary
// Licenses when the conditions for such availability set forth in the Eclipse
// Public License v. 2.0 are satisfied: GNU General Public License, version 2
// with the GNU Classpath Exception which is available at
// https://www.gnu.org/software/classpath/license.html.
//
// SPDX-License-Identifier: EPL-2.0 OR GPL-2.0-only WITH Classpath-exception-2.0
// *****************************************************************************
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.InlineCompletionTriggerKind = exports.InlayHintKind = exports.CommentThreadCollapsibleState = exports.CommentThreadState = exports.CommentMode = exports.TypeHierarchyItem = exports.HierarchyItem = exports.FoldingRangeKind = exports.SymbolTag = exports.SymbolKind = exports.CodeActionTriggerKind = exports.DocumentHighlightKind = exports.MarkerTag = exports.MarkerSeverity = exports.IdObject = exports.CompletionItemKind = exports.CompletionItemInsertTextRule = exports.CompletionTriggerKind = exports.MarkdownString = void 0;
const markdown_rendering_1 = __webpack_require__(/*! @theia/core/lib/common/markdown-rendering */ "../node_modules/@theia/core/lib/common/markdown-rendering/index.js");
Object.defineProperty(exports, "MarkdownString", ({ enumerable: true, get: function () { return markdown_rendering_1.MarkdownString; } }));
var CompletionTriggerKind;
(function (CompletionTriggerKind) {
    CompletionTriggerKind[CompletionTriggerKind["Invoke"] = 0] = "Invoke";
    CompletionTriggerKind[CompletionTriggerKind["TriggerCharacter"] = 1] = "TriggerCharacter";
    CompletionTriggerKind[CompletionTriggerKind["TriggerForIncompleteCompletions"] = 2] = "TriggerForIncompleteCompletions";
})(CompletionTriggerKind || (exports.CompletionTriggerKind = CompletionTriggerKind = {}));
var CompletionItemInsertTextRule;
(function (CompletionItemInsertTextRule) {
    CompletionItemInsertTextRule[CompletionItemInsertTextRule["KeepWhitespace"] = 1] = "KeepWhitespace";
    CompletionItemInsertTextRule[CompletionItemInsertTextRule["InsertAsSnippet"] = 4] = "InsertAsSnippet";
})(CompletionItemInsertTextRule || (exports.CompletionItemInsertTextRule = CompletionItemInsertTextRule = {}));
var CompletionItemKind;
(function (CompletionItemKind) {
    CompletionItemKind[CompletionItemKind["Method"] = 0] = "Method";
    CompletionItemKind[CompletionItemKind["Function"] = 1] = "Function";
    CompletionItemKind[CompletionItemKind["Constructor"] = 2] = "Constructor";
    CompletionItemKind[CompletionItemKind["Field"] = 3] = "Field";
    CompletionItemKind[CompletionItemKind["Variable"] = 4] = "Variable";
    CompletionItemKind[CompletionItemKind["Class"] = 5] = "Class";
    CompletionItemKind[CompletionItemKind["Struct"] = 6] = "Struct";
    CompletionItemKind[CompletionItemKind["Interface"] = 7] = "Interface";
    CompletionItemKind[CompletionItemKind["Module"] = 8] = "Module";
    CompletionItemKind[CompletionItemKind["Property"] = 9] = "Property";
    CompletionItemKind[CompletionItemKind["Event"] = 10] = "Event";
    CompletionItemKind[CompletionItemKind["Operator"] = 11] = "Operator";
    CompletionItemKind[CompletionItemKind["Unit"] = 12] = "Unit";
    CompletionItemKind[CompletionItemKind["Value"] = 13] = "Value";
    CompletionItemKind[CompletionItemKind["Constant"] = 14] = "Constant";
    CompletionItemKind[CompletionItemKind["Enum"] = 15] = "Enum";
    CompletionItemKind[CompletionItemKind["EnumMember"] = 16] = "EnumMember";
    CompletionItemKind[CompletionItemKind["Keyword"] = 17] = "Keyword";
    CompletionItemKind[CompletionItemKind["Text"] = 18] = "Text";
    CompletionItemKind[CompletionItemKind["Color"] = 19] = "Color";
    CompletionItemKind[CompletionItemKind["File"] = 20] = "File";
    CompletionItemKind[CompletionItemKind["Reference"] = 21] = "Reference";
    CompletionItemKind[CompletionItemKind["Customcolor"] = 22] = "Customcolor";
    CompletionItemKind[CompletionItemKind["Folder"] = 23] = "Folder";
    CompletionItemKind[CompletionItemKind["TypeParameter"] = 24] = "TypeParameter";
    CompletionItemKind[CompletionItemKind["User"] = 25] = "User";
    CompletionItemKind[CompletionItemKind["Issue"] = 26] = "Issue";
    CompletionItemKind[CompletionItemKind["Snippet"] = 27] = "Snippet";
})(CompletionItemKind || (exports.CompletionItemKind = CompletionItemKind = {}));
class IdObject {
}
exports.IdObject = IdObject;
var MarkerSeverity;
(function (MarkerSeverity) {
    MarkerSeverity[MarkerSeverity["Hint"] = 1] = "Hint";
    MarkerSeverity[MarkerSeverity["Info"] = 2] = "Info";
    MarkerSeverity[MarkerSeverity["Warning"] = 4] = "Warning";
    MarkerSeverity[MarkerSeverity["Error"] = 8] = "Error";
})(MarkerSeverity || (exports.MarkerSeverity = MarkerSeverity = {}));
var MarkerTag;
(function (MarkerTag) {
    MarkerTag[MarkerTag["Unnecessary"] = 1] = "Unnecessary";
    MarkerTag[MarkerTag["Deprecated"] = 2] = "Deprecated";
})(MarkerTag || (exports.MarkerTag = MarkerTag = {}));
var DocumentHighlightKind;
(function (DocumentHighlightKind) {
    DocumentHighlightKind[DocumentHighlightKind["Text"] = 0] = "Text";
    DocumentHighlightKind[DocumentHighlightKind["Read"] = 1] = "Read";
    DocumentHighlightKind[DocumentHighlightKind["Write"] = 2] = "Write";
})(DocumentHighlightKind || (exports.DocumentHighlightKind = DocumentHighlightKind = {}));
var CodeActionTriggerKind;
(function (CodeActionTriggerKind) {
    CodeActionTriggerKind[CodeActionTriggerKind["Invoke"] = 1] = "Invoke";
    CodeActionTriggerKind[CodeActionTriggerKind["Automatic"] = 2] = "Automatic";
})(CodeActionTriggerKind || (exports.CodeActionTriggerKind = CodeActionTriggerKind = {}));
var SymbolKind;
(function (SymbolKind) {
    SymbolKind[SymbolKind["File"] = 0] = "File";
    SymbolKind[SymbolKind["Module"] = 1] = "Module";
    SymbolKind[SymbolKind["Namespace"] = 2] = "Namespace";
    SymbolKind[SymbolKind["Package"] = 3] = "Package";
    SymbolKind[SymbolKind["Class"] = 4] = "Class";
    SymbolKind[SymbolKind["Method"] = 5] = "Method";
    SymbolKind[SymbolKind["Property"] = 6] = "Property";
    SymbolKind[SymbolKind["Field"] = 7] = "Field";
    SymbolKind[SymbolKind["Constructor"] = 8] = "Constructor";
    SymbolKind[SymbolKind["Enum"] = 9] = "Enum";
    SymbolKind[SymbolKind["Interface"] = 10] = "Interface";
    SymbolKind[SymbolKind["Function"] = 11] = "Function";
    SymbolKind[SymbolKind["Variable"] = 12] = "Variable";
    SymbolKind[SymbolKind["Constant"] = 13] = "Constant";
    SymbolKind[SymbolKind["String"] = 14] = "String";
    SymbolKind[SymbolKind["Number"] = 15] = "Number";
    SymbolKind[SymbolKind["Boolean"] = 16] = "Boolean";
    SymbolKind[SymbolKind["Array"] = 17] = "Array";
    SymbolKind[SymbolKind["Object"] = 18] = "Object";
    SymbolKind[SymbolKind["Key"] = 19] = "Key";
    SymbolKind[SymbolKind["Null"] = 20] = "Null";
    SymbolKind[SymbolKind["EnumMember"] = 21] = "EnumMember";
    SymbolKind[SymbolKind["Struct"] = 22] = "Struct";
    SymbolKind[SymbolKind["Event"] = 23] = "Event";
    SymbolKind[SymbolKind["Operator"] = 24] = "Operator";
    SymbolKind[SymbolKind["TypeParameter"] = 25] = "TypeParameter";
})(SymbolKind || (exports.SymbolKind = SymbolKind = {}));
var SymbolTag;
(function (SymbolTag) {
    SymbolTag[SymbolTag["Deprecated"] = 1] = "Deprecated";
})(SymbolTag || (exports.SymbolTag = SymbolTag = {}));
class FoldingRangeKind {
    constructor(value) {
        this.value = value;
    }
}
exports.FoldingRangeKind = FoldingRangeKind;
FoldingRangeKind.Comment = new FoldingRangeKind('comment');
FoldingRangeKind.Imports = new FoldingRangeKind('imports');
FoldingRangeKind.Region = new FoldingRangeKind('region');
class HierarchyItem {
}
exports.HierarchyItem = HierarchyItem;
class TypeHierarchyItem extends HierarchyItem {
}
exports.TypeHierarchyItem = TypeHierarchyItem;
var CommentMode;
(function (CommentMode) {
    CommentMode[CommentMode["Editing"] = 0] = "Editing";
    CommentMode[CommentMode["Preview"] = 1] = "Preview";
})(CommentMode || (exports.CommentMode = CommentMode = {}));
var CommentThreadState;
(function (CommentThreadState) {
    CommentThreadState[CommentThreadState["Unresolved"] = 0] = "Unresolved";
    CommentThreadState[CommentThreadState["Resolved"] = 1] = "Resolved";
})(CommentThreadState || (exports.CommentThreadState = CommentThreadState = {}));
var CommentThreadCollapsibleState;
(function (CommentThreadCollapsibleState) {
    /**
     * Determines an item is collapsed
     */
    CommentThreadCollapsibleState[CommentThreadCollapsibleState["Collapsed"] = 0] = "Collapsed";
    /**
     * Determines an item is expanded
     */
    CommentThreadCollapsibleState[CommentThreadCollapsibleState["Expanded"] = 1] = "Expanded";
})(CommentThreadCollapsibleState || (exports.CommentThreadCollapsibleState = CommentThreadCollapsibleState = {}));
var InlayHintKind;
(function (InlayHintKind) {
    InlayHintKind[InlayHintKind["Type"] = 1] = "Type";
    InlayHintKind[InlayHintKind["Parameter"] = 2] = "Parameter";
})(InlayHintKind || (exports.InlayHintKind = InlayHintKind = {}));
/**
 * How an {@link InlineCompletionsProvider inline completion provider} was triggered.
 */
var InlineCompletionTriggerKind;
(function (InlineCompletionTriggerKind) {
    /**
     * Completion was triggered automatically while editing.
     * It is sufficient to return a single completion item in this case.
     */
    InlineCompletionTriggerKind[InlineCompletionTriggerKind["Automatic"] = 0] = "Automatic";
    /**
     * Completion was triggered explicitly by a user gesture.
     * Return multiple completion items to enable cycling through them.
     */
    InlineCompletionTriggerKind[InlineCompletionTriggerKind["Explicit"] = 1] = "Explicit";
})(InlineCompletionTriggerKind || (exports.InlineCompletionTriggerKind = InlineCompletionTriggerKind = {}));


/***/ }),

/***/ "../node_modules/@theia/plugin-ext/lib/common/plugin-api-rpc.js":
/*!**********************************************************************!*\
  !*** ../node_modules/@theia/plugin-ext/lib/common/plugin-api-rpc.js ***!
  \**********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

// *****************************************************************************
// Copyright (C) 2018 Red Hat, Inc. and others.
//
// This program and the accompanying materials are made available under the
// terms of the Eclipse Public License v. 2.0 which is available at
// http://www.eclipse.org/legal/epl-2.0.
//
// This Source Code may also be made available under the following Secondary
// Licenses when the conditions for such availability set forth in the Eclipse
// Public License v. 2.0 are satisfied: GNU General Public License, version 2
// with the GNU Classpath Exception which is available at
// https://www.gnu.org/software/classpath/license.html.
//
// SPDX-License-Identifier: EPL-2.0 OR GPL-2.0-only WITH Classpath-exception-2.0
// *****************************************************************************
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.LocalizationExt = exports.NotebookEditorRevealType = exports.MAIN_RPC_CONTEXT = exports.PLUGIN_RPC_CONTEXT = exports.DebugConfigurationProviderTriggerKind = exports.OutputChannelRegistryFactory = exports.LanguagesMainFactory = exports.WorkspaceNotebookCellEditDto = exports.WorkspaceTextEditDto = exports.TrackedRangeStickiness = exports.TextEditorRevealType = exports.EditorPosition = exports.CommentsEditCommandArg = exports.CommentsContextCommandArg = exports.CommentsCommandArg = exports.TimelineCommandArg = exports.ScmCommandArg = exports.TreeViewItemCollapsibleState = exports.TreeViewItemReference = exports.DataTransferFileDTO = exports.MainMessageType = exports.emptyPlugin = exports.PluginManager = exports.ExtensionKind = exports.UIKind = void 0;
/* eslint-disable @typescript-eslint/no-explicit-any */
const rpc_protocol_1 = __webpack_require__(/*! ./rpc-protocol */ "../node_modules/@theia/plugin-ext/lib/common/rpc-protocol.js");
const common_1 = __webpack_require__(/*! @theia/core/lib/common */ "../node_modules/@theia/core/lib/common/index.js");
var UIKind;
(function (UIKind) {
    /**
     * Extensions are accessed from a desktop application.
     */
    UIKind[UIKind["Desktop"] = 1] = "Desktop";
    /**
     * Extensions are accessed from a web browser.
     */
    UIKind[UIKind["Web"] = 2] = "Web";
})(UIKind || (exports.UIKind = UIKind = {}));
var ExtensionKind;
(function (ExtensionKind) {
    /**
     * Extension runs where the UI runs.
     */
    ExtensionKind[ExtensionKind["UI"] = 1] = "UI";
    /**
     * Extension runs where the remote extension host runs.
     */
    ExtensionKind[ExtensionKind["Workspace"] = 2] = "Workspace";
})(ExtensionKind || (exports.ExtensionKind = ExtensionKind = {}));
exports.PluginManager = Symbol.for('PluginManager');
exports.emptyPlugin = {
    lifecycle: {
        startMethod: 'empty',
        stopMethod: 'empty'
    },
    model: {
        id: 'emptyPlugin',
        name: 'emptyPlugin',
        publisher: 'Theia',
        version: 'empty',
        displayName: 'empty',
        description: 'empty',
        engine: {
            type: 'empty',
            version: 'empty'
        },
        packagePath: 'empty',
        packageUri: 'empty',
        entryPoint: {}
    },
    pluginPath: 'empty',
    pluginFolder: 'empty',
    pluginUri: 'empty',
    rawModel: {
        name: 'emptyPlugin',
        publisher: 'Theia',
        version: 'empty',
        displayName: 'empty',
        description: 'empty',
        engines: {
            type: 'empty',
            version: 'empty'
        },
        packagePath: 'empty'
    },
    isUnderDevelopment: false
};
var MainMessageType;
(function (MainMessageType) {
    MainMessageType[MainMessageType["Error"] = 0] = "Error";
    MainMessageType[MainMessageType["Warning"] = 1] = "Warning";
    MainMessageType[MainMessageType["Info"] = 2] = "Info";
})(MainMessageType || (exports.MainMessageType = MainMessageType = {}));
class DataTransferFileDTO {
    constructor(name, contentId, uri) {
        this.name = name;
        this.contentId = contentId;
        this.uri = uri;
    }
    static is(value) {
        return !(typeof value === 'string');
    }
}
exports.DataTransferFileDTO = DataTransferFileDTO;
var TreeViewItemReference;
(function (TreeViewItemReference) {
    function is(arg) {
        return (0, common_1.isObject)(arg) && (0, common_1.isString)(arg.viewId) && (0, common_1.isString)(arg.itemId);
    }
    TreeViewItemReference.is = is;
})(TreeViewItemReference || (exports.TreeViewItemReference = TreeViewItemReference = {}));
/**
 * Collapsible state of the tree item
 */
var TreeViewItemCollapsibleState;
(function (TreeViewItemCollapsibleState) {
    /**
     * Determines an item can be neither collapsed nor expanded. Implies it has no children.
     */
    TreeViewItemCollapsibleState[TreeViewItemCollapsibleState["None"] = 0] = "None";
    /**
     * Determines an item is collapsed
     */
    TreeViewItemCollapsibleState[TreeViewItemCollapsibleState["Collapsed"] = 1] = "Collapsed";
    /**
     * Determines an item is expanded
     */
    TreeViewItemCollapsibleState[TreeViewItemCollapsibleState["Expanded"] = 2] = "Expanded";
})(TreeViewItemCollapsibleState || (exports.TreeViewItemCollapsibleState = TreeViewItemCollapsibleState = {}));
var ScmCommandArg;
(function (ScmCommandArg) {
    function is(arg) {
        return (0, common_1.isObject)(arg) && 'sourceControlHandle' in arg;
    }
    ScmCommandArg.is = is;
})(ScmCommandArg || (exports.ScmCommandArg = ScmCommandArg = {}));
var TimelineCommandArg;
(function (TimelineCommandArg) {
    function is(arg) {
        return (0, common_1.isObject)(arg) && 'timelineHandle' in arg;
    }
    TimelineCommandArg.is = is;
})(TimelineCommandArg || (exports.TimelineCommandArg = TimelineCommandArg = {}));
var CommentsCommandArg;
(function (CommentsCommandArg) {
    function is(arg) {
        return (0, common_1.isObject)(arg) && 'commentControlHandle' in arg && 'commentThreadHandle' in arg && 'text' in arg && !('commentUniqueId' in arg);
    }
    CommentsCommandArg.is = is;
})(CommentsCommandArg || (exports.CommentsCommandArg = CommentsCommandArg = {}));
var CommentsContextCommandArg;
(function (CommentsContextCommandArg) {
    function is(arg) {
        return (0, common_1.isObject)(arg) && 'commentControlHandle' in arg && 'commentThreadHandle' in arg && 'commentUniqueId' in arg && !('text' in arg);
    }
    CommentsContextCommandArg.is = is;
})(CommentsContextCommandArg || (exports.CommentsContextCommandArg = CommentsContextCommandArg = {}));
var CommentsEditCommandArg;
(function (CommentsEditCommandArg) {
    function is(arg) {
        return (0, common_1.isObject)(arg) && 'commentControlHandle' in arg && 'commentThreadHandle' in arg && 'commentUniqueId' in arg && 'text' in arg;
    }
    CommentsEditCommandArg.is = is;
})(CommentsEditCommandArg || (exports.CommentsEditCommandArg = CommentsEditCommandArg = {}));
var EditorPosition;
(function (EditorPosition) {
    EditorPosition[EditorPosition["ONE"] = 0] = "ONE";
    EditorPosition[EditorPosition["TWO"] = 1] = "TWO";
    EditorPosition[EditorPosition["THREE"] = 2] = "THREE";
    EditorPosition[EditorPosition["FOUR"] = 3] = "FOUR";
    EditorPosition[EditorPosition["FIVE"] = 4] = "FIVE";
    EditorPosition[EditorPosition["SIX"] = 5] = "SIX";
    EditorPosition[EditorPosition["SEVEN"] = 6] = "SEVEN";
    EditorPosition[EditorPosition["EIGHT"] = 7] = "EIGHT";
    EditorPosition[EditorPosition["NINE"] = 8] = "NINE";
})(EditorPosition || (exports.EditorPosition = EditorPosition = {}));
var TextEditorRevealType;
(function (TextEditorRevealType) {
    TextEditorRevealType[TextEditorRevealType["Default"] = 0] = "Default";
    TextEditorRevealType[TextEditorRevealType["InCenter"] = 1] = "InCenter";
    TextEditorRevealType[TextEditorRevealType["InCenterIfOutsideViewport"] = 2] = "InCenterIfOutsideViewport";
    TextEditorRevealType[TextEditorRevealType["AtTop"] = 3] = "AtTop";
})(TextEditorRevealType || (exports.TextEditorRevealType = TextEditorRevealType = {}));
/**
 * Describes the behavior of decorations when typing/editing near their edges.
 */
var TrackedRangeStickiness;
(function (TrackedRangeStickiness) {
    TrackedRangeStickiness[TrackedRangeStickiness["AlwaysGrowsWhenTypingAtEdges"] = 0] = "AlwaysGrowsWhenTypingAtEdges";
    TrackedRangeStickiness[TrackedRangeStickiness["NeverGrowsWhenTypingAtEdges"] = 1] = "NeverGrowsWhenTypingAtEdges";
    TrackedRangeStickiness[TrackedRangeStickiness["GrowsOnlyWhenTypingBefore"] = 2] = "GrowsOnlyWhenTypingBefore";
    TrackedRangeStickiness[TrackedRangeStickiness["GrowsOnlyWhenTypingAfter"] = 3] = "GrowsOnlyWhenTypingAfter";
})(TrackedRangeStickiness || (exports.TrackedRangeStickiness = TrackedRangeStickiness = {}));
var WorkspaceTextEditDto;
(function (WorkspaceTextEditDto) {
    function is(arg) {
        return !!arg
            && 'resource' in arg
            && 'textEdit' in arg
            && arg.textEdit !== null
            && typeof arg.textEdit === 'object';
    }
    WorkspaceTextEditDto.is = is;
})(WorkspaceTextEditDto || (exports.WorkspaceTextEditDto = WorkspaceTextEditDto = {}));
var WorkspaceNotebookCellEditDto;
(function (WorkspaceNotebookCellEditDto) {
    function is(arg) {
        return !!arg
            && 'resource' in arg
            && 'cellEdit' in arg
            && arg.cellEdit !== null
            && typeof arg.cellEdit === 'object';
    }
    WorkspaceNotebookCellEditDto.is = is;
})(WorkspaceNotebookCellEditDto || (exports.WorkspaceNotebookCellEditDto = WorkspaceNotebookCellEditDto = {}));
exports.LanguagesMainFactory = Symbol('LanguagesMainFactory');
exports.OutputChannelRegistryFactory = Symbol('OutputChannelRegistryFactory');
/**
 * A DebugConfigurationProviderTriggerKind specifies when the `provideDebugConfigurations` method of a `DebugConfigurationProvider` should be called.
 * Currently there are two situations:
 *  (1) providing debug configurations to populate a newly created `launch.json`
 *  (2) providing dynamically generated configurations when the user asks for them through the UI (e.g. via the "Select and Start Debugging" command).
 * A trigger kind is used when registering a `DebugConfigurationProvider` with {@link debug.registerDebugConfigurationProvider}.
 */
var DebugConfigurationProviderTriggerKind;
(function (DebugConfigurationProviderTriggerKind) {
    /**
     * `DebugConfigurationProvider.provideDebugConfigurations` is called to provide the initial debug
     * configurations for a newly created launch.json.
     */
    DebugConfigurationProviderTriggerKind[DebugConfigurationProviderTriggerKind["Initial"] = 1] = "Initial";
    /**
     * `DebugConfigurationProvider.provideDebugConfigurations` is called to provide dynamically generated debug configurations when the user asks for them through the UI
     * (e.g. via the "Select and Start Debugging" command).
     */
    DebugConfigurationProviderTriggerKind[DebugConfigurationProviderTriggerKind["Dynamic"] = 2] = "Dynamic";
})(DebugConfigurationProviderTriggerKind || (exports.DebugConfigurationProviderTriggerKind = DebugConfigurationProviderTriggerKind = {}));
exports.PLUGIN_RPC_CONTEXT = {
    AUTHENTICATION_MAIN: (0, rpc_protocol_1.createProxyIdentifier)('AuthenticationMain'),
    COMMAND_REGISTRY_MAIN: (0, rpc_protocol_1.createProxyIdentifier)('CommandRegistryMain'),
    QUICK_OPEN_MAIN: (0, rpc_protocol_1.createProxyIdentifier)('QuickOpenMain'),
    DIALOGS_MAIN: (0, rpc_protocol_1.createProxyIdentifier)('DialogsMain'),
    WORKSPACE_MAIN: (0, rpc_protocol_1.createProxyIdentifier)('WorkspaceMain'),
    MESSAGE_REGISTRY_MAIN: (0, rpc_protocol_1.createProxyIdentifier)('MessageRegistryMain'),
    TEXT_EDITORS_MAIN: (0, rpc_protocol_1.createProxyIdentifier)('TextEditorsMain'),
    DOCUMENTS_MAIN: (0, rpc_protocol_1.createProxyIdentifier)('DocumentsMain'),
    NOTEBOOKS_MAIN: (0, rpc_protocol_1.createProxyIdentifier)('NotebooksMain'),
    NOTEBOOK_DOCUMENTS_MAIN: (0, rpc_protocol_1.createProxyIdentifier)('NotebookDocumentsMain'),
    NOTEBOOK_EDITORS_MAIN: (0, rpc_protocol_1.createProxyIdentifier)('NotebookEditorsMain'),
    NOTEBOOK_DOCUMENTS_AND_EDITORS_MAIN: (0, rpc_protocol_1.createProxyIdentifier)('NotebooksAndEditorsMain'),
    NOTEBOOK_RENDERERS_MAIN: (0, rpc_protocol_1.createProxyIdentifier)('NotebookRenderersMain'),
    NOTEBOOK_KERNELS_MAIN: (0, rpc_protocol_1.createProxyIdentifier)('NotebookKernelsMain'),
    STATUS_BAR_MESSAGE_REGISTRY_MAIN: (0, rpc_protocol_1.createProxyIdentifier)('StatusBarMessageRegistryMain'),
    ENV_MAIN: (0, rpc_protocol_1.createProxyIdentifier)('EnvMain'),
    NOTIFICATION_MAIN: (0, rpc_protocol_1.createProxyIdentifier)('NotificationMain'),
    TERMINAL_MAIN: (0, rpc_protocol_1.createProxyIdentifier)('TerminalServiceMain'),
    TREE_VIEWS_MAIN: (0, rpc_protocol_1.createProxyIdentifier)('TreeViewsMain'),
    PREFERENCE_REGISTRY_MAIN: (0, rpc_protocol_1.createProxyIdentifier)('PreferenceRegistryMain'),
    OUTPUT_CHANNEL_REGISTRY_MAIN: (0, rpc_protocol_1.createProxyIdentifier)('OutputChannelRegistryMain'),
    LANGUAGES_MAIN: (0, rpc_protocol_1.createProxyIdentifier)('LanguagesMain'),
    CONNECTION_MAIN: (0, rpc_protocol_1.createProxyIdentifier)('ConnectionMain'),
    WEBVIEWS_MAIN: (0, rpc_protocol_1.createProxyIdentifier)('WebviewsMain'),
    CUSTOM_EDITORS_MAIN: (0, rpc_protocol_1.createProxyIdentifier)('CustomEditorsMain'),
    WEBVIEW_VIEWS_MAIN: (0, rpc_protocol_1.createProxyIdentifier)('WebviewViewsMain'),
    STORAGE_MAIN: (0, rpc_protocol_1.createProxyIdentifier)('StorageMain'),
    TASKS_MAIN: (0, rpc_protocol_1.createProxyIdentifier)('TasksMain'),
    DEBUG_MAIN: (0, rpc_protocol_1.createProxyIdentifier)('DebugMain'),
    FILE_SYSTEM_MAIN: (0, rpc_protocol_1.createProxyIdentifier)('FileSystemMain'),
    SCM_MAIN: (0, rpc_protocol_1.createProxyIdentifier)('ScmMain'),
    SECRETS_MAIN: (0, rpc_protocol_1.createProxyIdentifier)('SecretsMain'),
    DECORATIONS_MAIN: (0, rpc_protocol_1.createProxyIdentifier)('DecorationsMain'),
    WINDOW_MAIN: (0, rpc_protocol_1.createProxyIdentifier)('WindowMain'),
    CLIPBOARD_MAIN: (0, rpc_protocol_1.createProxyIdentifier)('ClipboardMain'),
    LABEL_SERVICE_MAIN: (0, rpc_protocol_1.createProxyIdentifier)('LabelServiceMain'),
    TIMELINE_MAIN: (0, rpc_protocol_1.createProxyIdentifier)('TimelineMain'),
    THEMING_MAIN: (0, rpc_protocol_1.createProxyIdentifier)('ThemingMain'),
    COMMENTS_MAIN: (0, rpc_protocol_1.createProxyIdentifier)('CommentsMain'),
    TABS_MAIN: (0, rpc_protocol_1.createProxyIdentifier)('TabsMain'),
    TELEMETRY_MAIN: (0, rpc_protocol_1.createProxyIdentifier)('TelemetryMain'),
    LOCALIZATION_MAIN: (0, rpc_protocol_1.createProxyIdentifier)('LocalizationMain'),
    TESTING_MAIN: (0, rpc_protocol_1.createProxyIdentifier)('TestingMain')
};
exports.MAIN_RPC_CONTEXT = {
    AUTHENTICATION_EXT: (0, rpc_protocol_1.createProxyIdentifier)('AuthenticationExt'),
    HOSTED_PLUGIN_MANAGER_EXT: (0, rpc_protocol_1.createProxyIdentifier)('PluginManagerExt'),
    COMMAND_REGISTRY_EXT: (0, rpc_protocol_1.createProxyIdentifier)('CommandRegistryExt'),
    QUICK_OPEN_EXT: (0, rpc_protocol_1.createProxyIdentifier)('QuickOpenExt'),
    WINDOW_STATE_EXT: (0, rpc_protocol_1.createProxyIdentifier)('WindowStateExt'),
    NOTIFICATION_EXT: (0, rpc_protocol_1.createProxyIdentifier)('NotificationExt'),
    WORKSPACE_EXT: (0, rpc_protocol_1.createProxyIdentifier)('WorkspaceExt'),
    TEXT_EDITORS_EXT: (0, rpc_protocol_1.createProxyIdentifier)('TextEditorsExt'),
    EDITORS_AND_DOCUMENTS_EXT: (0, rpc_protocol_1.createProxyIdentifier)('EditorsAndDocumentsExt'),
    DOCUMENTS_EXT: (0, rpc_protocol_1.createProxyIdentifier)('DocumentsExt'),
    NOTEBOOKS_EXT: (0, rpc_protocol_1.createProxyIdentifier)('NotebooksExt'),
    NOTEBOOK_DOCUMENTS_EXT: (0, rpc_protocol_1.createProxyIdentifier)('NotebookDocumentsExt'),
    NOTEBOOK_EDITORS_EXT: (0, rpc_protocol_1.createProxyIdentifier)('NotebookEditorsExt'),
    NOTEBOOK_RENDERERS_EXT: (0, rpc_protocol_1.createProxyIdentifier)('NotebooksRenderersExt'),
    NOTEBOOK_KERNELS_EXT: (0, rpc_protocol_1.createProxyIdentifier)('NotebookKernelsExt'),
    TERMINAL_EXT: (0, rpc_protocol_1.createProxyIdentifier)('TerminalServiceExt'),
    OUTPUT_CHANNEL_REGISTRY_EXT: (0, rpc_protocol_1.createProxyIdentifier)('OutputChannelRegistryExt'),
    TREE_VIEWS_EXT: (0, rpc_protocol_1.createProxyIdentifier)('TreeViewsExt'),
    PREFERENCE_REGISTRY_EXT: (0, rpc_protocol_1.createProxyIdentifier)('PreferenceRegistryExt'),
    LANGUAGES_EXT: (0, rpc_protocol_1.createProxyIdentifier)('LanguagesExt'),
    CONNECTION_EXT: (0, rpc_protocol_1.createProxyIdentifier)('ConnectionExt'),
    WEBVIEWS_EXT: (0, rpc_protocol_1.createProxyIdentifier)('WebviewsExt'),
    CUSTOM_EDITORS_EXT: (0, rpc_protocol_1.createProxyIdentifier)('CustomEditorsExt'),
    WEBVIEW_VIEWS_EXT: (0, rpc_protocol_1.createProxyIdentifier)('WebviewViewsExt'),
    STORAGE_EXT: (0, rpc_protocol_1.createProxyIdentifier)('StorageExt'),
    TASKS_EXT: (0, rpc_protocol_1.createProxyIdentifier)('TasksExt'),
    DEBUG_EXT: (0, rpc_protocol_1.createProxyIdentifier)('DebugExt'),
    FILE_SYSTEM_EXT: (0, rpc_protocol_1.createProxyIdentifier)('FileSystemExt'),
    ExtHostFileSystemEventService: (0, rpc_protocol_1.createProxyIdentifier)('ExtHostFileSystemEventService'),
    SCM_EXT: (0, rpc_protocol_1.createProxyIdentifier)('ScmExt'),
    SECRETS_EXT: (0, rpc_protocol_1.createProxyIdentifier)('SecretsExt'),
    DECORATIONS_EXT: (0, rpc_protocol_1.createProxyIdentifier)('DecorationsExt'),
    LABEL_SERVICE_EXT: (0, rpc_protocol_1.createProxyIdentifier)('LabelServiceExt'),
    TIMELINE_EXT: (0, rpc_protocol_1.createProxyIdentifier)('TimeLineExt'),
    THEMING_EXT: (0, rpc_protocol_1.createProxyIdentifier)('ThemingExt'),
    COMMENTS_EXT: (0, rpc_protocol_1.createProxyIdentifier)('CommentsExt'),
    TABS_EXT: (0, rpc_protocol_1.createProxyIdentifier)('TabsExt'),
    TELEMETRY_EXT: (0, rpc_protocol_1.createProxyIdentifier)('TelemetryExt)'),
    TESTING_EXT: (0, rpc_protocol_1.createProxyIdentifier)('TestingExt')
};
;
var NotebookEditorRevealType;
(function (NotebookEditorRevealType) {
    NotebookEditorRevealType[NotebookEditorRevealType["Default"] = 0] = "Default";
    NotebookEditorRevealType[NotebookEditorRevealType["InCenter"] = 1] = "InCenter";
    NotebookEditorRevealType[NotebookEditorRevealType["InCenterIfOutsideViewport"] = 2] = "InCenterIfOutsideViewport";
    NotebookEditorRevealType[NotebookEditorRevealType["AtTop"] = 3] = "AtTop";
})(NotebookEditorRevealType || (exports.NotebookEditorRevealType = NotebookEditorRevealType = {}));
exports.LocalizationExt = Symbol('LocalizationExt');


/***/ }),

/***/ "../node_modules/@theia/plugin-ext/lib/common/plugin-ext-api-contribution.js":
/*!***********************************************************************************!*\
  !*** ../node_modules/@theia/plugin-ext/lib/common/plugin-ext-api-contribution.js ***!
  \***********************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.MainPluginApiProvider = exports.ExtPluginApiProvider = void 0;
exports.ExtPluginApiProvider = 'extPluginApi';
exports.MainPluginApiProvider = Symbol('mainPluginApi');


/***/ }),

/***/ "../node_modules/@theia/plugin-ext/lib/common/plugin-identifiers.js":
/*!**************************************************************************!*\
  !*** ../node_modules/@theia/plugin-ext/lib/common/plugin-identifiers.js ***!
  \**************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

// *****************************************************************************
// Copyright (C) 2022 Ericsson and others.
//
// This program and the accompanying materials are made available under the
// terms of the Eclipse Public License v. 2.0 which is available at
// http://www.eclipse.org/legal/epl-2.0.
//
// This Source Code may also be made available under the following Secondary
// Licenses when the conditions for such availability set forth in the Eclipse
// Public License v. 2.0 are satisfied: GNU General Public License, version 2
// with the GNU Classpath Exception which is available at
// https://www.gnu.org/software/classpath/license.html.
//
// SPDX-License-Identifier: EPL-2.0 OR GPL-2.0-only WITH Classpath-exception-2.0
// *****************************************************************************
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.PluginIdentifiers = void 0;
var PluginIdentifiers;
(function (PluginIdentifiers) {
    /** Unpublished plugins (not from Open VSX or VSCode plugin store) may not have a `publisher` field. */
    PluginIdentifiers.UNPUBLISHED = '<unpublished>';
    /**
     * @returns a string in the format `<publisher>.<name>`
     */
    function componentsToUnversionedId({ publisher = PluginIdentifiers.UNPUBLISHED, name }) {
        return `${publisher.toLowerCase()}.${name.toLowerCase()}`;
    }
    PluginIdentifiers.componentsToUnversionedId = componentsToUnversionedId;
    /**
     * @returns a string in the format `<publisher>.<name>@<version>`.
     */
    function componentsToVersionedId({ publisher = PluginIdentifiers.UNPUBLISHED, name, version }) {
        return `${publisher.toLowerCase()}.${name.toLowerCase()}@${version}`;
    }
    PluginIdentifiers.componentsToVersionedId = componentsToVersionedId;
    function componentsToVersionWithId(components) {
        return { id: componentsToUnversionedId(components), version: components.version };
    }
    PluginIdentifiers.componentsToVersionWithId = componentsToVersionWithId;
    /**
     * @returns a string in the format `<id>@<version>`.
     */
    function idAndVersionToVersionedId({ id, version }) {
        return `${id}@${version}`;
    }
    PluginIdentifiers.idAndVersionToVersionedId = idAndVersionToVersionedId;
    /**
     * @returns a string in the format `<publisher>.<name>`.
     */
    function unversionedFromVersioned(id) {
        const endOfId = id.indexOf('@');
        return id.slice(0, endOfId);
    }
    PluginIdentifiers.unversionedFromVersioned = unversionedFromVersioned;
    /**
     * @returns `undefined` if it looks like the string passed in does not have the format returned by {@link PluginIdentifiers.toVersionedId}.
     */
    function identifiersFromVersionedId(probablyId) {
        const endOfPublisher = probablyId.indexOf('.');
        const endOfName = probablyId.indexOf('@', endOfPublisher);
        if (endOfPublisher === -1 || endOfName === -1) {
            return undefined;
        }
        return { publisher: probablyId.slice(0, endOfPublisher), name: probablyId.slice(endOfPublisher + 1, endOfName), version: probablyId.slice(endOfName + 1) };
    }
    PluginIdentifiers.identifiersFromVersionedId = identifiersFromVersionedId;
    /**
     * @returns `undefined` if it looks like the string passed in does not have the format returned by {@link PluginIdentifiers.toVersionedId}.
     */
    function idAndVersionFromVersionedId(probablyId) {
        const endOfPublisher = probablyId.indexOf('.');
        const endOfName = probablyId.indexOf('@', endOfPublisher);
        if (endOfPublisher === -1 || endOfName === -1) {
            return undefined;
        }
        return { id: probablyId.slice(0, endOfName), version: probablyId.slice(endOfName + 1) };
    }
    PluginIdentifiers.idAndVersionFromVersionedId = idAndVersionFromVersionedId;
})(PluginIdentifiers || (exports.PluginIdentifiers = PluginIdentifiers = {}));


/***/ }),

/***/ "../node_modules/@theia/plugin-ext/lib/common/plugin-protocol.js":
/*!***********************************************************************!*\
  !*** ../node_modules/@theia/plugin-ext/lib/common/plugin-protocol.js ***!
  \***********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.PluginHostEnvironmentVariable = exports.ServerPluginRunner = exports.PluginServer = exports.pluginServerJsonRpcPath = exports.PLUGIN_HOST_BACKEND = exports.HostedPluginServer = exports.PluginDeployerHandler = exports.HostedPluginClient = exports.buildFrontendModuleName = exports.getPluginId = exports.MetadataProcessor = exports.IconContribution = exports.PluginType = exports.PluginDeployerEntryType = exports.PluginDeployerParticipant = exports.PluginDeployer = exports.PluginDeployerFileHandler = exports.PluginDeployerDirectoryHandler = exports.PluginDeployerResolver = exports.PluginScanner = exports.PluginViewType = exports.CustomEditorPriority = exports.PluginPackage = exports.hostedServicePath = exports.PluginIdentifiers = void 0;
const plugin_identifiers_1 = __webpack_require__(/*! ./plugin-identifiers */ "../node_modules/@theia/plugin-ext/lib/common/plugin-identifiers.js");
Object.defineProperty(exports, "PluginIdentifiers", ({ enumerable: true, get: function () { return plugin_identifiers_1.PluginIdentifiers; } }));
exports.hostedServicePath = '/services/hostedPlugin';
var PluginPackage;
(function (PluginPackage) {
    function toPluginUrl(pck, relativePath) {
        return `hostedPlugin/${getPluginId(pck)}/${encodeURIComponent(relativePath)}`;
    }
    PluginPackage.toPluginUrl = toPluginUrl;
})(PluginPackage || (exports.PluginPackage = PluginPackage = {}));
var CustomEditorPriority;
(function (CustomEditorPriority) {
    CustomEditorPriority["default"] = "default";
    CustomEditorPriority["builtin"] = "builtin";
    CustomEditorPriority["option"] = "option";
})(CustomEditorPriority || (exports.CustomEditorPriority = CustomEditorPriority = {}));
var PluginViewType;
(function (PluginViewType) {
    PluginViewType["Tree"] = "tree";
    PluginViewType["Webview"] = "webview";
})(PluginViewType || (exports.PluginViewType = PluginViewType = {}));
exports.PluginScanner = Symbol('PluginScanner');
/**
 * A plugin resolver is handling how to resolve a plugin link into a local resource.
 */
exports.PluginDeployerResolver = Symbol('PluginDeployerResolver');
exports.PluginDeployerDirectoryHandler = Symbol('PluginDeployerDirectoryHandler');
exports.PluginDeployerFileHandler = Symbol('PluginDeployerFileHandler');
exports.PluginDeployer = Symbol('PluginDeployer');
exports.PluginDeployerParticipant = Symbol('PluginDeployerParticipant');
var PluginDeployerEntryType;
(function (PluginDeployerEntryType) {
    PluginDeployerEntryType[PluginDeployerEntryType["FRONTEND"] = 0] = "FRONTEND";
    PluginDeployerEntryType[PluginDeployerEntryType["BACKEND"] = 1] = "BACKEND";
    PluginDeployerEntryType[PluginDeployerEntryType["HEADLESS"] = 2] = "HEADLESS"; // Deployed in the Theia Node server outside the context of a frontend/backend connection
})(PluginDeployerEntryType || (exports.PluginDeployerEntryType = PluginDeployerEntryType = {}));
/**
 * Whether a plugin installed by a user or system.
 */
var PluginType;
(function (PluginType) {
    PluginType[PluginType["System"] = 0] = "System";
    PluginType[PluginType["User"] = 1] = "User";
})(PluginType || (exports.PluginType = PluginType = {}));
;
var IconContribution;
(function (IconContribution) {
    function isIconDefinition(defaults) {
        return 'fontCharacter' in defaults;
    }
    IconContribution.isIconDefinition = isIconDefinition;
})(IconContribution || (exports.IconContribution = IconContribution = {}));
exports.MetadataProcessor = Symbol('MetadataProcessor');
function getPluginId(plugin) {
    return `${plugin.publisher}_${plugin.name}`.replace(/\W/g, '_');
}
exports.getPluginId = getPluginId;
function buildFrontendModuleName(plugin) {
    return `${plugin.publisher}_${plugin.name}`.replace(/\W/g, '_');
}
exports.buildFrontendModuleName = buildFrontendModuleName;
exports.HostedPluginClient = Symbol('HostedPluginClient');
exports.PluginDeployerHandler = Symbol('PluginDeployerHandler');
exports.HostedPluginServer = Symbol('HostedPluginServer');
exports.PLUGIN_HOST_BACKEND = 'main';
/**
 * The JSON-RPC workspace interface.
 */
exports.pluginServerJsonRpcPath = '/services/plugin-ext';
exports.PluginServer = Symbol('PluginServer');
exports.ServerPluginRunner = Symbol('ServerPluginRunner');
exports.PluginHostEnvironmentVariable = Symbol('PluginHostEnvironmentVariable');


/***/ }),

/***/ "../node_modules/@theia/plugin-ext/lib/common/proxy-handler.js":
/*!*********************************************************************!*\
  !*** ../node_modules/@theia/plugin-ext/lib/common/proxy-handler.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.RpcInvocationHandler = exports.ClientProxyHandler = void 0;
/********************************************************************************
 * Copyright (C) 2022 STMicroelectronics and others.
 *
 * This program and the accompanying materials are made available under the
 * terms of the Eclipse Public License v. 2.0 which is available at
 * http://www.eclipse.org/legal/epl-2.0.
 *
 * This Source Code may also be made available under the following Secondary
 * Licenses when the conditions for such availability set forth in the Eclipse
 * Public License v. 2.0 are satisfied: GNU General Public License, version 2
 * with the GNU Classpath Exception which is available at
 * https://www.gnu.org/software/classpath/license.html.
 *
 * SPDX-License-Identifier: EPL-2.0 OR GPL-2.0-only WITH Classpath-exception-2.0
 ********************************************************************************/
/* eslint-disable @typescript-eslint/no-explicit-any */
const core_1 = __webpack_require__(/*! @theia/core/ */ "../node_modules/@theia/core/lib/common/index.js");
const promise_util_1 = __webpack_require__(/*! @theia/core/lib/common/promise-util */ "../node_modules/@theia/core/lib/common/promise-util.js");
/**
 * A proxy handler that will send any method invocation on the proxied object
 * as a rcp protocol message over a channel.
 */
class ClientProxyHandler {
    constructor(options) {
        this.rpcDeferred = new promise_util_1.Deferred();
        this.isRpcInitialized = false;
        Object.assign(this, options);
    }
    initializeRpc() {
        // we need to set the flag to true before waiting for the channel provider. Otherwise `get` might
        // get called again and we'll try to open a channel more than once
        this.proxySynchronizer.startProxyInitialization(this.id, this.rpcDeferred.promise.then(() => { }));
        this.isRpcInitialized = true;
        const clientOptions = { encoder: this.encoder, decoder: this.decoder, mode: 'clientOnly' };
        this.channelProvider().then(channel => {
            const rpc = new core_1.RpcProtocol(channel, undefined, clientOptions);
            this.rpcDeferred.resolve(rpc);
        });
    }
    get(target, name, receiver) {
        if (!this.isRpcInitialized) {
            this.initializeRpc();
        }
        if (target[name] || name.charCodeAt(0) !== 36 /* CharCode.DollarSign */) {
            return target[name];
        }
        const isNotify = this.isNotification(name);
        return (...args) => {
            const method = name.toString();
            return this.sendWhenNoInit(async (connection) => {
                if (isNotify) {
                    connection.sendNotification(method, args);
                }
                else {
                    return await connection.sendRequest(method, args);
                }
            });
        };
    }
    sendWhenNoInit(send) {
        return this.proxySynchronizer.pendingProxyInitializations().then(() => this.rpcDeferred.promise.then(send));
    }
    /**
     * Return whether the given property represents a notification. If true,
     * the promise returned from the invocation will resolve immediately to `undefined`
     *
     * A property leads to a notification rather than a method call if its name
     * begins with `notify` or `on`.
     *
     * @param p - The property being called on the proxy.
     * @return Whether `p` represents a notification.
     */
    isNotification(p) {
        let propertyString = p.toString();
        if (propertyString.charCodeAt(0) === 36 /* CharCode.DollarSign */) {
            propertyString = propertyString.substring(1);
        }
        return propertyString.startsWith('notify') || propertyString.startsWith('on');
    }
}
exports.ClientProxyHandler = ClientProxyHandler;
class RpcInvocationHandler {
    constructor(options) {
        this.rpcDeferred = new promise_util_1.Deferred();
        Object.assign(this, options);
    }
    listen(channel) {
        const serverOptions = { encoder: this.encoder, decoder: this.decoder, mode: 'serverOnly' };
        const server = new core_1.RpcProtocol(channel, (method, args) => this.handleRequest(method, args), serverOptions);
        server.onNotification((e) => this.onNotification(e.method, e.args));
        this.rpcDeferred.resolve(server);
    }
    handleRequest(method, args) {
        return this.rpcDeferred.promise.then(() => this.target[method](...args));
    }
    onNotification(method, args) {
        this.rpcDeferred.promise.then(() => {
            this.target[method](...args);
        });
    }
}
exports.RpcInvocationHandler = RpcInvocationHandler;


/***/ }),

/***/ "../node_modules/@theia/plugin-ext/lib/common/rpc-protocol.js":
/*!********************************************************************!*\
  !*** ../node_modules/@theia/plugin-ext/lib/common/rpc-protocol.js ***!
  \********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

// *****************************************************************************
// Copyright (C) 2018 Red Hat, Inc. and others.
//
// This program and the accompanying materials are made available under the
// terms of the Eclipse Public License v. 2.0 which is available at
// http://www.eclipse.org/legal/epl-2.0.
//
// This Source Code may also be made available under the following Secondary
// Licenses when the conditions for such availability set forth in the Eclipse
// Public License v. 2.0 are satisfied: GNU General Public License, version 2
// with the GNU Classpath Exception which is available at
// https://www.gnu.org/software/classpath/license.html.
//
// SPDX-License-Identifier: EPL-2.0 OR GPL-2.0-only WITH Classpath-exception-2.0
// *****************************************************************************
/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
// copied from https://github.com/Microsoft/vscode/blob/master/src/vs/workbench/services/extensions/node/rpcProtocol.ts
// with small modifications
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.registerMsgPackExtensions = exports.BatchingChannel = exports.ProxySynchronizerImpl = exports.RPCProtocolImpl = exports.ConnectionClosedError = exports.createProxyIdentifier = exports.ProxyIdentifier = exports.RPCProtocol = void 0;
/* eslint-disable @typescript-eslint/no-explicit-any */
const core_1 = __webpack_require__(/*! @theia/core */ "../node_modules/@theia/core/lib/common/index.js");
const event_1 = __webpack_require__(/*! @theia/core/lib/common/event */ "../node_modules/@theia/core/lib/common/event.js");
const channel_1 = __webpack_require__(/*! @theia/core/lib/common/message-rpc/channel */ "../node_modules/@theia/core/lib/common/message-rpc/channel.js");
const rpc_message_encoder_1 = __webpack_require__(/*! @theia/core/lib/common/message-rpc/rpc-message-encoder */ "../node_modules/@theia/core/lib/common/message-rpc/rpc-message-encoder.js");
const uint8_array_message_buffer_1 = __webpack_require__(/*! @theia/core/lib/common/message-rpc/uint8-array-message-buffer */ "../node_modules/@theia/core/lib/common/message-rpc/uint8-array-message-buffer.js");
const proxy_handler_1 = __webpack_require__(/*! ./proxy-handler */ "../node_modules/@theia/plugin-ext/lib/common/proxy-handler.js");
const msg_pack_extension_manager_1 = __webpack_require__(/*! @theia/core/lib/common/message-rpc/msg-pack-extension-manager */ "../node_modules/@theia/core/lib/common/message-rpc/msg-pack-extension-manager.js");
const vscode_uri_1 = __webpack_require__(/*! @theia/core/shared/vscode-uri */ "../node_modules/@theia/core/shared/vscode-uri/index.js");
const buffer_1 = __webpack_require__(/*! @theia/core/lib/common/buffer */ "../node_modules/@theia/core/lib/common/buffer.js");
const types_impl_1 = __webpack_require__(/*! ../plugin/types-impl */ "../node_modules/@theia/plugin-ext/lib/plugin/types-impl.js");
const promise_util_1 = __webpack_require__(/*! @theia/core/lib/common/promise-util */ "../node_modules/@theia/core/lib/common/promise-util.js");
exports.RPCProtocol = Symbol.for('RPCProtocol');
class ProxyIdentifier {
    constructor(isMain, id) {
        this.isMain = isMain;
        // TODO this is nasty, rewrite this
        this.id = id.toString();
    }
}
exports.ProxyIdentifier = ProxyIdentifier;
function createProxyIdentifier(identifier) {
    return new ProxyIdentifier(false, identifier);
}
exports.createProxyIdentifier = createProxyIdentifier;
var ConnectionClosedError;
(function (ConnectionClosedError) {
    const code = 'RPC_PROTOCOL_CLOSED';
    function create(message = 'connection is closed') {
        return Object.assign(new Error(message), { code });
    }
    ConnectionClosedError.create = create;
    function is(error) {
        return (0, core_1.isObject)(error) && 'code' in error && error.code === code;
    }
    ConnectionClosedError.is = is;
})(ConnectionClosedError || (exports.ConnectionClosedError = ConnectionClosedError = {}));
class RPCProtocolImpl {
    constructor(channel) {
        this.locals = new Map();
        this.proxies = new Map();
        this.encoder = new rpc_message_encoder_1.MsgPackMessageEncoder();
        this.decoder = new rpc_message_encoder_1.MsgPackMessageDecoder();
        this.toDispose = new core_1.DisposableCollection(core_1.Disposable.create(() => { }));
        this.toDispose.push(this.multiplexer = new channel_1.ChannelMultiplexer(new BatchingChannel(channel)));
        this.toDispose.push(core_1.Disposable.create(() => this.proxies.clear()));
        this.initCallback = new ProxySynchronizerImpl();
    }
    dispose() {
        this.toDispose.dispose();
    }
    get isDisposed() {
        return this.toDispose.disposed;
    }
    getProxy(proxyId) {
        if (this.isDisposed) {
            throw ConnectionClosedError.create();
        }
        let proxy = this.proxies.get(proxyId.id);
        if (!proxy) {
            proxy = this.createProxy(proxyId.id);
            this.proxies.set(proxyId.id, proxy);
        }
        return proxy;
    }
    createProxy(proxyId) {
        const handler = new proxy_handler_1.ClientProxyHandler({
            id: proxyId, encoder: this.encoder, decoder: this.decoder, channelProvider: () => this.multiplexer.open(proxyId), proxySynchronizer: this.initCallback
        });
        return new Proxy(Object.create(null), handler);
    }
    set(identifier, instance) {
        if (this.isDisposed) {
            throw ConnectionClosedError.create();
        }
        const invocationHandler = this.locals.get(identifier.id);
        if (!invocationHandler) {
            const handler = new proxy_handler_1.RpcInvocationHandler({ id: identifier.id, target: instance, encoder: this.encoder, decoder: this.decoder });
            const channel = this.multiplexer.getOpenChannel(identifier.id);
            if (channel) {
                handler.listen(channel);
            }
            else {
                const channelOpenListener = this.multiplexer.onDidOpenChannel(event => {
                    if (event.id === identifier.id) {
                        handler.listen(event.channel);
                        channelOpenListener.dispose();
                    }
                });
            }
            this.locals.set(identifier.id, handler);
            if (core_1.Disposable.is(instance)) {
                this.toDispose.push(instance);
            }
            this.toDispose.push(core_1.Disposable.create(() => this.locals.delete(identifier.id)));
        }
        return instance;
    }
}
exports.RPCProtocolImpl = RPCProtocolImpl;
class ProxySynchronizerImpl {
    constructor() {
        this.runningInitializations = new Set();
        this._pendingProxyInitializations = new promise_util_1.Deferred();
        /* after creation no init is active */
        this._pendingProxyInitializations.resolve();
    }
    startProxyInitialization(id, init) {
        if (this.runningInitializations.size === 0) {
            this._pendingProxyInitializations = new promise_util_1.Deferred();
        }
        init.then(() => this.finishedProxyInitialization(id));
        this.runningInitializations.add(id);
    }
    finishedProxyInitialization(id) {
        this.runningInitializations.delete(id);
        if (this.runningInitializations.size === 0) {
            this._pendingProxyInitializations.resolve();
        }
    }
    pendingProxyInitializations() {
        return this._pendingProxyInitializations.promise;
    }
}
exports.ProxySynchronizerImpl = ProxySynchronizerImpl;
/**
 * Wraps and underlying channel to send/receive multiple messages in one go:
 *  - multiple messages to be sent from one stack get sent in bulk at `process.nextTick`.
 *  - each incoming message is handled in a separate `process.nextTick`.
 */
class BatchingChannel {
    constructor(underlyingChannel) {
        this.underlyingChannel = underlyingChannel;
        this.messagesToSend = [];
        this.onMessageEmitter = new event_1.Emitter();
        this.onClose = this.underlyingChannel.onClose;
        this.onError = this.underlyingChannel.onError;
        underlyingChannel.onMessage(msg => this.handleMessages(msg()));
    }
    get onMessage() {
        return this.onMessageEmitter.event;
    }
    ;
    close() {
        this.underlyingChannel.close();
        this.onMessageEmitter.dispose();
        this.messagesToSend = [];
    }
    getWriteBuffer() {
        const writer = new uint8_array_message_buffer_1.Uint8ArrayWriteBuffer();
        writer.onCommit(buffer => this.commitSingleMessage(buffer));
        return writer;
    }
    commitSingleMessage(msg) {
        if (this.messagesToSend.length === 0) {
            if (typeof setImmediate !== 'undefined') {
                setImmediate(() => this.sendAccumulated());
            }
            else {
                setTimeout(() => this.sendAccumulated(), 0);
            }
        }
        this.messagesToSend.push(msg);
    }
    sendAccumulated() {
        const cachedMessages = this.messagesToSend;
        this.messagesToSend = [];
        const writer = this.underlyingChannel.getWriteBuffer();
        if (cachedMessages.length > 0) {
            writer.writeLength(cachedMessages.length);
            cachedMessages.forEach(msg => {
                writer.writeBytes(msg);
            });
        }
        writer.commit();
    }
    handleMessages(buffer) {
        // Read in the list of messages and dispatch each message individually
        const length = buffer.readLength();
        if (length > 0) {
            for (let index = 0; index < length; index++) {
                const message = buffer.readBytes();
                this.onMessageEmitter.fire(() => new uint8_array_message_buffer_1.Uint8ArrayReadBuffer(message));
            }
        }
    }
}
exports.BatchingChannel = BatchingChannel;
function registerMsgPackExtensions() {
    msg_pack_extension_manager_1.MsgPackExtensionManager.getInstance().registerExtensions({
        class: core_1.URI,
        tag: 2,
        serialize: (instance) => instance.toString(),
        deserialize: data => new core_1.URI(data)
    }, {
        class: types_impl_1.Range,
        tag: 3,
        serialize: (range) => ({
            start: {
                line: range.start.line,
                character: range.start.character
            },
            end: {
                line: range.end.line,
                character: range.end.character
            }
        }),
        deserialize: data => {
            const start = new types_impl_1.Position(data.start.line, data.start.character);
            const end = new types_impl_1.Position(data.end.line, data.end.character);
            return new types_impl_1.Range(start, end);
        }
    }, {
        class: vscode_uri_1.URI,
        tag: 4,
        // eslint-disable-next-line arrow-body-style
        serialize: (instance) => {
            return instance.toString();
        },
        deserialize: data => vscode_uri_1.URI.parse(data)
    }, {
        class: buffer_1.BinaryBuffer,
        tag: 5,
        // eslint-disable-next-line arrow-body-style
        serialize: (instance) => {
            return instance.buffer;
        },
        // eslint-disable-next-line arrow-body-style
        deserialize: buffer => {
            return buffer_1.BinaryBuffer.wrap(buffer);
        }
    });
}
exports.registerMsgPackExtensions = registerMsgPackExtensions;


/***/ }),

/***/ "../node_modules/@theia/plugin-ext/lib/common/types.js":
/*!*************************************************************!*\
  !*** ../node_modules/@theia/plugin-ext/lib/common/types.js ***!
  \*************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

// *****************************************************************************
// Copyright (C) 2018 Red Hat, Inc. and others.
//
// This program and the accompanying materials are made available under the
// terms of the Eclipse Public License v. 2.0 which is available at
// http://www.eclipse.org/legal/epl-2.0.
//
// This Source Code may also be made available under the following Secondary
// Licenses when the conditions for such availability set forth in the Eclipse
// Public License v. 2.0 are satisfied: GNU General Public License, version 2
// with the GNU Classpath Exception which is available at
// https://www.gnu.org/software/classpath/license.html.
//
// SPDX-License-Identifier: EPL-2.0 OR GPL-2.0-only WITH Classpath-exception-2.0
// *****************************************************************************
// copied from https://github.com/microsoft/vscode/blob/1.37.0/src/vs/base/common/types.ts
/*---------------------------------------------------------------------------------------------
*  Copyright (c) Microsoft Corporation. All rights reserved.
*  Licensed under the MIT License. See License.txt in the project root for license information.
*--------------------------------------------------------------------------------------------*/
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.assertIsDefined = exports.isUndefinedOrNull = exports.isUndefined = exports.isArray = exports.es5ClassCompat = exports.LogType = exports.mixin = exports.isObject = void 0;
const common_1 = __webpack_require__(/*! @theia/core/lib/common */ "../node_modules/@theia/core/lib/common/index.js");
/**
 * Returns `true` if the parameter has type "object" and not null, an array, a regexp, a date.
 */
function isObject(obj) {
    return (0, common_1.isObject)(obj)
        && !Array.isArray(obj)
        && !(obj instanceof RegExp)
        && !(obj instanceof Date);
}
exports.isObject = isObject;
// eslint-disable-next-line @typescript-eslint/no-explicit-any
function mixin(destination, source, overwrite = true) {
    if (!isObject(destination)) {
        return source;
    }
    if (isObject(source)) {
        Object.keys(source).forEach(key => {
            if (key in destination) {
                if (overwrite) {
                    if (isObject(destination[key]) && isObject(source[key])) {
                        mixin(destination[key], source[key], overwrite);
                    }
                    else {
                        destination[key] = source[key];
                    }
                }
            }
            else {
                destination[key] = source[key];
            }
        });
    }
    return destination;
}
exports.mixin = mixin;
var LogType;
(function (LogType) {
    LogType[LogType["Info"] = 0] = "Info";
    LogType[LogType["Error"] = 1] = "Error";
})(LogType || (exports.LogType = LogType = {}));
/* eslint-disable @typescript-eslint/no-explicit-any */
/** copied from https://github.com/TypeFox/vscode/blob/70b8db24a37fafc77247de7f7cb5bb0195120ed0/src/vs/workbench/api/common/extHostTypes.ts#L18-L27 */
function es5ClassCompat(target) {
    // @ts-ignore
    function _() { return Reflect.construct(target, arguments, this.constructor); }
    Object.defineProperty(_, 'name', Object.getOwnPropertyDescriptor(target, 'name'));
    Object.setPrototypeOf(_, target);
    Object.setPrototypeOf(_.prototype, target.prototype);
    return _;
}
exports.es5ClassCompat = es5ClassCompat;
/* eslint-enable @typescript-eslint/no-explicit-any */
const _typeof = {
    number: 'number',
    string: 'string',
    undefined: 'undefined',
    object: 'object',
    function: 'function'
};
/* eslint-disable @typescript-eslint/no-explicit-any */
/**
 * @returns whether the provided parameter is a JavaScript Array or not.
 */
function isArray(array) {
    if (Array.isArray) {
        return Array.isArray(array);
    }
    if (array && typeof (array.length) === _typeof.number && array.constructor === Array) {
        return true;
    }
    return false;
}
exports.isArray = isArray;
/**
 * @returns whether the provided parameter is undefined.
 */
function isUndefined(obj) {
    return typeof (obj) === _typeof.undefined;
}
exports.isUndefined = isUndefined;
/**
 * @returns whether the provided parameter is undefined or null.
 */
function isUndefinedOrNull(obj) {
    return isUndefined(obj) || obj === null; // eslint-disable-line no-null/no-null
}
exports.isUndefinedOrNull = isUndefinedOrNull;
/**
 * Asserts that the argument passed in is neither undefined nor null.
 */
function assertIsDefined(arg) {
    if (isUndefinedOrNull(arg)) {
        throw new Error('Assertion Failed: argument is undefined or null');
    }
    return arg;
}
exports.assertIsDefined = assertIsDefined;


/***/ }),

/***/ "../node_modules/@theia/plugin-ext/lib/common/uri-components.js":
/*!**********************************************************************!*\
  !*** ../node_modules/@theia/plugin-ext/lib/common/uri-components.js ***!
  \**********************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

// *****************************************************************************
// Copyright (C) 2018 Red Hat, Inc. and others.
//
// This program and the accompanying materials are made available under the
// terms of the Eclipse Public License v. 2.0 which is available at
// http://www.eclipse.org/legal/epl-2.0.
//
// This Source Code may also be made available under the following Secondary
// Licenses when the conditions for such availability set forth in the Eclipse
// Public License v. 2.0 are satisfied: GNU General Public License, version 2
// with the GNU Classpath Exception which is available at
// https://www.gnu.org/software/classpath/license.html.
//
// SPDX-License-Identifier: EPL-2.0 OR GPL-2.0-only WITH Classpath-exception-2.0
// *****************************************************************************
/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Schemes = void 0;
// some well known URI schemas
// based on https://github.com/microsoft/vscode/blob/04c36be045a94fee58e5f8992d3e3fd980294a84/src/vs/base/common/network.ts#L9-L79
// TODO move to network.ts file
var Schemes;
(function (Schemes) {
    /**
     * A schema that is used for models that exist in memory
     * only and that have no correspondence on a server or such.
     */
    Schemes.inMemory = 'inmemory';
    /**
     * A schema that is used for setting files
     */
    Schemes.vscode = 'vscode';
    /**
     * A schema that is used for internal private files
     */
    Schemes.internal = 'private';
    /**
     * A walk-through document.
     */
    Schemes.walkThrough = 'walkThrough';
    /**
     * An embedded code snippet.
     */
    Schemes.walkThroughSnippet = 'walkThroughSnippet';
    Schemes.http = 'http';
    Schemes.https = 'https';
    Schemes.file = 'file';
    Schemes.mailto = 'mailto';
    Schemes.untitled = 'untitled';
    Schemes.data = 'data';
    Schemes.command = 'command';
    Schemes.vscodeRemote = 'vscode-remote';
    Schemes.vscodeRemoteResource = 'vscode-remote-resource';
    Schemes.userData = 'vscode-userdata';
    Schemes.vscodeCustomEditor = 'vscode-custom-editor';
    Schemes.vscodeSettings = 'vscode-settings';
    Schemes.webviewPanel = 'webview-panel';
})(Schemes || (exports.Schemes = Schemes = {}));


/***/ }),

/***/ "../node_modules/@theia/plugin-ext/lib/main/browser/hierarchy/hierarchy-types-converters.js":
/*!**************************************************************************************************!*\
  !*** ../node_modules/@theia/plugin-ext/lib/main/browser/hierarchy/hierarchy-types-converters.js ***!
  \**************************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

// *****************************************************************************
// Copyright (C) 2020 Red Hat, Inc. and others.
//
// This program and the accompanying materials are made available under the
// terms of the Eclipse Public License v. 2.0 which is available at
// http://www.eclipse.org/legal/epl-2.0.
//
// This Source Code may also be made available under the following Secondary
// Licenses when the conditions for such availability set forth in the Eclipse
// Public License v. 2.0 are satisfied: GNU General Public License, version 2
// with the GNU Classpath Exception which is available at
// https://www.gnu.org/software/classpath/license.html.
//
// SPDX-License-Identifier: EPL-2.0 OR GPL-2.0-only WITH Classpath-exception-2.0
// *****************************************************************************
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.fromCallHierarchyCalleeToModelCallHierarchyOutgoingCall = exports.fromCallHierarchyCallerToModelCallHierarchyIncomingCall = exports.toCallee = exports.fromCaller = exports.toCaller = exports.fromItemHierarchyDefinition = exports.toItemHierarchyDefinition = exports.SymbolKindConverter = exports.toRange = exports.fromRange = exports.fromPosition = exports.toLocation = exports.fromLocation = exports.fromUriComponents = exports.toUriComponents = void 0;
const languageProtocol = __webpack_require__(/*! @theia/core/shared/vscode-languageserver-protocol */ "../node_modules/@theia/core/shared/vscode-languageserver-protocol/index.js");
const vscode_uri_1 = __webpack_require__(/*! @theia/core/shared/vscode-uri */ "../node_modules/@theia/core/shared/vscode-uri/index.js");
const model = __webpack_require__(/*! ../../../common/plugin-api-rpc-model */ "../node_modules/@theia/plugin-ext/lib/common/plugin-api-rpc-model.js");
function toUriComponents(uri) {
    return vscode_uri_1.URI.parse(uri);
}
exports.toUriComponents = toUriComponents;
function fromUriComponents(uri) {
    return vscode_uri_1.URI.revive(uri).toString();
}
exports.fromUriComponents = fromUriComponents;
function fromLocation(location) {
    return {
        uri: vscode_uri_1.URI.parse(location.uri),
        range: fromRange(location.range)
    };
}
exports.fromLocation = fromLocation;
function toLocation(uri, range) {
    return {
        uri: vscode_uri_1.URI.revive(uri).toString(),
        range: toRange(range)
    };
}
exports.toLocation = toLocation;
function fromPosition(position) {
    return {
        lineNumber: position.line,
        column: position.character
    };
}
exports.fromPosition = fromPosition;
function fromRange(range) {
    const { start, end } = range;
    return {
        startLineNumber: start.line + 1,
        startColumn: start.character + 1,
        endLineNumber: end.line + 1,
        endColumn: end.character + 1,
    };
}
exports.fromRange = fromRange;
function toRange(range) {
    return languageProtocol.Range.create(range.startLineNumber - 1, range.startColumn - 1, range.endLineNumber - 1, range.endColumn - 1);
}
exports.toRange = toRange;
var SymbolKindConverter;
(function (SymbolKindConverter) {
    function fromSymbolKind(kind) {
        switch (kind) {
            case languageProtocol.SymbolKind.File: return model.SymbolKind.File;
            case languageProtocol.SymbolKind.Module: return model.SymbolKind.Module;
            case languageProtocol.SymbolKind.Namespace: return model.SymbolKind.Namespace;
            case languageProtocol.SymbolKind.Package: return model.SymbolKind.Package;
            case languageProtocol.SymbolKind.Class: return model.SymbolKind.Class;
            case languageProtocol.SymbolKind.Method: return model.SymbolKind.Method;
            case languageProtocol.SymbolKind.Property: return model.SymbolKind.Property;
            case languageProtocol.SymbolKind.Field: return model.SymbolKind.Field;
            case languageProtocol.SymbolKind.Constructor: return model.SymbolKind.Constructor;
            case languageProtocol.SymbolKind.Enum: return model.SymbolKind.Enum;
            case languageProtocol.SymbolKind.Interface: return model.SymbolKind.Interface;
            case languageProtocol.SymbolKind.Function: return model.SymbolKind.Function;
            case languageProtocol.SymbolKind.Variable: return model.SymbolKind.Variable;
            case languageProtocol.SymbolKind.Constant: return model.SymbolKind.Constant;
            case languageProtocol.SymbolKind.String: return model.SymbolKind.String;
            case languageProtocol.SymbolKind.Number: return model.SymbolKind.Number;
            case languageProtocol.SymbolKind.Boolean: return model.SymbolKind.Boolean;
            case languageProtocol.SymbolKind.Array: return model.SymbolKind.Array;
            case languageProtocol.SymbolKind.Object: return model.SymbolKind.Object;
            case languageProtocol.SymbolKind.Key: return model.SymbolKind.Key;
            case languageProtocol.SymbolKind.Null: return model.SymbolKind.Null;
            case languageProtocol.SymbolKind.EnumMember: return model.SymbolKind.EnumMember;
            case languageProtocol.SymbolKind.Struct: return model.SymbolKind.Struct;
            case languageProtocol.SymbolKind.Event: return model.SymbolKind.Event;
            case languageProtocol.SymbolKind.Operator: return model.SymbolKind.Operator;
            case languageProtocol.SymbolKind.TypeParameter: return model.SymbolKind.TypeParameter;
            default: return model.SymbolKind.Property;
        }
    }
    SymbolKindConverter.fromSymbolKind = fromSymbolKind;
    function toSymbolKind(kind) {
        switch (kind) {
            case model.SymbolKind.File: return languageProtocol.SymbolKind.File;
            case model.SymbolKind.Module: return languageProtocol.SymbolKind.Module;
            case model.SymbolKind.Namespace: return languageProtocol.SymbolKind.Namespace;
            case model.SymbolKind.Package: return languageProtocol.SymbolKind.Package;
            case model.SymbolKind.Class: return languageProtocol.SymbolKind.Class;
            case model.SymbolKind.Method: return languageProtocol.SymbolKind.Method;
            case model.SymbolKind.Property: return languageProtocol.SymbolKind.Property;
            case model.SymbolKind.Field: return languageProtocol.SymbolKind.Field;
            case model.SymbolKind.Constructor: return languageProtocol.SymbolKind.Constructor;
            case model.SymbolKind.Enum: return languageProtocol.SymbolKind.Enum;
            case model.SymbolKind.Interface: return languageProtocol.SymbolKind.Interface;
            case model.SymbolKind.Function: return languageProtocol.SymbolKind.Function;
            case model.SymbolKind.Variable: return languageProtocol.SymbolKind.Variable;
            case model.SymbolKind.Constant: return languageProtocol.SymbolKind.Constant;
            case model.SymbolKind.String: return languageProtocol.SymbolKind.String;
            case model.SymbolKind.Number: return languageProtocol.SymbolKind.Number;
            case model.SymbolKind.Boolean: return languageProtocol.SymbolKind.Boolean;
            case model.SymbolKind.Array: return languageProtocol.SymbolKind.Array;
            case model.SymbolKind.Object: return languageProtocol.SymbolKind.Object;
            case model.SymbolKind.Key: return languageProtocol.SymbolKind.Key;
            case model.SymbolKind.Null: return languageProtocol.SymbolKind.Null;
            case model.SymbolKind.EnumMember: return languageProtocol.SymbolKind.EnumMember;
            case model.SymbolKind.Struct: return languageProtocol.SymbolKind.Struct;
            case model.SymbolKind.Event: return languageProtocol.SymbolKind.Event;
            case model.SymbolKind.Operator: return languageProtocol.SymbolKind.Operator;
            case model.SymbolKind.TypeParameter: return languageProtocol.SymbolKind.TypeParameter;
            default: return languageProtocol.SymbolKind.Property;
        }
    }
    SymbolKindConverter.toSymbolKind = toSymbolKind;
})(SymbolKindConverter || (exports.SymbolKindConverter = SymbolKindConverter = {}));
function toItemHierarchyDefinition(modelItem) {
    return {
        ...modelItem,
        kind: SymbolKindConverter.toSymbolKind(modelItem.kind),
        range: toRange(modelItem.range),
        selectionRange: toRange(modelItem.selectionRange),
    };
}
exports.toItemHierarchyDefinition = toItemHierarchyDefinition;
function fromItemHierarchyDefinition(definition) {
    return {
        ...definition,
        kind: SymbolKindConverter.fromSymbolKind(definition.kind),
        range: fromRange(definition.range),
        selectionRange: fromRange(definition.range),
    };
}
exports.fromItemHierarchyDefinition = fromItemHierarchyDefinition;
function toCaller(caller) {
    return {
        from: toItemHierarchyDefinition(caller.from),
        fromRanges: caller.fromRanges.map(toRange)
    };
}
exports.toCaller = toCaller;
function fromCaller(caller) {
    return {
        from: fromItemHierarchyDefinition(caller.from),
        fromRanges: caller.fromRanges.map(fromRange)
    };
}
exports.fromCaller = fromCaller;
function toCallee(callee) {
    return {
        to: toItemHierarchyDefinition(callee.to),
        fromRanges: callee.fromRanges.map(toRange),
    };
}
exports.toCallee = toCallee;
function fromCallHierarchyCallerToModelCallHierarchyIncomingCall(caller) {
    return {
        from: fromItemHierarchyDefinition(caller.from),
        fromRanges: caller.fromRanges.map(fromRange),
    };
}
exports.fromCallHierarchyCallerToModelCallHierarchyIncomingCall = fromCallHierarchyCallerToModelCallHierarchyIncomingCall;
function fromCallHierarchyCalleeToModelCallHierarchyOutgoingCall(callee) {
    return {
        to: fromItemHierarchyDefinition(callee.to),
        fromRanges: callee.fromRanges.map(fromRange),
    };
}
exports.fromCallHierarchyCalleeToModelCallHierarchyOutgoingCall = fromCallHierarchyCalleeToModelCallHierarchyOutgoingCall;


/***/ }),

/***/ "../node_modules/@theia/plugin-ext/lib/plugin/markdown-string.js":
/*!***********************************************************************!*\
  !*** ../node_modules/@theia/plugin-ext/lib/plugin/markdown-string.js ***!
  \***********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

// *****************************************************************************
// Copyright (C) 2018 Red Hat, Inc. and others.
//
// This program and the accompanying materials are made available under the
// terms of the Eclipse Public License v. 2.0 which is available at
// http://www.eclipse.org/legal/epl-2.0.
//
// This Source Code may also be made available under the following Secondary
// Licenses when the conditions for such availability set forth in the Eclipse
// Public License v. 2.0 are satisfied: GNU General Public License, version 2
// with the GNU Classpath Exception which is available at
// https://www.gnu.org/software/classpath/license.html.
//
// SPDX-License-Identifier: EPL-2.0 OR GPL-2.0-only WITH Classpath-exception-2.0
// *****************************************************************************
var _MarkdownString_delegate;
var MarkdownString_1;
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.MarkdownString = void 0;
const tslib_1 = __webpack_require__(/*! tslib */ "../node_modules/tslib/tslib.es6.mjs");
const markdown_rendering_1 = __webpack_require__(/*! @theia/core/lib/common/markdown-rendering */ "../node_modules/@theia/core/lib/common/markdown-rendering/index.js");
const types_1 = __webpack_require__(/*! ../common/types */ "../node_modules/@theia/plugin-ext/lib/common/types.js");
const types_impl_1 = __webpack_require__(/*! ./types-impl */ "../node_modules/@theia/plugin-ext/lib/plugin/types-impl.js");
// Copied from https://github.com/microsoft/vscode/blob/7d9b1c37f8e5ae3772782ba3b09d827eb3fdd833/src/vs/workbench/api/common/extHostTypes.ts
let MarkdownString = MarkdownString_1 = class MarkdownString {
    /**
     * @returns whether the thing is a markdown string implementation with helper methods.
     */
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    static isMarkdownString(thing) {
        if (thing instanceof MarkdownString_1) {
            return true;
        }
        return thing && thing.appendCodeblock && thing.appendMarkdown && thing.appendText && (thing.value !== undefined);
    }
    constructor(value, supportThemeIcons = false) {
        _MarkdownString_delegate.set(this, void 0);
        tslib_1.__classPrivateFieldSet(this, _MarkdownString_delegate, new markdown_rendering_1.MarkdownStringImpl(value, { supportThemeIcons }), "f");
    }
    get value() {
        return tslib_1.__classPrivateFieldGet(this, _MarkdownString_delegate, "f").value;
    }
    set value(value) {
        tslib_1.__classPrivateFieldGet(this, _MarkdownString_delegate, "f").value = value;
    }
    get isTrusted() {
        return tslib_1.__classPrivateFieldGet(this, _MarkdownString_delegate, "f").isTrusted;
    }
    set isTrusted(value) {
        tslib_1.__classPrivateFieldGet(this, _MarkdownString_delegate, "f").isTrusted = value;
    }
    get supportThemeIcons() {
        return tslib_1.__classPrivateFieldGet(this, _MarkdownString_delegate, "f").supportThemeIcons;
    }
    set supportThemeIcons(value) {
        tslib_1.__classPrivateFieldGet(this, _MarkdownString_delegate, "f").supportThemeIcons = value;
    }
    get supportHtml() {
        return tslib_1.__classPrivateFieldGet(this, _MarkdownString_delegate, "f").supportHtml;
    }
    set supportHtml(value) {
        tslib_1.__classPrivateFieldGet(this, _MarkdownString_delegate, "f").supportHtml = value;
    }
    get baseUri() {
        return types_impl_1.URI.revive(tslib_1.__classPrivateFieldGet(this, _MarkdownString_delegate, "f").baseUri);
    }
    set baseUri(value) {
        tslib_1.__classPrivateFieldGet(this, _MarkdownString_delegate, "f").baseUri = value;
    }
    appendText(value) {
        tslib_1.__classPrivateFieldGet(this, _MarkdownString_delegate, "f").appendText(value);
        return this;
    }
    appendMarkdown(value) {
        tslib_1.__classPrivateFieldGet(this, _MarkdownString_delegate, "f").appendMarkdown(value);
        return this;
    }
    appendCodeblock(value, language) {
        tslib_1.__classPrivateFieldGet(this, _MarkdownString_delegate, "f").appendCodeblock(language !== null && language !== void 0 ? language : '', value);
        return this;
    }
    toJSON() {
        const plainObject = { value: this.value };
        if (this.isTrusted !== undefined) {
            plainObject.isTrusted = this.isTrusted;
        }
        if (this.supportThemeIcons !== undefined) {
            plainObject.supportThemeIcons = this.supportThemeIcons;
        }
        if (this.supportHtml !== undefined) {
            plainObject.supportHtml = this.supportHtml;
        }
        if (this.baseUri !== undefined) {
            plainObject.baseUri = this.baseUri.toJSON();
        }
        return plainObject;
    }
};
exports.MarkdownString = MarkdownString;
_MarkdownString_delegate = new WeakMap();
exports.MarkdownString = MarkdownString = MarkdownString_1 = tslib_1.__decorate([
    types_1.es5ClassCompat,
    tslib_1.__metadata("design:paramtypes", [String, Boolean])
], MarkdownString);


/***/ }),

/***/ "../node_modules/@theia/plugin-ext/lib/plugin/type-converters.js":
/*!***********************************************************************!*\
  !*** ../node_modules/@theia/plugin-ext/lib/plugin/type-converters.js ***!
  \***********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

// *****************************************************************************
// Copyright (C) 2018 Red Hat, Inc. and others.
//
// This program and the accompanying materials are made available under the
// terms of the Eclipse Public License v. 2.0 which is available at
// http://www.eclipse.org/legal/epl-2.0.
//
// This Source Code may also be made available under the following Secondary
// Licenses when the conditions for such availability set forth in the Eclipse
// Public License v. 2.0 are satisfied: GNU General Public License, version 2
// with the GNU Classpath Exception which is available at
// https://www.gnu.org/software/classpath/license.html.
//
// SPDX-License-Identifier: EPL-2.0 OR GPL-2.0-only WITH Classpath-exception-2.0
// *****************************************************************************
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.fromHierarchyItem = exports.toLocation = exports.isModelCallHierarchyOutgoingCall = exports.isModelCallHierarchyIncomingCall = exports.isModelCallHierarchyItem = exports.isUriComponents = exports.isModelRange = exports.isModelLocation = exports.toSymbolTag = exports.fromSymbolTag = exports.toDocumentSymbol = exports.fromDocumentSymbol = exports.toCodeActionTriggerKind = exports.SymbolKind = exports.fromWorkspaceEdit = exports.SignatureHelp = exports.SignatureInformation = exports.ParameterInformation = exports.fromDocumentHighlight = exports.fromDocumentHighlightKind = exports.DocumentLink = exports.fromDefinitionLink = exports.fromTextDocumentShowOptions = exports.fromLocation = exports.toInlineValueContext = exports.fromInlineValue = exports.fromEvaluatableExpression = exports.fromHover = exports.convertCode = exports.convertDiagnosticToMarkerData = exports.fromTextEdit = exports.toCompletionItemKind = exports.fromCompletionItemKind = exports.fromGlobPattern = exports.fromDocumentSelector = exports.toMarkdown = exports.fromMarkdownOrString = exports.fromMarkdown = exports.fromManyMarkdown = exports.fromRangeOrRangeWithMessage = exports.isDecorationOptionsArr = exports.toPosition = exports.fromPosition = exports.fromRange = exports.toRange = exports.fromSelection = exports.toSelection = exports.toWebviewPanelShowOptions = exports.fromViewColumn = exports.toViewColumn = void 0;
exports.NotebookKernelSourceAction = exports.NotebookRange = exports.NotebookCellExecutionSummary = exports.NotebookCellOutputConverter = exports.NotebookCellOutputItem = exports.NotebookCellOutput = exports.NotebookCellKind = exports.NotebookCellData = exports.NotebookData = exports.NotebookStatusBarItem = exports.NotebookDocumentContentOptions = exports.DataTransfer = exports.DataTransferItem = exports.InlayHintKind = exports.pluginToPluginInfo = exports.pathOrURIToURI = exports.ViewColumn = exports.ThemableDecorationAttachmentRenderOptions = exports.ThemableDecorationRenderOptions = exports.DecorationRangeBehavior = exports.DecorationRenderOptions = exports.convertToTransferQuickPickItems = exports.convertQuickInputButton = exports.convertIconPath = exports.fromColorPresentation = exports.toColor = exports.fromColor = exports.fromFoldingRangeKind = exports.fromFoldingRange = exports.fromSelectionRange = exports.toSymbolInformation = exports.fromSymbolInformation = exports.getShellExecutionOptions = exports.getShellArgs = exports.getCustomExecution = exports.getShellExecution = exports.getProcessExecution = exports.fromCustomExecution = exports.fromShellExecution = exports.fromProcessExecution = exports.toTask = exports.fromTask = exports.toWorkspaceFolder = exports.toTypeHierarchyItem = exports.fromTypeHierarchyItem = exports.isModelTypeHierarchyItem = exports.toCallHierarchyOutgoingCall = exports.toCallHierarchyIncomingCall = exports.toCallHierarchyItem = exports.fromCallHierarchyItem = void 0;
exports.TestItem = exports.TestMessage = void 0;
const lstypes = __webpack_require__(/*! @theia/core/shared/vscode-languageserver-protocol */ "../node_modules/@theia/core/shared/vscode-languageserver-protocol/index.js");
const types_impl_1 = __webpack_require__(/*! ./types-impl */ "../node_modules/@theia/plugin-ext/lib/plugin/types-impl.js");
const rpc = __webpack_require__(/*! ../common/plugin-api-rpc */ "../node_modules/@theia/plugin-ext/lib/common/plugin-api-rpc.js");
const plugin_api_rpc_1 = __webpack_require__(/*! ../common/plugin-api-rpc */ "../node_modules/@theia/plugin-ext/lib/common/plugin-api-rpc.js");
const model = __webpack_require__(/*! ../common/plugin-api-rpc-model */ "../node_modules/@theia/plugin-ext/lib/common/plugin-api-rpc-model.js");
const markdown_string_1 = __webpack_require__(/*! ./markdown-string */ "../node_modules/@theia/plugin-ext/lib/plugin/markdown-string.js");
const types = __webpack_require__(/*! ./types-impl */ "../node_modules/@theia/plugin-ext/lib/plugin/types-impl.js");
const arrays_1 = __webpack_require__(/*! ../common/arrays */ "../node_modules/@theia/plugin-ext/lib/common/arrays.js");
const common_1 = __webpack_require__(/*! @theia/core/lib/common */ "../node_modules/@theia/core/lib/common/index.js");
const notebooks = __webpack_require__(/*! @theia/notebook/lib/common */ "../node_modules/@theia/notebook/lib/common/index.js");
const buffer_1 = __webpack_require__(/*! @theia/core/lib/common/buffer */ "../node_modules/@theia/core/lib/common/buffer.js");
const common_2 = __webpack_require__(/*! @theia/notebook/lib/common */ "../node_modules/@theia/notebook/lib/common/index.js");
const markdown_rendering_1 = __webpack_require__(/*! @theia/core/lib/common/markdown-rendering */ "../node_modules/@theia/core/lib/common/markdown-rendering/index.js");
const themables_1 = __webpack_require__(/*! @theia/monaco-editor-core/esm/vs/base/common/themables */ "../node_modules/@theia/monaco-editor-core/esm/vs/base/common/themables.js");
const SIDE_GROUP = -2;
const ACTIVE_GROUP = -1;
function toViewColumn(ep) {
    if (typeof ep !== 'number') {
        return undefined;
    }
    if (ep === plugin_api_rpc_1.EditorPosition.ONE) {
        return types.ViewColumn.One;
    }
    else if (ep === plugin_api_rpc_1.EditorPosition.TWO) {
        return types.ViewColumn.Two;
    }
    else if (ep === plugin_api_rpc_1.EditorPosition.THREE) {
        return types.ViewColumn.Three;
    }
    else if (ep === plugin_api_rpc_1.EditorPosition.FOUR) {
        return types.ViewColumn.Four;
    }
    else if (ep === plugin_api_rpc_1.EditorPosition.FIVE) {
        return types.ViewColumn.Five;
    }
    else if (ep === plugin_api_rpc_1.EditorPosition.SIX) {
        return types.ViewColumn.Six;
    }
    else if (ep === plugin_api_rpc_1.EditorPosition.SEVEN) {
        return types.ViewColumn.Seven;
    }
    else if (ep === plugin_api_rpc_1.EditorPosition.EIGHT) {
        return types.ViewColumn.Eight;
    }
    else if (ep === plugin_api_rpc_1.EditorPosition.NINE) {
        return types.ViewColumn.Nine;
    }
    return undefined;
}
exports.toViewColumn = toViewColumn;
function fromViewColumn(column) {
    if (typeof column === 'number' && column >= types.ViewColumn.One) {
        return column - 1;
    }
    if (column === types.ViewColumn.Beside) {
        return SIDE_GROUP;
    }
    return ACTIVE_GROUP;
}
exports.fromViewColumn = fromViewColumn;
function toWebviewPanelShowOptions(options) {
    if (typeof options === 'object') {
        const showOptions = options;
        return {
            area: showOptions.area ? showOptions.area : types.WebviewPanelTargetArea.Main,
            viewColumn: showOptions.viewColumn ? fromViewColumn(showOptions.viewColumn) : undefined,
            preserveFocus: showOptions.preserveFocus ? showOptions.preserveFocus : false
        };
    }
    return {
        area: types.WebviewPanelTargetArea.Main,
        viewColumn: fromViewColumn(options),
        preserveFocus: false
    };
}
exports.toWebviewPanelShowOptions = toWebviewPanelShowOptions;
function toSelection(selection) {
    const { selectionStartLineNumber, selectionStartColumn, positionLineNumber, positionColumn } = selection;
    const start = new types.Position(selectionStartLineNumber - 1, selectionStartColumn - 1);
    const end = new types.Position(positionLineNumber - 1, positionColumn - 1);
    return new types.Selection(start, end);
}
exports.toSelection = toSelection;
function fromSelection(selection) {
    const { active, anchor } = selection;
    return {
        selectionStartLineNumber: anchor.line + 1,
        selectionStartColumn: anchor.character + 1,
        positionLineNumber: active.line + 1,
        positionColumn: active.character + 1
    };
}
exports.fromSelection = fromSelection;
function toRange(range) {
    const { startLineNumber, startColumn, endLineNumber, endColumn } = range;
    return new types.Range(startLineNumber - 1, startColumn - 1, endLineNumber - 1, endColumn - 1);
}
exports.toRange = toRange;
function fromRange(range) {
    if (!range) {
        return undefined;
    }
    const { start, end } = range;
    return {
        startLineNumber: start.line + 1,
        startColumn: start.character + 1,
        endLineNumber: end.line + 1,
        endColumn: end.character + 1
    };
}
exports.fromRange = fromRange;
function fromPosition(position) {
    return { lineNumber: position.line + 1, column: position.character + 1 };
}
exports.fromPosition = fromPosition;
function toPosition(position) {
    return new types.Position(position.lineNumber - 1, position.column - 1);
}
exports.toPosition = toPosition;
function isDecorationOptions(arg) {
    return (0, common_1.isObject)(arg) && typeof arg.range !== 'undefined';
}
function isDecorationOptionsArr(something) {
    if (something.length === 0) {
        return true;
    }
    return isDecorationOptions(something[0]) ? true : false;
}
exports.isDecorationOptionsArr = isDecorationOptionsArr;
function fromRangeOrRangeWithMessage(ranges) {
    if (isDecorationOptionsArr(ranges)) {
        return ranges.map(r => {
            let hoverMessage;
            if (Array.isArray(r.hoverMessage)) {
                hoverMessage = fromManyMarkdown(r.hoverMessage);
            }
            else if (r.hoverMessage) {
                hoverMessage = fromMarkdown(r.hoverMessage);
            }
            else {
                hoverMessage = undefined;
            }
            return {
                range: fromRange(r.range),
                hoverMessage: hoverMessage,
                // eslint-disable-next-line @typescript-eslint/no-explicit-any
                renderOptions: /* URI vs Uri */ r.renderOptions
            };
        });
    }
    else {
        return ranges.map(r => ({ range: fromRange(r) }));
    }
}
exports.fromRangeOrRangeWithMessage = fromRangeOrRangeWithMessage;
function fromManyMarkdown(markup) {
    return markup.map(fromMarkdown);
}
exports.fromManyMarkdown = fromManyMarkdown;
function isCodeblock(arg) {
    return (0, common_1.isObject)(arg)
        && typeof arg.language === 'string'
        && typeof arg.value === 'string';
}
function fromMarkdown(markup) {
    if (isCodeblock(markup)) {
        const { language, value } = markup;
        return { value: '```' + language + '\n' + value + '\n```\n' };
    }
    else if (markup instanceof markdown_string_1.MarkdownString) {
        return markup.toJSON();
    }
    else if (markdown_rendering_1.MarkdownString.is(markup)) {
        return markup;
    }
    else if (typeof markup === 'string') {
        return { value: markup };
    }
    else {
        return { value: '' };
    }
}
exports.fromMarkdown = fromMarkdown;
function fromMarkdownOrString(value) {
    if (value === undefined) {
        return undefined;
    }
    else if (typeof value === 'string') {
        return value;
    }
    else {
        return fromMarkdown(value);
    }
}
exports.fromMarkdownOrString = fromMarkdownOrString;
function toMarkdown(value) {
    const implemented = new markdown_string_1.MarkdownString(value.value, value.supportThemeIcons);
    implemented.isTrusted = value.isTrusted;
    implemented.supportHtml = value.supportHtml;
    implemented.baseUri = value.baseUri && types_impl_1.URI.revive(implemented.baseUri);
    return implemented;
}
exports.toMarkdown = toMarkdown;
function fromDocumentSelector(selector) {
    if (!selector) {
        return undefined;
    }
    else if ((0, arrays_1.isReadonlyArray)(selector)) {
        return selector.map(fromDocumentSelector);
    }
    else if (typeof selector === 'string') {
        return selector;
    }
    else {
        return {
            language: selector.language,
            scheme: selector.scheme,
            pattern: fromGlobPattern(selector.pattern)
        };
    }
}
exports.fromDocumentSelector = fromDocumentSelector;
function fromGlobPattern(pattern) {
    if (typeof pattern === 'string') {
        return pattern;
    }
    if (isRelativePattern(pattern)) {
        return new types.RelativePattern(pattern.baseUri, pattern.pattern);
    }
    return pattern;
}
exports.fromGlobPattern = fromGlobPattern;
function isRelativePattern(obj) {
    const rp = obj;
    return rp && typeof rp.baseUri === 'string' && typeof rp.pattern === 'string';
}
function fromCompletionItemKind(kind) {
    switch (kind) {
        case types.CompletionItemKind.Method: return model.CompletionItemKind.Method;
        case types.CompletionItemKind.Function: return model.CompletionItemKind.Function;
        case types.CompletionItemKind.Constructor: return model.CompletionItemKind.Constructor;
        case types.CompletionItemKind.Field: return model.CompletionItemKind.Field;
        case types.CompletionItemKind.Variable: return model.CompletionItemKind.Variable;
        case types.CompletionItemKind.Class: return model.CompletionItemKind.Class;
        case types.CompletionItemKind.Interface: return model.CompletionItemKind.Interface;
        case types.CompletionItemKind.Struct: return model.CompletionItemKind.Struct;
        case types.CompletionItemKind.Module: return model.CompletionItemKind.Module;
        case types.CompletionItemKind.Property: return model.CompletionItemKind.Property;
        case types.CompletionItemKind.Unit: return model.CompletionItemKind.Unit;
        case types.CompletionItemKind.Value: return model.CompletionItemKind.Value;
        case types.CompletionItemKind.Constant: return model.CompletionItemKind.Constant;
        case types.CompletionItemKind.Enum: return model.CompletionItemKind.Enum;
        case types.CompletionItemKind.EnumMember: return model.CompletionItemKind.EnumMember;
        case types.CompletionItemKind.Keyword: return model.CompletionItemKind.Keyword;
        case types.CompletionItemKind.Snippet: return model.CompletionItemKind.Snippet;
        case types.CompletionItemKind.Text: return model.CompletionItemKind.Text;
        case types.CompletionItemKind.Color: return model.CompletionItemKind.Color;
        case types.CompletionItemKind.File: return model.CompletionItemKind.File;
        case types.CompletionItemKind.Reference: return model.CompletionItemKind.Reference;
        case types.CompletionItemKind.Folder: return model.CompletionItemKind.Folder;
        case types.CompletionItemKind.Event: return model.CompletionItemKind.Event;
        case types.CompletionItemKind.Operator: return model.CompletionItemKind.Operator;
        case types.CompletionItemKind.TypeParameter: return model.CompletionItemKind.TypeParameter;
        case types.CompletionItemKind.User: return model.CompletionItemKind.User;
        case types.CompletionItemKind.Issue: return model.CompletionItemKind.Issue;
    }
    return model.CompletionItemKind.Property;
}
exports.fromCompletionItemKind = fromCompletionItemKind;
function toCompletionItemKind(kind) {
    switch (kind) {
        case model.CompletionItemKind.Method: return types.CompletionItemKind.Method;
        case model.CompletionItemKind.Function: return types.CompletionItemKind.Function;
        case model.CompletionItemKind.Constructor: return types.CompletionItemKind.Constructor;
        case model.CompletionItemKind.Field: return types.CompletionItemKind.Field;
        case model.CompletionItemKind.Variable: return types.CompletionItemKind.Variable;
        case model.CompletionItemKind.Class: return types.CompletionItemKind.Class;
        case model.CompletionItemKind.Interface: return types.CompletionItemKind.Interface;
        case model.CompletionItemKind.Struct: return types.CompletionItemKind.Struct;
        case model.CompletionItemKind.Module: return types.CompletionItemKind.Module;
        case model.CompletionItemKind.Property: return types.CompletionItemKind.Property;
        case model.CompletionItemKind.Unit: return types.CompletionItemKind.Unit;
        case model.CompletionItemKind.Value: return types.CompletionItemKind.Value;
        case model.CompletionItemKind.Constant: return types.CompletionItemKind.Constant;
        case model.CompletionItemKind.Enum: return types.CompletionItemKind.Enum;
        case model.CompletionItemKind.EnumMember: return types.CompletionItemKind.EnumMember;
        case model.CompletionItemKind.Keyword: return types.CompletionItemKind.Keyword;
        case model.CompletionItemKind.Snippet: return types.CompletionItemKind.Snippet;
        case model.CompletionItemKind.Text: return types.CompletionItemKind.Text;
        case model.CompletionItemKind.Color: return types.CompletionItemKind.Color;
        case model.CompletionItemKind.File: return types.CompletionItemKind.File;
        case model.CompletionItemKind.Reference: return types.CompletionItemKind.Reference;
        case model.CompletionItemKind.Folder: return types.CompletionItemKind.Folder;
        case model.CompletionItemKind.Event: return types.CompletionItemKind.Event;
        case model.CompletionItemKind.Operator: return types.CompletionItemKind.Operator;
        case model.CompletionItemKind.TypeParameter: return types.CompletionItemKind.TypeParameter;
        case model.CompletionItemKind.User: return types.CompletionItemKind.User;
        case model.CompletionItemKind.Issue: return types.CompletionItemKind.Issue;
    }
    return types.CompletionItemKind.Property;
}
exports.toCompletionItemKind = toCompletionItemKind;
function fromTextEdit(edit) {
    return {
        text: edit.newText,
        range: fromRange(edit.range)
    };
}
exports.fromTextEdit = fromTextEdit;
function fromSnippetTextEdit(edit) {
    return {
        text: edit.snippet.value,
        range: fromRange(edit.range),
        insertAsSnippet: true
    };
}
function convertDiagnosticToMarkerData(diagnostic) {
    return {
        code: convertCode(diagnostic.code),
        severity: convertSeverity(diagnostic.severity),
        message: diagnostic.message,
        source: diagnostic.source,
        startLineNumber: diagnostic.range.start.line + 1,
        startColumn: diagnostic.range.start.character + 1,
        endLineNumber: diagnostic.range.end.line + 1,
        endColumn: diagnostic.range.end.character + 1,
        relatedInformation: convertRelatedInformation(diagnostic.relatedInformation),
        tags: convertTags(diagnostic.tags)
    };
}
exports.convertDiagnosticToMarkerData = convertDiagnosticToMarkerData;
function convertCode(code) {
    if (typeof code === 'number') {
        return String(code);
    }
    if (typeof code === 'string' || typeof code === 'undefined') {
        return code;
    }
    else {
        return String(code.value);
    }
    ;
}
exports.convertCode = convertCode;
function convertSeverity(severity) {
    switch (severity) {
        case types.DiagnosticSeverity.Error: return types.MarkerSeverity.Error;
        case types.DiagnosticSeverity.Warning: return types.MarkerSeverity.Warning;
        case types.DiagnosticSeverity.Information: return types.MarkerSeverity.Info;
        case types.DiagnosticSeverity.Hint: return types.MarkerSeverity.Hint;
    }
}
function convertRelatedInformation(diagnosticsRelatedInformation) {
    if (!diagnosticsRelatedInformation) {
        return undefined;
    }
    const relatedInformation = [];
    for (const item of diagnosticsRelatedInformation) {
        relatedInformation.push({
            resource: item.location.uri.toString(),
            message: item.message,
            startLineNumber: item.location.range.start.line + 1,
            startColumn: item.location.range.start.character + 1,
            endLineNumber: item.location.range.end.line + 1,
            endColumn: item.location.range.end.character + 1
        });
    }
    return relatedInformation;
}
function convertTags(tags) {
    if (!tags) {
        return undefined;
    }
    const markerTags = [];
    for (const tag of tags) {
        switch (tag) {
            case types.DiagnosticTag.Unnecessary:
                markerTags.push(types.MarkerTag.Unnecessary);
                break;
            case types.DiagnosticTag.Deprecated:
                markerTags.push(types.MarkerTag.Deprecated);
                break;
        }
    }
    return markerTags;
}
function fromHover(hover) {
    return {
        range: fromRange(hover.range),
        contents: fromManyMarkdown(hover.contents)
    };
}
exports.fromHover = fromHover;
function fromEvaluatableExpression(evaluatableExpression) {
    return {
        range: fromRange(evaluatableExpression.range),
        expression: evaluatableExpression.expression
    };
}
exports.fromEvaluatableExpression = fromEvaluatableExpression;
function fromInlineValue(inlineValue) {
    if (inlineValue instanceof types_impl_1.InlineValueText) {
        return {
            type: 'text',
            range: fromRange(inlineValue.range),
            text: inlineValue.text
        };
    }
    else if (inlineValue instanceof types_impl_1.InlineValueVariableLookup) {
        return {
            type: 'variable',
            range: fromRange(inlineValue.range),
            variableName: inlineValue.variableName,
            caseSensitiveLookup: inlineValue.caseSensitiveLookup
        };
    }
    else if (inlineValue instanceof types_impl_1.InlineValueEvaluatableExpression) {
        return {
            type: 'expression',
            range: fromRange(inlineValue.range),
            expression: inlineValue.expression
        };
    }
    else {
        throw new Error('Unknown InlineValue type');
    }
}
exports.fromInlineValue = fromInlineValue;
function toInlineValueContext(inlineValueContext) {
    const ivLocation = inlineValueContext.stoppedLocation;
    return {
        frameId: inlineValueContext.frameId,
        stoppedLocation: new types.Range(ivLocation.startLineNumber, ivLocation.startColumn, ivLocation.endLineNumber, ivLocation.endColumn)
    };
}
exports.toInlineValueContext = toInlineValueContext;
function fromLocation(location) {
    if (!location) {
        return undefined;
    }
    return {
        uri: location.uri,
        range: fromRange(location.range)
    };
}
exports.fromLocation = fromLocation;
function fromTextDocumentShowOptions(options) {
    if (options.selection) {
        return {
            ...options,
            selection: fromRange(options.selection),
        };
    }
    return options;
}
exports.fromTextDocumentShowOptions = fromTextDocumentShowOptions;
function fromDefinitionLink(definitionLink) {
    return {
        uri: definitionLink.targetUri,
        range: fromRange(definitionLink.targetRange),
        originSelectionRange: definitionLink.originSelectionRange ? fromRange(definitionLink.originSelectionRange) : undefined,
        targetSelectionRange: definitionLink.targetSelectionRange ? fromRange(definitionLink.targetSelectionRange) : undefined
    };
}
exports.fromDefinitionLink = fromDefinitionLink;
var DocumentLink;
(function (DocumentLink) {
    function from(link) {
        return {
            range: fromRange(link.range),
            url: link.target,
            tooltip: link.tooltip
        };
    }
    DocumentLink.from = from;
    function to(link) {
        let target = undefined;
        if (link.url) {
            try {
                target = typeof link.url === 'string' ? types_impl_1.URI.parse(link.url, true) : types_impl_1.URI.revive(link.url);
            }
            catch (err) {
                // ignore
            }
        }
        return new types.DocumentLink(toRange(link.range), target);
    }
    DocumentLink.to = to;
})(DocumentLink || (exports.DocumentLink = DocumentLink = {}));
function fromDocumentHighlightKind(kind) {
    switch (kind) {
        case types.DocumentHighlightKind.Text: return model.DocumentHighlightKind.Text;
        case types.DocumentHighlightKind.Read: return model.DocumentHighlightKind.Read;
        case types.DocumentHighlightKind.Write: return model.DocumentHighlightKind.Write;
    }
    return model.DocumentHighlightKind.Text;
}
exports.fromDocumentHighlightKind = fromDocumentHighlightKind;
function fromDocumentHighlight(documentHighlight) {
    return {
        range: fromRange(documentHighlight.range),
        kind: fromDocumentHighlightKind(documentHighlight.kind)
    };
}
exports.fromDocumentHighlight = fromDocumentHighlight;
var ParameterInformation;
(function (ParameterInformation) {
    function from(info) {
        return {
            label: info.label,
            documentation: info.documentation ? fromMarkdown(info.documentation) : undefined
        };
    }
    ParameterInformation.from = from;
    function to(info) {
        return {
            label: info.label,
            documentation: markdown_rendering_1.MarkdownString.is(info.documentation) ? toMarkdown(info.documentation) : info.documentation
        };
    }
    ParameterInformation.to = to;
})(ParameterInformation || (exports.ParameterInformation = ParameterInformation = {}));
var SignatureInformation;
(function (SignatureInformation) {
    function from(info) {
        return {
            label: info.label,
            documentation: info.documentation ? fromMarkdown(info.documentation) : undefined,
            parameters: info.parameters && info.parameters.map(ParameterInformation.from),
            activeParameter: info.activeParameter
        };
    }
    SignatureInformation.from = from;
    function to(info) {
        return {
            label: info.label,
            documentation: markdown_rendering_1.MarkdownString.is(info.documentation) ? toMarkdown(info.documentation) : info.documentation,
            parameters: info.parameters && info.parameters.map(ParameterInformation.to),
            activeParameter: info.activeParameter
        };
    }
    SignatureInformation.to = to;
})(SignatureInformation || (exports.SignatureInformation = SignatureInformation = {}));
var SignatureHelp;
(function (SignatureHelp) {
    function from(id, help) {
        return {
            id,
            activeSignature: help.activeSignature,
            activeParameter: help.activeParameter,
            signatures: help.signatures && help.signatures.map(SignatureInformation.from)
        };
    }
    SignatureHelp.from = from;
    function to(help) {
        return {
            activeSignature: help.activeSignature,
            activeParameter: help.activeParameter,
            signatures: help.signatures && help.signatures.map(SignatureInformation.to)
        };
    }
    SignatureHelp.to = to;
})(SignatureHelp || (exports.SignatureHelp = SignatureHelp = {}));
// eslint-disable-next-line @typescript-eslint/no-explicit-any
function fromWorkspaceEdit(value, documents) {
    const result = {
        edits: []
    };
    for (const entry of value._allEntries()) {
        if ((entry === null || entry === void 0 ? void 0 : entry._type) === 2 /* types.FileEditType.Text */) {
            // text edits
            const doc = documents ? documents.getDocument(entry.uri.toString()) : undefined;
            const workspaceTextEditDto = {
                resource: entry.uri,
                modelVersionId: doc === null || doc === void 0 ? void 0 : doc.version,
                textEdit: (entry.edit instanceof types.TextEdit) ? fromTextEdit(entry.edit) : fromSnippetTextEdit(entry.edit),
                metadata: entry.metadata
            };
            result.edits.push(workspaceTextEditDto);
        }
        else if ((entry === null || entry === void 0 ? void 0 : entry._type) === 1 /* types.FileEditType.File */) {
            // resource edits
            const workspaceFileEditDto = {
                oldResource: entry.from,
                newResource: entry.to,
                options: entry.options,
                metadata: entry.metadata
            };
            result.edits.push(workspaceFileEditDto);
        }
        else if ((entry === null || entry === void 0 ? void 0 : entry._type) === 3 /* types.FileEditType.Cell */) {
            // cell edit
            if (entry.edit) {
                result.edits.push({
                    metadata: entry.metadata,
                    resource: entry.uri,
                    cellEdit: entry.edit,
                });
            }
        }
        else if ((entry === null || entry === void 0 ? void 0 : entry._type) === 5 /* types.FileEditType.CellReplace */) {
            // cell replace
            result.edits.push({
                metadata: entry.metadata,
                resource: entry.uri,
                cellEdit: {
                    editType: 1 /* notebooks.CellEditType.Replace */,
                    index: entry.index,
                    count: entry.count,
                    cells: entry.cells.map(NotebookCellData.from)
                }
            });
        }
    }
    return result;
}
exports.fromWorkspaceEdit = fromWorkspaceEdit;
var SymbolKind;
(function (SymbolKind) {
    const fromMapping = Object.create(null);
    fromMapping[model.SymbolKind.File] = model.SymbolKind.File;
    fromMapping[model.SymbolKind.Module] = model.SymbolKind.Module;
    fromMapping[model.SymbolKind.Namespace] = model.SymbolKind.Namespace;
    fromMapping[model.SymbolKind.Package] = model.SymbolKind.Package;
    fromMapping[model.SymbolKind.Class] = model.SymbolKind.Class;
    fromMapping[model.SymbolKind.Method] = model.SymbolKind.Method;
    fromMapping[model.SymbolKind.Property] = model.SymbolKind.Property;
    fromMapping[model.SymbolKind.Field] = model.SymbolKind.Field;
    fromMapping[model.SymbolKind.Constructor] = model.SymbolKind.Constructor;
    fromMapping[model.SymbolKind.Enum] = model.SymbolKind.Enum;
    fromMapping[model.SymbolKind.Interface] = model.SymbolKind.Interface;
    fromMapping[model.SymbolKind.Function] = model.SymbolKind.Function;
    fromMapping[model.SymbolKind.Variable] = model.SymbolKind.Variable;
    fromMapping[model.SymbolKind.Constant] = model.SymbolKind.Constant;
    fromMapping[model.SymbolKind.String] = model.SymbolKind.String;
    fromMapping[model.SymbolKind.Number] = model.SymbolKind.Number;
    fromMapping[model.SymbolKind.Boolean] = model.SymbolKind.Boolean;
    fromMapping[model.SymbolKind.Array] = model.SymbolKind.Array;
    fromMapping[model.SymbolKind.Object] = model.SymbolKind.Object;
    fromMapping[model.SymbolKind.Key] = model.SymbolKind.Key;
    fromMapping[model.SymbolKind.Null] = model.SymbolKind.Null;
    fromMapping[model.SymbolKind.EnumMember] = model.SymbolKind.EnumMember;
    fromMapping[model.SymbolKind.Struct] = model.SymbolKind.Struct;
    fromMapping[model.SymbolKind.Event] = model.SymbolKind.Event;
    fromMapping[model.SymbolKind.Operator] = model.SymbolKind.Operator;
    fromMapping[model.SymbolKind.TypeParameter] = model.SymbolKind.TypeParameter;
    function fromSymbolKind(kind) {
        return fromMapping[kind] || model.SymbolKind.Property;
    }
    SymbolKind.fromSymbolKind = fromSymbolKind;
    function toSymbolKind(kind) {
        for (const k in fromMapping) {
            if (fromMapping[k] === kind) {
                return Number(k);
            }
        }
        return model.SymbolKind.Property;
    }
    SymbolKind.toSymbolKind = toSymbolKind;
})(SymbolKind || (exports.SymbolKind = SymbolKind = {}));
function toCodeActionTriggerKind(triggerKind) {
    switch (triggerKind) {
        case model.CodeActionTriggerKind.Invoke:
            return types.CodeActionTriggerKind.Invoke;
        case model.CodeActionTriggerKind.Automatic:
            return types.CodeActionTriggerKind.Automatic;
    }
}
exports.toCodeActionTriggerKind = toCodeActionTriggerKind;
function fromDocumentSymbol(info) {
    const result = {
        name: info.name,
        detail: info.detail,
        range: fromRange(info.range),
        tags: info.tags ? info.tags.map(fromSymbolTag) : [],
        selectionRange: fromRange(info.selectionRange),
        kind: SymbolKind.fromSymbolKind(info.kind)
    };
    if (info.children) {
        result.children = info.children.map(fromDocumentSymbol);
    }
    return result;
}
exports.fromDocumentSymbol = fromDocumentSymbol;
function toDocumentSymbol(symbol) {
    return {
        name: symbol.name,
        detail: symbol.detail,
        range: toRange(symbol.range),
        tags: symbol.tags && symbol.tags.length > 0 ? symbol.tags.map(toSymbolTag) : [],
        selectionRange: toRange(symbol.selectionRange),
        children: symbol.children ? symbol.children.map(toDocumentSymbol) : [],
        kind: SymbolKind.toSymbolKind(symbol.kind)
    };
}
exports.toDocumentSymbol = toDocumentSymbol;
function fromSymbolTag(kind) {
    switch (kind) {
        case types.SymbolTag.Deprecated: return model.SymbolTag.Deprecated;
    }
}
exports.fromSymbolTag = fromSymbolTag;
function toSymbolTag(kind) {
    switch (kind) {
        case model.SymbolTag.Deprecated: return types.SymbolTag.Deprecated;
    }
}
exports.toSymbolTag = toSymbolTag;
function isModelLocation(arg) {
    return (0, common_1.isObject)(arg) &&
        isModelRange(arg.range) &&
        isUriComponents(arg.uri);
}
exports.isModelLocation = isModelLocation;
function isModelRange(arg) {
    return (0, common_1.isObject)(arg) &&
        typeof arg.startLineNumber === 'number' &&
        typeof arg.startColumn === 'number' &&
        typeof arg.endLineNumber === 'number' &&
        typeof arg.endColumn === 'number';
}
exports.isModelRange = isModelRange;
function isUriComponents(arg) {
    return (0, common_1.isObject)(arg) &&
        typeof arg.scheme === 'string' &&
        (arg['$mid'] === 1 || (typeof arg.path === 'string' &&
            typeof arg.query === 'string' &&
            typeof arg.fragment === 'string'));
}
exports.isUriComponents = isUriComponents;
function isModelCallHierarchyItem(arg) {
    return (0, common_1.isObject)(arg)
        && isModelRange(arg.range)
        && isModelRange(arg.selectionRange)
        && isUriComponents(arg.uri)
        && !!arg.name;
}
exports.isModelCallHierarchyItem = isModelCallHierarchyItem;
function isModelCallHierarchyIncomingCall(arg) {
    return (0, common_1.isObject)(arg) &&
        'from' in arg &&
        'fromRanges' in arg &&
        isModelCallHierarchyItem(arg.from);
}
exports.isModelCallHierarchyIncomingCall = isModelCallHierarchyIncomingCall;
function isModelCallHierarchyOutgoingCall(arg) {
    return (0, common_1.isObject)(arg) &&
        'to' in arg &&
        'fromRanges' in arg &&
        isModelCallHierarchyItem(arg.to);
}
exports.isModelCallHierarchyOutgoingCall = isModelCallHierarchyOutgoingCall;
function toLocation(value) {
    return new types.Location(types_impl_1.URI.revive(value.uri), toRange(value.range));
}
exports.toLocation = toLocation;
function fromHierarchyItem(item) {
    return {
        kind: SymbolKind.fromSymbolKind(item.kind),
        name: item.name,
        detail: item.detail,
        uri: item.uri,
        range: fromRange(item.range),
        selectionRange: fromRange(item.selectionRange),
        tags: item.tags,
        _itemId: item._itemId,
        _sessionId: item._sessionId,
    };
}
exports.fromHierarchyItem = fromHierarchyItem;
function fromCallHierarchyItem(item) {
    return fromHierarchyItem(item);
}
exports.fromCallHierarchyItem = fromCallHierarchyItem;
function toCallHierarchyItem(value) {
    const item = new types.CallHierarchyItem(SymbolKind.toSymbolKind(value.kind), value.name, value.detail ? value.detail : '', types_impl_1.URI.revive(value.uri), toRange(value.range), toRange(value.selectionRange));
    item.tags = value.tags;
    item._itemId = value._itemId;
    item._sessionId = value._sessionId;
    return item;
}
exports.toCallHierarchyItem = toCallHierarchyItem;
function toCallHierarchyIncomingCall(value) {
    return new types.CallHierarchyIncomingCall(toCallHierarchyItem(value.from), value.fromRanges && value.fromRanges.map(toRange));
}
exports.toCallHierarchyIncomingCall = toCallHierarchyIncomingCall;
function toCallHierarchyOutgoingCall(value) {
    return new types.CallHierarchyOutgoingCall(toCallHierarchyItem(value.to), value.fromRanges && value.fromRanges.map(toRange));
}
exports.toCallHierarchyOutgoingCall = toCallHierarchyOutgoingCall;
function isModelTypeHierarchyItem(arg) {
    return (0, common_1.isObject)(arg)
        && isModelRange(arg.range)
        && isModelRange(arg.selectionRange)
        && isUriComponents(arg.uri)
        && !!arg.name;
}
exports.isModelTypeHierarchyItem = isModelTypeHierarchyItem;
function fromTypeHierarchyItem(item) {
    return fromHierarchyItem(item);
}
exports.fromTypeHierarchyItem = fromTypeHierarchyItem;
function toTypeHierarchyItem(value) {
    const item = new types.TypeHierarchyItem(SymbolKind.toSymbolKind(value.kind), value.name, value.detail ? value.detail : '', types_impl_1.URI.revive(value.uri), toRange(value.selectionRange), toRange(value.range));
    item.tags = value.tags;
    item._itemId = value._itemId;
    item._sessionId = value._sessionId;
    return item;
}
exports.toTypeHierarchyItem = toTypeHierarchyItem;
function toWorkspaceFolder(folder) {
    return {
        uri: types_impl_1.URI.revive(folder.uri),
        name: folder.name,
        index: folder.index
    };
}
exports.toWorkspaceFolder = toWorkspaceFolder;
function fromTask(task) {
    if (!task) {
        return undefined;
    }
    const taskDto = {};
    taskDto.label = task.name;
    taskDto.source = task.source;
    taskDto.runOptions = { reevaluateOnRerun: task.runOptions.reevaluateOnRerun };
    if (task.hasProblemMatchers) {
        taskDto.problemMatcher = task.problemMatchers;
    }
    if ('detail' in task) {
        taskDto.detail = task.detail;
    }
    if (typeof task.scope === 'number') {
        taskDto.scope = task.scope;
    }
    else if (task.scope !== undefined) {
        taskDto.scope = task.scope.uri.toString();
    }
    else {
        taskDto.scope = types.TaskScope.Workspace;
    }
    if (task.presentationOptions) {
        taskDto.presentation = task.presentationOptions;
    }
    if (task.group) {
        taskDto.group = {
            kind: task.group.id,
            isDefault: !!task.group.isDefault
        };
    }
    const taskDefinition = task.definition;
    if (!taskDefinition) {
        return taskDto;
    }
    taskDto.type = taskDefinition.type;
    const { type, ...properties } = taskDefinition;
    for (const key in properties) {
        if (properties.hasOwnProperty(key)) {
            taskDto[key] = properties[key];
        }
    }
    const execution = task.execution;
    if (!execution) {
        return taskDto;
    }
    if (types.ShellExecution.is(execution)) {
        return fromShellExecution(execution, taskDto);
    }
    if (types.ProcessExecution.is(execution)) {
        return fromProcessExecution(execution, taskDto);
    }
    if (types.CustomExecution.is(execution)) {
        return fromCustomExecution(execution, taskDto);
    }
    return taskDto;
}
exports.fromTask = fromTask;
function toTask(taskDto) {
    if (!taskDto) {
        throw new Error('Task should be provided for converting');
    }
    const { type, taskType, label, source, scope, problemMatcher, detail, command, args, options, group, presentation, runOptions, ...properties } = taskDto;
    const result = {};
    result.name = label;
    result.source = source;
    result.runOptions = runOptions !== null && runOptions !== void 0 ? runOptions : {};
    if (detail) {
        result.detail = detail;
    }
    if (typeof scope === 'string') {
        const uri = types_impl_1.URI.parse(scope);
        result.scope = {
            uri,
            name: uri.toString(),
            index: 0
        };
    }
    else {
        result.scope = scope;
    }
    const taskDefinition = {
        type: type
    };
    result.definition = taskDefinition;
    if (taskType === 'process') {
        result.execution = getProcessExecution(taskDto);
    }
    const execution = { command, args, options };
    if (taskType === 'shell' || types.ShellExecution.is(execution)) {
        result.execution = getShellExecution(taskDto);
    }
    if (taskType === 'customExecution' || types.CustomExecution.is(execution)) {
        result.execution = getCustomExecution(taskDto);
        // if taskType is customExecution, we need to put all the information into taskDefinition,
        // because some parameters may be in taskDefinition.
        taskDefinition.label = label;
        taskDefinition.command = command;
        taskDefinition.args = args;
        taskDefinition.options = options;
    }
    if (group) {
        result.group = new types.TaskGroup(group.kind, group.kind, group.isDefault);
    }
    if (presentation) {
        result.presentationOptions = presentation;
    }
    if (!properties) {
        return result;
    }
    for (const key in properties) {
        if (properties.hasOwnProperty(key)) {
            taskDefinition[key] = properties[key];
        }
    }
    return result;
}
exports.toTask = toTask;
function fromProcessExecution(execution, taskDto) {
    taskDto.taskType = 'process';
    taskDto.command = execution.process;
    taskDto.args = execution.args;
    const options = execution.options;
    if (options) {
        taskDto.options = options;
    }
    return taskDto;
}
exports.fromProcessExecution = fromProcessExecution;
function fromShellExecution(execution, taskDto) {
    taskDto.taskType = 'shell';
    const options = execution.options;
    if (options) {
        taskDto.options = getShellExecutionOptions(options);
    }
    const commandLine = execution.commandLine;
    if (commandLine) {
        taskDto.command = commandLine;
        return taskDto;
    }
    if (execution.command) {
        taskDto.command = getCommand(execution.command);
        taskDto.args = getShellArgs(execution.args);
        return taskDto;
    }
    else {
        throw new Error('Command is undefined');
    }
}
exports.fromShellExecution = fromShellExecution;
function fromCustomExecution(execution, taskDto) {
    taskDto.taskType = 'customExecution';
    const callback = execution.callback;
    if (callback) {
        taskDto.callback = callback;
        return taskDto;
    }
    else {
        throw new Error('Converting CustomExecution callback is not implemented');
    }
}
exports.fromCustomExecution = fromCustomExecution;
function getProcessExecution(taskDto) {
    return new types.ProcessExecution(taskDto.command, taskDto.args || [], taskDto.options || {});
}
exports.getProcessExecution = getProcessExecution;
function getShellExecution(taskDto) {
    if (taskDto.command && Array.isArray(taskDto.args) && taskDto.args.length !== 0) {
        return new types.ShellExecution(taskDto.command, taskDto.args, taskDto.options || {});
    }
    return new types.ShellExecution(taskDto.command || taskDto.commandLine, taskDto.options || {});
}
exports.getShellExecution = getShellExecution;
function getCustomExecution(taskDto) {
    return new types.CustomExecution(taskDto.callback);
}
exports.getCustomExecution = getCustomExecution;
function getShellArgs(args) {
    if (!args || args.length === 0) {
        return [];
    }
    const element = args[0];
    if (typeof element === 'string') {
        return args;
    }
    const result = [];
    const shellQuotedArgs = args;
    shellQuotedArgs.forEach(arg => {
        result.push(arg.value);
    });
    return result;
}
exports.getShellArgs = getShellArgs;
function getCommand(command) {
    return typeof command === 'string' ? command : command.value;
}
// eslint-disable-next-line @typescript-eslint/no-explicit-any
function getShellExecutionOptions(options) {
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    const result = {};
    const env = options.env;
    if (env) {
        result['env'] = env;
    }
    const executable = options.executable;
    if (executable) {
        result['executable'] = executable;
    }
    const shellQuoting = options.shellQuoting;
    if (shellQuoting) {
        result['shellQuoting'] = shellQuoting;
    }
    const shellArgs = options.shellArgs;
    if (shellArgs) {
        result['shellArgs'] = shellArgs;
    }
    const cwd = options.cwd;
    if (cwd) {
        Object.assign(result, { cwd });
    }
    return result;
}
exports.getShellExecutionOptions = getShellExecutionOptions;
function fromSymbolInformation(symbolInformation) {
    if (!symbolInformation) {
        return undefined;
    }
    if (symbolInformation.location && symbolInformation.location.range) {
        const p1 = lstypes.Position.create(symbolInformation.location.range.start.line, symbolInformation.location.range.start.character);
        const p2 = lstypes.Position.create(symbolInformation.location.range.end.line, symbolInformation.location.range.end.character);
        return lstypes.SymbolInformation.create(symbolInformation.name, symbolInformation.kind++, lstypes.Range.create(p1, p2), symbolInformation.location.uri.toString(), symbolInformation.containerName);
    }
    return {
        name: symbolInformation.name,
        containerName: symbolInformation.containerName,
        kind: symbolInformation.kind++,
        location: {
            uri: symbolInformation.location.uri.toString(),
            range: symbolInformation.location.range,
        }
    };
}
exports.fromSymbolInformation = fromSymbolInformation;
function toSymbolInformation(symbolInformation) {
    if (!symbolInformation) {
        return undefined;
    }
    return {
        name: symbolInformation.name,
        containerName: symbolInformation.containerName,
        kind: symbolInformation.kind,
        location: {
            uri: types_impl_1.URI.parse(symbolInformation.location.uri),
            range: symbolInformation.location.range
        }
    };
}
exports.toSymbolInformation = toSymbolInformation;
function fromSelectionRange(selectionRange) {
    return { range: fromRange(selectionRange.range) };
}
exports.fromSelectionRange = fromSelectionRange;
function fromFoldingRange(foldingRange) {
    const range = {
        start: foldingRange.start + 1,
        end: foldingRange.end + 1
    };
    if (foldingRange.kind) {
        range.kind = fromFoldingRangeKind(foldingRange.kind);
    }
    return range;
}
exports.fromFoldingRange = fromFoldingRange;
function fromFoldingRangeKind(kind) {
    if (kind) {
        switch (kind) {
            case types.FoldingRangeKind.Comment:
                return model.FoldingRangeKind.Comment;
            case types.FoldingRangeKind.Imports:
                return model.FoldingRangeKind.Imports;
            case types.FoldingRangeKind.Region:
                return model.FoldingRangeKind.Region;
        }
    }
    return undefined;
}
exports.fromFoldingRangeKind = fromFoldingRangeKind;
function fromColor(color) {
    return [color.red, color.green, color.blue, color.alpha];
}
exports.fromColor = fromColor;
function toColor(color) {
    return new types.Color(color[0], color[1], color[2], color[3]);
}
exports.toColor = toColor;
function fromColorPresentation(colorPresentation) {
    return {
        label: colorPresentation.label,
        textEdit: colorPresentation.textEdit ? fromTextEdit(colorPresentation.textEdit) : undefined,
        additionalTextEdits: colorPresentation.additionalTextEdits ? colorPresentation.additionalTextEdits.map(value => fromTextEdit(value)) : undefined
    };
}
exports.fromColorPresentation = fromColorPresentation;
function convertIconPath(iconPath) {
    var _a;
    if (!iconPath) {
        return undefined;
    }
    if (iconPath instanceof types.URI) {
        return iconPath.toJSON();
    }
    else if ('dark' in iconPath) {
        return {
            dark: iconPath.dark.toJSON(),
            light: (_a = iconPath.light) === null || _a === void 0 ? void 0 : _a.toJSON()
        };
    }
    else if (themables_1.ThemeIcon.isThemeIcon(iconPath)) {
        return {
            id: iconPath.id,
            color: iconPath.color ? { id: iconPath.color.id } : undefined
        };
    }
    else {
        return undefined;
    }
}
exports.convertIconPath = convertIconPath;
function convertQuickInputButton(button, index) {
    const iconPath = convertIconPath(button.iconPath);
    if (!iconPath) {
        throw new Error(`Could not convert icon path: '${button.iconPath}'`);
    }
    return {
        handle: index,
        iconPath: iconPath,
        tooltip: button.tooltip
    };
}
exports.convertQuickInputButton = convertQuickInputButton;
function convertToTransferQuickPickItems(items) {
    return items.map((item, index) => {
        if (typeof item === 'string') {
            return { kind: 'item', label: item, handle: index };
        }
        else if (item.kind === types_impl_1.QuickPickItemKind.Separator) {
            return { kind: 'separator', label: item.label, handle: index };
        }
        else {
            const { label, description, iconPath, detail, picked, alwaysShow, buttons } = item;
            return {
                kind: 'item',
                label,
                description,
                iconPath: convertIconPath(iconPath),
                detail,
                picked,
                alwaysShow,
                buttons: buttons ? buttons.map(convertQuickInputButton) : undefined,
                handle: index,
            };
        }
    });
}
exports.convertToTransferQuickPickItems = convertToTransferQuickPickItems;
var DecorationRenderOptions;
(function (DecorationRenderOptions) {
    function from(options) {
        return {
            isWholeLine: options.isWholeLine,
            rangeBehavior: options.rangeBehavior ? DecorationRangeBehavior.from(options.rangeBehavior) : undefined,
            overviewRulerLane: options.overviewRulerLane,
            light: options.light ? ThemableDecorationRenderOptions.from(options.light) : undefined,
            dark: options.dark ? ThemableDecorationRenderOptions.from(options.dark) : undefined,
            backgroundColor: options.backgroundColor,
            outline: options.outline,
            outlineColor: options.outlineColor,
            outlineStyle: options.outlineStyle,
            outlineWidth: options.outlineWidth,
            border: options.border,
            borderColor: options.borderColor,
            borderRadius: options.borderRadius,
            borderSpacing: options.borderSpacing,
            borderStyle: options.borderStyle,
            borderWidth: options.borderWidth,
            fontStyle: options.fontStyle,
            fontWeight: options.fontWeight,
            textDecoration: options.textDecoration,
            cursor: options.cursor,
            color: options.color,
            opacity: options.opacity,
            letterSpacing: options.letterSpacing,
            gutterIconPath: options.gutterIconPath ? pathOrURIToURI(options.gutterIconPath) : undefined,
            gutterIconSize: options.gutterIconSize,
            overviewRulerColor: options.overviewRulerColor,
            before: options.before ? ThemableDecorationAttachmentRenderOptions.from(options.before) : undefined,
            after: options.after ? ThemableDecorationAttachmentRenderOptions.from(options.after) : undefined,
        };
    }
    DecorationRenderOptions.from = from;
})(DecorationRenderOptions || (exports.DecorationRenderOptions = DecorationRenderOptions = {}));
var DecorationRangeBehavior;
(function (DecorationRangeBehavior) {
    function from(value) {
        if (typeof value === 'undefined') {
            return value;
        }
        switch (value) {
            case types.DecorationRangeBehavior.OpenOpen:
                return rpc.TrackedRangeStickiness.AlwaysGrowsWhenTypingAtEdges;
            case types.DecorationRangeBehavior.ClosedClosed:
                return rpc.TrackedRangeStickiness.NeverGrowsWhenTypingAtEdges;
            case types.DecorationRangeBehavior.OpenClosed:
                return rpc.TrackedRangeStickiness.GrowsOnlyWhenTypingBefore;
            case types.DecorationRangeBehavior.ClosedOpen:
                return rpc.TrackedRangeStickiness.GrowsOnlyWhenTypingAfter;
        }
    }
    DecorationRangeBehavior.from = from;
})(DecorationRangeBehavior || (exports.DecorationRangeBehavior = DecorationRangeBehavior = {}));
var ThemableDecorationRenderOptions;
(function (ThemableDecorationRenderOptions) {
    function from(options) {
        if (typeof options === 'undefined') {
            return options;
        }
        return {
            backgroundColor: options.backgroundColor,
            outline: options.outline,
            outlineColor: options.outlineColor,
            outlineStyle: options.outlineStyle,
            outlineWidth: options.outlineWidth,
            border: options.border,
            borderColor: options.borderColor,
            borderRadius: options.borderRadius,
            borderSpacing: options.borderSpacing,
            borderStyle: options.borderStyle,
            borderWidth: options.borderWidth,
            fontStyle: options.fontStyle,
            fontWeight: options.fontWeight,
            textDecoration: options.textDecoration,
            cursor: options.cursor,
            color: options.color,
            opacity: options.opacity,
            letterSpacing: options.letterSpacing,
            gutterIconPath: options.gutterIconPath ? pathOrURIToURI(options.gutterIconPath) : undefined,
            gutterIconSize: options.gutterIconSize,
            overviewRulerColor: options.overviewRulerColor,
            before: options.before ? ThemableDecorationAttachmentRenderOptions.from(options.before) : undefined,
            after: options.after ? ThemableDecorationAttachmentRenderOptions.from(options.after) : undefined,
        };
    }
    ThemableDecorationRenderOptions.from = from;
})(ThemableDecorationRenderOptions || (exports.ThemableDecorationRenderOptions = ThemableDecorationRenderOptions = {}));
var ThemableDecorationAttachmentRenderOptions;
(function (ThemableDecorationAttachmentRenderOptions) {
    function from(options) {
        if (typeof options === 'undefined') {
            return options;
        }
        return {
            contentText: options.contentText,
            contentIconPath: options.contentIconPath ? pathOrURIToURI(options.contentIconPath) : undefined,
            border: options.border,
            borderColor: options.borderColor,
            fontStyle: options.fontStyle,
            fontWeight: options.fontWeight,
            textDecoration: options.textDecoration,
            color: options.color,
            backgroundColor: options.backgroundColor,
            margin: options.margin,
            width: options.width,
            height: options.height,
        };
    }
    ThemableDecorationAttachmentRenderOptions.from = from;
})(ThemableDecorationAttachmentRenderOptions || (exports.ThemableDecorationAttachmentRenderOptions = ThemableDecorationAttachmentRenderOptions = {}));
var ViewColumn;
(function (ViewColumn) {
    function from(column) {
        if (typeof column === 'number' && column >= types.ViewColumn.One) {
            return column - 1; // adjust zero index (ViewColumn.ONE => 0)
        }
        if (column === types.ViewColumn.Beside) {
            return SIDE_GROUP;
        }
        return ACTIVE_GROUP; // default is always the active group
    }
    ViewColumn.from = from;
    function to(position) {
        if (typeof position === 'number' && position >= 0) {
            return position + 1; // adjust to index (ViewColumn.ONE => 1)
        }
        throw new Error('invalid \'EditorGroupColumn\'');
    }
    ViewColumn.to = to;
})(ViewColumn || (exports.ViewColumn = ViewColumn = {}));
function pathOrURIToURI(value) {
    if (typeof value === 'undefined') {
        return value;
    }
    if (typeof value === 'string') {
        return types_impl_1.URI.file(value);
    }
    else {
        return value;
    }
}
exports.pathOrURIToURI = pathOrURIToURI;
function pluginToPluginInfo(plugin) {
    return {
        id: plugin.model.id,
        name: plugin.model.name,
        displayName: plugin.model.displayName
    };
}
exports.pluginToPluginInfo = pluginToPluginInfo;
var InlayHintKind;
(function (InlayHintKind) {
    function from(kind) {
        return kind;
    }
    InlayHintKind.from = from;
    function to(kind) {
        return kind;
    }
    InlayHintKind.to = to;
})(InlayHintKind || (exports.InlayHintKind = InlayHintKind = {}));
var DataTransferItem;
(function (DataTransferItem) {
    function to(mime, item, resolveFileData) {
        const file = item.fileData;
        if (file) {
            return new class extends types.DataTransferItem {
                asFile() {
                    return {
                        name: file.name,
                        uri: types_impl_1.URI.revive(file.uri),
                        data: () => resolveFileData(file.id),
                    };
                }
            }('');
        }
        if (mime === 'text/uri-list' && item.uriListData) {
            return new types.DataTransferItem(reviveUriList(item.uriListData));
        }
        return new types.DataTransferItem(item.asString);
    }
    DataTransferItem.to = to;
    function reviveUriList(parts) {
        return parts.map(part => typeof part === 'string' ? part : types_impl_1.URI.revive(part).toString()).join('\r\n');
    }
})(DataTransferItem || (exports.DataTransferItem = DataTransferItem = {}));
var DataTransfer;
(function (DataTransfer) {
    function toDataTransfer(value, resolveFileData) {
        const dataTransfer = new types.DataTransfer();
        for (const [mimeType, item] of value.items) {
            dataTransfer.set(mimeType, DataTransferItem.to(mimeType, item, resolveFileData));
        }
        return dataTransfer;
    }
    DataTransfer.toDataTransfer = toDataTransfer;
})(DataTransfer || (exports.DataTransfer = DataTransfer = {}));
var NotebookDocumentContentOptions;
(function (NotebookDocumentContentOptions) {
    function from(options) {
        var _a, _b, _c;
        return {
            transientOutputs: (_a = options === null || options === void 0 ? void 0 : options.transientOutputs) !== null && _a !== void 0 ? _a : false,
            transientCellMetadata: (_b = options === null || options === void 0 ? void 0 : options.transientCellMetadata) !== null && _b !== void 0 ? _b : {},
            transientDocumentMetadata: (_c = options === null || options === void 0 ? void 0 : options.transientDocumentMetadata) !== null && _c !== void 0 ? _c : {},
        };
    }
    NotebookDocumentContentOptions.from = from;
})(NotebookDocumentContentOptions || (exports.NotebookDocumentContentOptions = NotebookDocumentContentOptions = {}));
var NotebookStatusBarItem;
(function (NotebookStatusBarItem) {
    function from(item, commandsConverter, disposables) {
        const command = typeof item.command === 'string' ? { title: '', command: item.command } : item.command;
        return {
            alignment: item.alignment === types.NotebookCellStatusBarAlignment.Left ? 1 /* notebooks.CellStatusbarAlignment.Left */ : 2 /* notebooks.CellStatusbarAlignment.Right */,
            command: commandsConverter.toSafeCommand(command, disposables),
            text: item.text,
            tooltip: item.tooltip,
            priority: item.priority
        };
    }
    NotebookStatusBarItem.from = from;
})(NotebookStatusBarItem || (exports.NotebookStatusBarItem = NotebookStatusBarItem = {}));
var NotebookData;
(function (NotebookData) {
    function from(data) {
        var _a;
        const res = {
            metadata: (_a = data.metadata) !== null && _a !== void 0 ? _a : Object.create(null),
            cells: [],
        };
        for (const cell of data.cells) {
            // types.NotebookCellData.validate(cell);
            res.cells.push(NotebookCellData.from(cell));
        }
        return res;
    }
    NotebookData.from = from;
    function to(data) {
        const res = new types.NotebookData(data.cells.map(NotebookCellData.to));
        if (!(0, common_1.isEmptyObject)(data.metadata)) {
            res.metadata = data.metadata;
        }
        return res;
    }
    NotebookData.to = to;
})(NotebookData || (exports.NotebookData = NotebookData = {}));
var NotebookCellData;
(function (NotebookCellData) {
    function from(data) {
        var _a;
        return {
            cellKind: NotebookCellKind.from(data.kind),
            language: data.languageId,
            source: data.value,
            metadata: data.metadata,
            internalMetadata: NotebookCellExecutionSummary.from((_a = data.executionSummary) !== null && _a !== void 0 ? _a : {}),
            outputs: data.outputs ? data.outputs.map(NotebookCellOutputConverter.from) : []
        };
    }
    NotebookCellData.from = from;
    function to(data) {
        return new types.NotebookCellData(NotebookCellKind.to(data.cellKind), data.source, data.language, data.outputs ? data.outputs.map(NotebookCellOutput.to) : undefined, data.metadata, data.internalMetadata ? NotebookCellExecutionSummary.to(data.internalMetadata) : undefined);
    }
    NotebookCellData.to = to;
})(NotebookCellData || (exports.NotebookCellData = NotebookCellData = {}));
var NotebookCellKind;
(function (NotebookCellKind) {
    function from(data) {
        switch (data) {
            case types.NotebookCellKind.Markup:
                return notebooks.CellKind.Markup;
            case types.NotebookCellKind.Code:
            default:
                return notebooks.CellKind.Code;
        }
    }
    NotebookCellKind.from = from;
    function to(data) {
        switch (data) {
            case notebooks.CellKind.Markup:
                return types.NotebookCellKind.Markup;
            case notebooks.CellKind.Code:
            default:
                return types.NotebookCellKind.Code;
        }
    }
    NotebookCellKind.to = to;
})(NotebookCellKind || (exports.NotebookCellKind = NotebookCellKind = {}));
var NotebookCellOutput;
(function (NotebookCellOutput) {
    function from(output) {
        return {
            outputId: output.outputId,
            items: output.items.map(NotebookCellOutputItem.from),
            metadata: output.metadata
        };
    }
    NotebookCellOutput.from = from;
    function to(output) {
        const items = output.items.map(NotebookCellOutputItem.to);
        return new types.NotebookCellOutput(items, output.outputId, output.metadata);
    }
    NotebookCellOutput.to = to;
})(NotebookCellOutput || (exports.NotebookCellOutput = NotebookCellOutput = {}));
var NotebookCellOutputItem;
(function (NotebookCellOutputItem) {
    function from(item) {
        return {
            mime: item.mime,
            valueBytes: buffer_1.BinaryBuffer.wrap(item.data),
        };
    }
    NotebookCellOutputItem.from = from;
    function to(item) {
        return new types.NotebookCellOutputItem(item.valueBytes.buffer, item.mime);
    }
    NotebookCellOutputItem.to = to;
})(NotebookCellOutputItem || (exports.NotebookCellOutputItem = NotebookCellOutputItem = {}));
var NotebookCellOutputConverter;
(function (NotebookCellOutputConverter) {
    function from(output) {
        return {
            outputId: output.outputId,
            items: output.items.map(NotebookCellOutputItem.from),
            metadata: output.metadata
        };
    }
    NotebookCellOutputConverter.from = from;
    function to(output) {
        const items = output.items.map(NotebookCellOutputItem.to);
        return new types.NotebookCellOutput(items, output.outputId, output.metadata);
    }
    NotebookCellOutputConverter.to = to;
    function ensureUniqueMimeTypes(items, warn = false) {
        const seen = new Set();
        const removeIdx = new Set();
        for (let i = 0; i < items.length; i++) {
            const item = items[i];
            // We can have multiple text stream mime types in the same output.
            if (!seen.has(item.mime) || (0, common_2.isTextStreamMime)(item.mime)) {
                seen.add(item.mime);
                continue;
            }
            // duplicated mime types... first has won
            removeIdx.add(i);
            if (warn) {
                console.warn(`DUPLICATED mime type '${item.mime}' will be dropped`);
            }
        }
        if (removeIdx.size === 0) {
            return items;
        }
        return items.filter((_, index) => !removeIdx.has(index));
    }
    NotebookCellOutputConverter.ensureUniqueMimeTypes = ensureUniqueMimeTypes;
})(NotebookCellOutputConverter || (exports.NotebookCellOutputConverter = NotebookCellOutputConverter = {}));
var NotebookCellExecutionSummary;
(function (NotebookCellExecutionSummary) {
    function to(data) {
        return {
            timing: typeof data.runStartTime === 'number' && typeof data.runEndTime === 'number' ? { startTime: data.runStartTime, endTime: data.runEndTime } : undefined,
            executionOrder: data.executionOrder,
            success: data.lastRunSuccess
        };
    }
    NotebookCellExecutionSummary.to = to;
    function from(data) {
        var _a, _b;
        return {
            lastRunSuccess: data.success,
            runStartTime: (_a = data.timing) === null || _a === void 0 ? void 0 : _a.startTime,
            runEndTime: (_b = data.timing) === null || _b === void 0 ? void 0 : _b.endTime,
            executionOrder: data.executionOrder
        };
    }
    NotebookCellExecutionSummary.from = from;
})(NotebookCellExecutionSummary || (exports.NotebookCellExecutionSummary = NotebookCellExecutionSummary = {}));
var NotebookRange;
(function (NotebookRange) {
    function from(range) {
        return { start: range.start, end: range.end };
    }
    NotebookRange.from = from;
    function to(range) {
        return new types.NotebookRange(range.start, range.end);
    }
    NotebookRange.to = to;
})(NotebookRange || (exports.NotebookRange = NotebookRange = {}));
var NotebookKernelSourceAction;
(function (NotebookKernelSourceAction) {
    function from(item, commandsConverter, disposables) {
        const command = typeof item.command === 'string' ? { title: '', command: item.command } : item.command;
        return {
            command: commandsConverter.toSafeCommand(command, disposables),
            label: item.label,
            description: item.description,
            detail: item.detail,
            documentation: item.documentation
        };
    }
    NotebookKernelSourceAction.from = from;
})(NotebookKernelSourceAction || (exports.NotebookKernelSourceAction = NotebookKernelSourceAction = {}));
var TestMessage;
(function (TestMessage) {
    function from(message) {
        if ((0, arrays_1.isReadonlyArray)(message)) {
            return message.map(msg => TestMessage.from(msg)[0]);
        }
        return [{
                location: fromLocation(message.location),
                message: fromMarkdown(message.message),
                expected: message.expectedOutput,
                actual: message.actualOutput,
                contextValue: message.contextValue
            }];
    }
    TestMessage.from = from;
})(TestMessage || (exports.TestMessage = TestMessage = {}));
var TestItem;
(function (TestItem) {
    function from(test) {
        return TestItem.fromPartial(test);
    }
    TestItem.from = from;
    function fromPartial(test) {
        const result = {};
        if ('id' in test) {
            result.id = test.id;
        }
        if ('uri' in test) {
            result.uri = test.uri;
        }
        if ('label' in test) {
            result.label = test.label;
        }
        if ('range' in test) {
            result.range = fromRange(test.range);
        }
        if ('sortKey' in test) {
            result.sortKey = test.sortText;
        }
        if ('tags' in test) {
            result.tags = test.tags ? test.tags.map(tag => tag.id) : [];
        }
        if ('busy' in test) {
            result.busy = test.busy;
        }
        if ('sortKey' in test) {
            result.sortKey = test.sortText;
        }
        if ('canResolveChildren' in test) {
            result.canResolveChildren = test.canResolveChildren;
        }
        if ('description' in test) {
            result.description = test.description;
        }
        if ('description' in test) {
            result.error = test.error;
        }
        if (test.children) {
            const children = [];
            test.children.forEach(item => {
                children.push(TestItem.from(item));
            });
            result.children = children;
        }
        return result;
    }
    TestItem.fromPartial = fromPartial;
})(TestItem || (exports.TestItem = TestItem = {}));


/***/ }),

/***/ "../node_modules/@theia/plugin-ext/lib/plugin/types-impl.js":
/*!******************************************************************!*\
  !*** ../node_modules/@theia/plugin-ext/lib/plugin/types-impl.js ***!
  \******************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

// *****************************************************************************
// Copyright (C) 2018 Red Hat, Inc. and others.
//
// This program and the accompanying materials are made available under the
// terms of the Eclipse Public License v. 2.0 which is available at
// http://www.eclipse.org/legal/epl-2.0.
//
// This Source Code may also be made available under the following Secondary
// Licenses when the conditions for such availability set forth in the Eclipse
// Public License v. 2.0 are satisfied: GNU General Public License, version 2
// with the GNU Classpath Exception which is available at
// https://www.gnu.org/software/classpath/license.html.
//
// SPDX-License-Identifier: EPL-2.0 OR GPL-2.0-only WITH Classpath-exception-2.0
// *****************************************************************************
// copied from https://github.com/microsoft/vscode/blob/1.37.0/src/vs/workbench/api/common/extHostTypes.ts
/*---------------------------------------------------------------------------------------------
*  Copyright (c) Microsoft Corporation. All rights reserved.
*  Licensed under the MIT License. See License.txt in the project root for license information.
*--------------------------------------------------------------------------------------------*/
var _a, _NotebookCellOutputItem_encoder;
var URI_1, Disposable_1, Position_1, Range_1, SnippetString_1, ThemeIcon_1, TextEdit_1, Location_1, NotebookEdit_1, DocumentDropOrPasteEditKind_1, CodeActionKind_1, SymbolInformation_1, DocumentSymbol_1, FileSystemError_1, TaskGroup_1, CallHierarchyItem_1, TypeHierarchyItem_1, TestMessage_1, FileCoverage_1, SemanticTokensBuilder_1;
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.NotebookEditorRevealType = exports.NotebookControllerAffinity = exports.NotebookCellStatusBarAlignment = exports.NotebookCellKind = exports.MarkerTag = exports.MarkerSeverity = exports.Diagnostic = exports.CompletionItemTag = exports.DiagnosticTag = exports.DiagnosticRelatedInformation = exports.Location = exports.DebugConsoleMode = exports.DiagnosticSeverity = exports.InlineCompletionList = exports.InlineCompletionItem = exports.InlineCompletionTriggerKind = exports.CompletionList = exports.CompletionItem = exports.CompletionItemKind = exports.CompletionTriggerKind = exports.TextEdit = exports.SyntaxTokenType = exports.IndentAction = exports.RelativePattern = exports.ConfigurationTarget = exports.OverviewRulerLane = exports.DecorationRangeBehavior = exports.TextEditorRevealType = exports.ThemeIcon = exports.ThemeColor = exports.SnippetString = exports.EnvironmentVariableMutatorType = exports.EndOfLine = exports.TextDocumentShowOptions = exports.Selection = exports.Range = exports.Position = exports.TextDocumentChangeReason = exports.TextEditorSelectionChangeKind = exports.ColorTheme = exports.ExternalUriOpenerPriority = exports.SourceControlInputBoxValidationType = exports.ExtensionKind = exports.ExtensionMode = exports.ColorThemeKind = exports.ViewColumn = exports.TextEditorLineNumbersStyle = exports.StatusBarAlignment = exports.Disposable = exports.URI = void 0;
exports.TerminalExitReason = exports.TerminalProfile = exports.TerminalOutputAnchor = exports.TerminalLocation = exports.TerminalLink = exports.QuickInputButtons = exports.CommentThreadCollapsibleState = exports.CommentThreadState = exports.DocumentSymbol = exports.SymbolInformation = exports.SymbolTag = exports.TreeItemCheckboxState = exports.TreeItemCollapsibleState = exports.TreeItem = exports.DataTransfer = exports.DataTransferItem = exports.WorkspaceEdit = exports.CodeAction = exports.TextDocumentSaveReason = exports.CodeActionKind = exports.CodeActionTriggerKind = exports.CodeActionTrigger = exports.CodeLens = exports.DocumentDropEdit = exports.DocumentDropOrPasteEditKind = exports.DocumentLink = exports.MultiDocumentHighlight = exports.DocumentHighlight = exports.DocumentHighlightKind = exports.InlineValueEvaluatableExpression = exports.InlineValueVariableLookup = exports.InlineValueText = exports.InlineValueContext = exports.EvaluatableExpression = exports.Hover = exports.SignatureHelp = exports.SignatureHelpTriggerKind = exports.SignatureInformation = exports.ParameterInformation = exports.NotebookRendererScript = exports.NotebookEdit = exports.SnippetTextEdit = exports.NotebookRange = exports.NotebookData = exports.NotebookCellStatusBarItem = exports.NotebookCellOutputItem = exports.NotebookCellOutput = exports.NotebookCellData = exports.NotebookKernelSourceAction = exports.NotebookCellExecutionState = void 0;
exports.TestRunProfileKind = exports.TestResultState = exports.LinkedEditingRanges = exports.LanguageStatusSeverity = exports.TypeHierarchyItem = exports.CallHierarchyOutgoingCall = exports.CallHierarchyIncomingCall = exports.CallHierarchyItem = exports.UIKind = exports.WebviewPanelTargetArea = exports.OperatingSystem = exports.SelectionRange = exports.FoldingRangeKind = exports.FoldingRange = exports.InlayHintKind = exports.InlayHint = exports.InlayHintLabelPart = exports.ColorFormat = exports.ColorPresentation = exports.ColorInformation = exports.Color = exports.DebugStackFrame = exports.DebugThread = exports.FunctionBreakpoint = exports.SourceBreakpoint = exports.Breakpoint = exports.LogLevel = exports.DebugAdapterInlineImplementation = exports.DebugAdapterNamedPipeServer = exports.DebugAdapterServer = exports.DebugAdapterExecutable = exports.Task2 = exports.Task = exports.TaskScope = exports.TaskGroup = exports.CustomExecution = exports.ShellExecution = exports.TaskRevealKind = exports.TaskPanelKind = exports.ShellQuoting = exports.QuickPickItemKind = exports.ProcessExecution = exports.ProgressLocation = exports.Progress = exports.ProgressOptions = exports.FileType = exports.FileSystemError = exports.FileChangeType = exports.CommentMode = exports.FileDecoration = void 0;
exports.LanguageModelError = exports.LanguageModelChatMessage = exports.LanguageModelChatMessageRole = exports.ChatResultFeedbackKind = exports.ChatResponseFileTreePart = exports.ChatResponseMarkdownPart = exports.ChatResponseCommandButtonPart = exports.ChatResponseReferencePart = exports.ChatResponseProgressPart = exports.ChatResponseAnchorPart = exports.ChatResponseTurn = exports.ChatRequestTurn = exports.TerminalQuickFixOpener = exports.TerminalQuickFixTerminalCommand = exports.EditSessionIdentityMatch = exports.DocumentPasteTriggerKind = exports.DocumentPasteEdit = exports.DocumentPasteEditKind = exports.InteractiveWindowInput = exports.TerminalEditorTabInput = exports.NotebookDiffEditorTabInput = exports.NotebookEditorTabInput = exports.TelemetryLogger = exports.TelemetryTrustedValue = exports.WebviewEditorTabInput = exports.CustomEditorTabInput = exports.TextMergeTabInput = exports.TextDiffTabInput = exports.TextTabInput = exports.InputBoxValidationSeverity = exports.SemanticTokensEdits = exports.SemanticTokensEdit = exports.SemanticTokens = exports.SemanticTokensBuilder = exports.SemanticTokensLegend = exports.TimelineItem = exports.DeclarationCoverage = exports.BranchCoverage = exports.StatementCoverage = exports.FileCoverage = exports.TestCoverageCount = exports.TestMessage = exports.TestRunRequest = exports.TestTag = void 0;
const tslib_1 = __webpack_require__(/*! tslib */ "../node_modules/tslib/tslib.es6.mjs");
/* eslint-disable no-null/no-null */
const coreutils_1 = __webpack_require__(/*! @theia/core/shared/@phosphor/coreutils */ "../node_modules/@theia/core/shared/@phosphor/coreutils/index.js");
const errors_1 = __webpack_require__(/*! ../common/errors */ "../node_modules/@theia/plugin-ext/lib/common/errors.js");
const vscode_uri_1 = __webpack_require__(/*! @theia/core/shared/vscode-uri */ "../node_modules/@theia/core/shared/vscode-uri/index.js");
const paths_util_1 = __webpack_require__(/*! ../common/paths-util */ "../node_modules/@theia/plugin-ext/lib/common/paths-util.js");
const strings_1 = __webpack_require__(/*! @theia/core/lib/common/strings */ "../node_modules/@theia/core/lib/common/strings.js");
const plugin_api_rpc_model_1 = __webpack_require__(/*! ../common/plugin-api-rpc-model */ "../node_modules/@theia/plugin-ext/lib/common/plugin-api-rpc-model.js");
const files_1 = __webpack_require__(/*! @theia/filesystem/lib/common/files */ "../node_modules/@theia/filesystem/lib/common/files.js");
const paths = __webpack_require__(/*! path */ "../node_modules/path-browserify/index.js");
const types_1 = __webpack_require__(/*! ../common/types */ "../node_modules/@theia/plugin-ext/lib/common/types.js");
const common_1 = __webpack_require__(/*! @theia/core/lib/common */ "../node_modules/@theia/core/lib/common/index.js");
/**
 * This is an implementation of #theia.Uri based on vscode-uri.
 * This is supposed to fix https://github.com/eclipse-theia/theia/issues/8752
 * We cannot simply upgrade the dependency, because the current version 3.x
 * is not compatible with our current codebase
 */
let URI = URI_1 = class URI extends vscode_uri_1.URI {
    constructor(schemeOrData, authority, path, query, fragment, _strict = false) {
        if (typeof schemeOrData === 'string') {
            super(schemeOrData, authority, path, query, fragment, _strict);
        }
        else {
            super(schemeOrData);
        }
    }
    /**
     * Override to create the correct class.
     */
    with(change) {
        return new URI_1(super.with(change));
    }
    static joinPath(uri, ...pathSegments) {
        if (!uri.path) {
            throw new Error('\'joinPath\' called on URI without path');
        }
        const newPath = paths.posix.join(uri.path, ...pathSegments);
        return new URI_1(uri.scheme, uri.authority, newPath, uri.query, uri.fragment);
    }
    static revive(data) {
        const uri = vscode_uri_1.URI.revive(data);
        return uri ? new URI_1(uri) : undefined;
    }
    static parse(value, _strict) {
        return new URI_1(vscode_uri_1.URI.parse(value, _strict));
    }
    static file(path) {
        return new URI_1(vscode_uri_1.URI.file(path));
    }
    /**
     * There is quite some magic in to vscode URI class related to
     * transferring via JSON.stringify(). Making the CodeURI instance
     * makes sure we transfer this object as a vscode-uri URI.
     */
    toJSON() {
        return vscode_uri_1.URI.from(this).toJSON();
    }
};
exports.URI = URI;
exports.URI = URI = URI_1 = tslib_1.__decorate([
    types_1.es5ClassCompat,
    tslib_1.__metadata("design:paramtypes", [Object, String, String, String, String, Boolean])
], URI);
let Disposable = Disposable_1 = class Disposable {
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    static from(...disposables) {
        return new Disposable_1(() => {
            if (disposables) {
                for (const disposable of disposables) {
                    if (disposable && typeof disposable.dispose === 'function') {
                        disposable.dispose();
                    }
                }
            }
        });
    }
    constructor(func) {
        this.disposable = func;
    }
    /**
     * Dispose this object.
     */
    dispose() {
        if (this.disposable) {
            this.disposable();
            this.disposable = undefined;
        }
    }
    static create(func) {
        return new Disposable_1(func);
    }
};
exports.Disposable = Disposable;
exports.Disposable = Disposable = Disposable_1 = tslib_1.__decorate([
    types_1.es5ClassCompat,
    tslib_1.__metadata("design:paramtypes", [Function])
], Disposable);
var StatusBarAlignment;
(function (StatusBarAlignment) {
    StatusBarAlignment[StatusBarAlignment["Left"] = 1] = "Left";
    StatusBarAlignment[StatusBarAlignment["Right"] = 2] = "Right";
})(StatusBarAlignment || (exports.StatusBarAlignment = StatusBarAlignment = {}));
var TextEditorLineNumbersStyle;
(function (TextEditorLineNumbersStyle) {
    TextEditorLineNumbersStyle[TextEditorLineNumbersStyle["Off"] = 0] = "Off";
    TextEditorLineNumbersStyle[TextEditorLineNumbersStyle["On"] = 1] = "On";
    TextEditorLineNumbersStyle[TextEditorLineNumbersStyle["Relative"] = 2] = "Relative";
    TextEditorLineNumbersStyle[TextEditorLineNumbersStyle["Interval"] = 3] = "Interval";
})(TextEditorLineNumbersStyle || (exports.TextEditorLineNumbersStyle = TextEditorLineNumbersStyle = {}));
/**
 * Denotes a column in the editor window.
 * Columns are used to show editors side by side.
 */
var ViewColumn;
(function (ViewColumn) {
    ViewColumn[ViewColumn["Active"] = -1] = "Active";
    ViewColumn[ViewColumn["Beside"] = -2] = "Beside";
    ViewColumn[ViewColumn["One"] = 1] = "One";
    ViewColumn[ViewColumn["Two"] = 2] = "Two";
    ViewColumn[ViewColumn["Three"] = 3] = "Three";
    ViewColumn[ViewColumn["Four"] = 4] = "Four";
    ViewColumn[ViewColumn["Five"] = 5] = "Five";
    ViewColumn[ViewColumn["Six"] = 6] = "Six";
    ViewColumn[ViewColumn["Seven"] = 7] = "Seven";
    ViewColumn[ViewColumn["Eight"] = 8] = "Eight";
    ViewColumn[ViewColumn["Nine"] = 9] = "Nine";
})(ViewColumn || (exports.ViewColumn = ViewColumn = {}));
/**
 * Represents a color theme kind.
 */
var ColorThemeKind;
(function (ColorThemeKind) {
    ColorThemeKind[ColorThemeKind["Light"] = 1] = "Light";
    ColorThemeKind[ColorThemeKind["Dark"] = 2] = "Dark";
    ColorThemeKind[ColorThemeKind["HighContrast"] = 3] = "HighContrast";
    ColorThemeKind[ColorThemeKind["HighContrastLight"] = 4] = "HighContrastLight";
})(ColorThemeKind || (exports.ColorThemeKind = ColorThemeKind = {}));
var ExtensionMode;
(function (ExtensionMode) {
    /**
     * The extension is installed normally (for example, from the marketplace
     * or VSIX) in the editor.
     */
    ExtensionMode[ExtensionMode["Production"] = 1] = "Production";
    /**
     * The extension is running from an `--extensionDevelopmentPath` provided
     * when launching the editor.
     */
    ExtensionMode[ExtensionMode["Development"] = 2] = "Development";
    /**
     * The extension is running from an `--extensionTestsPath` and
     * the extension host is running unit tests.
     */
    ExtensionMode[ExtensionMode["Test"] = 3] = "Test";
})(ExtensionMode || (exports.ExtensionMode = ExtensionMode = {}));
var ExtensionKind;
(function (ExtensionKind) {
    ExtensionKind[ExtensionKind["UI"] = 1] = "UI";
    ExtensionKind[ExtensionKind["Workspace"] = 2] = "Workspace";
})(ExtensionKind || (exports.ExtensionKind = ExtensionKind = {}));
/**
 * Represents the validation type of the Source Control input.
 */
var SourceControlInputBoxValidationType;
(function (SourceControlInputBoxValidationType) {
    /**
     * Something not allowed by the rules of a language or other means.
     */
    SourceControlInputBoxValidationType[SourceControlInputBoxValidationType["Error"] = 0] = "Error";
    /**
     * Something suspicious but allowed.
     */
    SourceControlInputBoxValidationType[SourceControlInputBoxValidationType["Warning"] = 1] = "Warning";
    /**
     * Something to inform about but not a problem.
     */
    SourceControlInputBoxValidationType[SourceControlInputBoxValidationType["Information"] = 2] = "Information";
})(SourceControlInputBoxValidationType || (exports.SourceControlInputBoxValidationType = SourceControlInputBoxValidationType = {}));
var ExternalUriOpenerPriority;
(function (ExternalUriOpenerPriority) {
    ExternalUriOpenerPriority[ExternalUriOpenerPriority["None"] = 0] = "None";
    ExternalUriOpenerPriority[ExternalUriOpenerPriority["Option"] = 1] = "Option";
    ExternalUriOpenerPriority[ExternalUriOpenerPriority["Default"] = 2] = "Default";
    ExternalUriOpenerPriority[ExternalUriOpenerPriority["Preferred"] = 3] = "Preferred";
})(ExternalUriOpenerPriority || (exports.ExternalUriOpenerPriority = ExternalUriOpenerPriority = {}));
let ColorTheme = class ColorTheme {
    constructor(kind) {
        this.kind = kind;
    }
};
exports.ColorTheme = ColorTheme;
exports.ColorTheme = ColorTheme = tslib_1.__decorate([
    types_1.es5ClassCompat,
    tslib_1.__metadata("design:paramtypes", [Number])
], ColorTheme);
/**
 * Represents sources that can cause `window.onDidChangeEditorSelection`
 */
var TextEditorSelectionChangeKind;
(function (TextEditorSelectionChangeKind) {
    TextEditorSelectionChangeKind[TextEditorSelectionChangeKind["Keyboard"] = 1] = "Keyboard";
    TextEditorSelectionChangeKind[TextEditorSelectionChangeKind["Mouse"] = 2] = "Mouse";
    TextEditorSelectionChangeKind[TextEditorSelectionChangeKind["Command"] = 3] = "Command";
})(TextEditorSelectionChangeKind || (exports.TextEditorSelectionChangeKind = TextEditorSelectionChangeKind = {}));
(function (TextEditorSelectionChangeKind) {
    function fromValue(s) {
        switch (s) {
            case 'keyboard': return TextEditorSelectionChangeKind.Keyboard;
            case 'mouse': return TextEditorSelectionChangeKind.Mouse;
            case 'api': return TextEditorSelectionChangeKind.Command;
        }
        return undefined;
    }
    TextEditorSelectionChangeKind.fromValue = fromValue;
})(TextEditorSelectionChangeKind || (exports.TextEditorSelectionChangeKind = TextEditorSelectionChangeKind = {}));
var TextDocumentChangeReason;
(function (TextDocumentChangeReason) {
    TextDocumentChangeReason[TextDocumentChangeReason["Undo"] = 1] = "Undo";
    TextDocumentChangeReason[TextDocumentChangeReason["Redo"] = 2] = "Redo";
})(TextDocumentChangeReason || (exports.TextDocumentChangeReason = TextDocumentChangeReason = {}));
let Position = Position_1 = class Position {
    constructor(line, char) {
        if (line < 0) {
            throw new Error('line number cannot be negative');
        }
        if (char < 0) {
            throw new Error('char number cannot be negative');
        }
        this._line = line;
        this._character = char;
    }
    get line() {
        return this._line;
    }
    get character() {
        return this._character;
    }
    isBefore(other) {
        if (this._line < other._line) {
            return true;
        }
        if (other._line < this._line) {
            return false;
        }
        return this._character < other._character;
    }
    isBeforeOrEqual(other) {
        if (this._line < other._line) {
            return true;
        }
        if (other._line < this._line) {
            return false;
        }
        return this._character <= other._character;
    }
    isAfter(other) {
        return !this.isBeforeOrEqual(other);
    }
    isAfterOrEqual(other) {
        return !this.isBefore(other);
    }
    isEqual(other) {
        return this._line === other._line && this._character === other._character;
    }
    compareTo(other) {
        if (this._line < other._line) {
            return -1;
        }
        else if (this._line > other.line) {
            return 1;
        }
        else {
            // equal line
            if (this._character < other._character) {
                return -1;
            }
            else if (this._character > other._character) {
                return 1;
            }
            else {
                // equal line and character
                return 0;
            }
        }
    }
    translate(lineDeltaOrChange, characterDelta = 0) {
        if (lineDeltaOrChange === null || characterDelta === null) {
            throw (0, errors_1.illegalArgument)();
        }
        let lineDelta;
        if (typeof lineDeltaOrChange === 'undefined') {
            lineDelta = 0;
        }
        else if (typeof lineDeltaOrChange === 'number') {
            lineDelta = lineDeltaOrChange;
        }
        else {
            lineDelta = typeof lineDeltaOrChange.lineDelta === 'number' ? lineDeltaOrChange.lineDelta : 0;
            characterDelta = typeof lineDeltaOrChange.characterDelta === 'number' ? lineDeltaOrChange.characterDelta : 0;
        }
        if (lineDelta === 0 && characterDelta === 0) {
            return this;
        }
        return new Position_1(this.line + lineDelta, this.character + characterDelta);
    }
    with(lineOrChange, character = this.character) {
        if (lineOrChange === null || character === null) {
            throw (0, errors_1.illegalArgument)();
        }
        let line;
        if (typeof lineOrChange === 'undefined') {
            line = this.line;
        }
        else if (typeof lineOrChange === 'number') {
            line = lineOrChange;
        }
        else {
            line = typeof lineOrChange.line === 'number' ? lineOrChange.line : this.line;
            character = typeof lineOrChange.character === 'number' ? lineOrChange.character : this.character;
        }
        if (line === this.line && character === this.character) {
            return this;
        }
        return new Position_1(line, character);
    }
    static Min(...positions) {
        let result = positions.pop();
        for (const p of positions) {
            if (p.isBefore(result)) {
                result = p;
            }
        }
        return result;
    }
    static Max(...positions) {
        let result = positions.pop();
        for (const p of positions) {
            if (p.isAfter(result)) {
                result = p;
            }
        }
        return result;
    }
    static isPosition(other) {
        if (!other) {
            return false;
        }
        if (typeof other !== 'object' || Array.isArray(other)) {
            return false;
        }
        if (other instanceof Position_1) {
            return true;
        }
        const { line, character } = other;
        if (typeof line === 'number' && typeof character === 'number') {
            return true;
        }
        return false;
    }
    toJSON() {
        return { line: this.line, character: this.character };
    }
};
exports.Position = Position;
exports.Position = Position = Position_1 = tslib_1.__decorate([
    types_1.es5ClassCompat,
    tslib_1.__metadata("design:paramtypes", [Number, Number])
], Position);
let Range = Range_1 = class Range {
    constructor(startLineOrStart, startColumnOrEnd, endLine, endColumn) {
        let start = undefined;
        let end = undefined;
        if (typeof startLineOrStart === 'number' && typeof startColumnOrEnd === 'number' && typeof endLine === 'number' && typeof endColumn === 'number') {
            start = new Position(startLineOrStart, startColumnOrEnd);
            end = new Position(endLine, endColumn);
        }
        else if (startLineOrStart instanceof Position && startColumnOrEnd instanceof Position) {
            start = startLineOrStart;
            end = startColumnOrEnd;
        }
        if (!start || !end) {
            throw new Error('Invalid arguments');
        }
        if (start.isBefore(end)) {
            this._start = start;
            this._end = end;
        }
        else {
            this._start = end;
            this._end = start;
        }
    }
    get start() {
        return this._start;
    }
    get end() {
        return this._end;
    }
    contains(positionOrRange) {
        if (positionOrRange instanceof Range_1) {
            return this.contains(positionOrRange._start)
                && this.contains(positionOrRange._end);
        }
        else if (positionOrRange instanceof Position) {
            if (positionOrRange.isBefore(this._start)) {
                return false;
            }
            if (this._end.isBefore(positionOrRange)) {
                return false;
            }
            return true;
        }
        return false;
    }
    isEqual(other) {
        return this._start.isEqual(other._start) && this._end.isEqual(other._end);
    }
    intersection(other) {
        const start = Position.Max(other.start, this._start);
        const end = Position.Min(other.end, this._end);
        if (start.isAfter(end)) {
            // this happens when there is no overlap:
            // |-----|
            //          |----|
            return undefined;
        }
        return new Range_1(start, end);
    }
    union(other) {
        if (this.contains(other)) {
            return this;
        }
        else if (other.contains(this)) {
            return other;
        }
        const start = Position.Min(other.start, this._start);
        const end = Position.Max(other.end, this.end);
        return new Range_1(start, end);
    }
    get isEmpty() {
        return this._start.isEqual(this._end);
    }
    get isSingleLine() {
        return this._start.line === this._end.line;
    }
    with(startOrChange, end = this.end) {
        if (startOrChange === null || end === null) {
            throw (0, errors_1.illegalArgument)();
        }
        let start;
        if (!startOrChange) {
            start = this.start;
        }
        else if (Position.isPosition(startOrChange)) {
            start = startOrChange;
        }
        else {
            start = startOrChange.start || this.start;
            end = startOrChange.end || this.end;
        }
        if (start.isEqual(this._start) && end.isEqual(this.end)) {
            return this;
        }
        return new Range_1(start, end);
    }
    static isRange(arg) {
        if (arg instanceof Range_1) {
            return true;
        }
        return (0, common_1.isObject)(arg)
            && Position.isPosition(arg.start)
            && Position.isPosition(arg.end);
    }
    toJSON() {
        return [this.start, this.end];
    }
};
exports.Range = Range;
exports.Range = Range = Range_1 = tslib_1.__decorate([
    types_1.es5ClassCompat,
    tslib_1.__metadata("design:paramtypes", [Object, Object, Number, Number])
], Range);
let Selection = class Selection extends Range {
    constructor(anchorLineOrAnchor, anchorColumnOrActive, activeLine, activeColumn) {
        let anchor = undefined;
        let active = undefined;
        if (typeof anchorLineOrAnchor === 'number' && typeof anchorColumnOrActive === 'number' && typeof activeLine === 'number' && typeof activeColumn === 'number') {
            anchor = new Position(anchorLineOrAnchor, anchorColumnOrActive);
            active = new Position(activeLine, activeColumn);
        }
        else if (anchorLineOrAnchor instanceof Position && anchorColumnOrActive instanceof Position) {
            anchor = anchorLineOrAnchor;
            active = anchorColumnOrActive;
        }
        if (!anchor || !active) {
            throw new Error('Invalid arguments');
        }
        super(anchor, active);
        this._anchor = anchor;
        this._active = active;
    }
    get active() {
        return this._active;
    }
    get anchor() {
        return this._anchor;
    }
    get isReversed() {
        return this._anchor === this._end;
    }
};
exports.Selection = Selection;
exports.Selection = Selection = tslib_1.__decorate([
    types_1.es5ClassCompat,
    tslib_1.__metadata("design:paramtypes", [Object, Object, Number, Number])
], Selection);
var TextDocumentShowOptions;
(function (TextDocumentShowOptions) {
    /**
     * @param candidate
     * @returns `true` if `candidate` is an instance of options that includes a selection.
     * This function should be used to determine whether TextDocumentOptions passed into commands by plugins
     * need to be translated to TextDocumentShowOptions in the style of the RPC model. Selection is the only field that requires translation.
     */
    function isTextDocumentShowOptions(candidate) {
        if (!candidate) {
            return false;
        }
        const options = candidate;
        return Range.isRange(options.selection);
    }
    TextDocumentShowOptions.isTextDocumentShowOptions = isTextDocumentShowOptions;
})(TextDocumentShowOptions || (exports.TextDocumentShowOptions = TextDocumentShowOptions = {}));
var EndOfLine;
(function (EndOfLine) {
    EndOfLine[EndOfLine["LF"] = 1] = "LF";
    EndOfLine[EndOfLine["CRLF"] = 2] = "CRLF";
})(EndOfLine || (exports.EndOfLine = EndOfLine = {}));
var EnvironmentVariableMutatorType;
(function (EnvironmentVariableMutatorType) {
    EnvironmentVariableMutatorType[EnvironmentVariableMutatorType["Replace"] = 1] = "Replace";
    EnvironmentVariableMutatorType[EnvironmentVariableMutatorType["Append"] = 2] = "Append";
    EnvironmentVariableMutatorType[EnvironmentVariableMutatorType["Prepend"] = 3] = "Prepend";
})(EnvironmentVariableMutatorType || (exports.EnvironmentVariableMutatorType = EnvironmentVariableMutatorType = {}));
let SnippetString = SnippetString_1 = class SnippetString {
    static isSnippetString(thing) {
        if (thing instanceof SnippetString_1) {
            return true;
        }
        if (!thing) {
            return false;
        }
        return typeof thing.value === 'string';
    }
    static _escape(value) {
        return value.replace(/\$|}|\\/g, '\\$&');
    }
    constructor(value) {
        this._tabstop = 1;
        this.value = value || '';
    }
    appendText(string) {
        this.value += SnippetString_1._escape(string);
        return this;
    }
    appendTabstop(number = this._tabstop++) {
        this.value += '$';
        this.value += number;
        return this;
    }
    appendPlaceholder(value, number = this._tabstop++) {
        if (typeof value === 'function') {
            const nested = new SnippetString_1();
            nested._tabstop = this._tabstop;
            value(nested);
            this._tabstop = nested._tabstop;
            value = nested.value;
        }
        else {
            value = SnippetString_1._escape(value);
        }
        this.value += '${';
        this.value += number;
        this.value += ':';
        this.value += value;
        this.value += '}';
        return this;
    }
    appendChoice(values, number = this._tabstop++) {
        const value = values.map(s => s.replace(/\$|}|\\|,/g, '\\$&')).join(',');
        this.value += `\$\{${number}|${value}|\}`;
        return this;
    }
    appendVariable(name, defaultValue) {
        if (typeof defaultValue === 'function') {
            const nested = new SnippetString_1();
            nested._tabstop = this._tabstop;
            defaultValue(nested);
            this._tabstop = nested._tabstop;
            defaultValue = nested.value;
        }
        else if (typeof defaultValue === 'string') {
            defaultValue = defaultValue.replace(/\$|}/g, '\\$&');
        }
        this.value += '${';
        this.value += name;
        if (defaultValue) {
            this.value += ':';
            this.value += defaultValue;
        }
        this.value += '}';
        return this;
    }
};
exports.SnippetString = SnippetString;
exports.SnippetString = SnippetString = SnippetString_1 = tslib_1.__decorate([
    types_1.es5ClassCompat,
    tslib_1.__metadata("design:paramtypes", [String])
], SnippetString);
let ThemeColor = class ThemeColor {
    constructor(id) {
        this.id = id;
    }
};
exports.ThemeColor = ThemeColor;
exports.ThemeColor = ThemeColor = tslib_1.__decorate([
    types_1.es5ClassCompat,
    tslib_1.__metadata("design:paramtypes", [String])
], ThemeColor);
let ThemeIcon = ThemeIcon_1 = class ThemeIcon {
    constructor(id, color) {
        this.id = id;
        this.color = color;
    }
};
exports.ThemeIcon = ThemeIcon;
ThemeIcon.File = new ThemeIcon_1('file');
ThemeIcon.Folder = new ThemeIcon_1('folder');
exports.ThemeIcon = ThemeIcon = ThemeIcon_1 = tslib_1.__decorate([
    types_1.es5ClassCompat,
    tslib_1.__metadata("design:paramtypes", [String, ThemeColor])
], ThemeIcon);
(function (ThemeIcon) {
    function is(item) {
        return (0, common_1.isObject)(item) && 'id' in item;
    }
    ThemeIcon.is = is;
})(ThemeIcon || (exports.ThemeIcon = ThemeIcon = {}));
var TextEditorRevealType;
(function (TextEditorRevealType) {
    TextEditorRevealType[TextEditorRevealType["Default"] = 0] = "Default";
    TextEditorRevealType[TextEditorRevealType["InCenter"] = 1] = "InCenter";
    TextEditorRevealType[TextEditorRevealType["InCenterIfOutsideViewport"] = 2] = "InCenterIfOutsideViewport";
    TextEditorRevealType[TextEditorRevealType["AtTop"] = 3] = "AtTop";
})(TextEditorRevealType || (exports.TextEditorRevealType = TextEditorRevealType = {}));
/**
 * These values match very carefully the values of `TrackedRangeStickiness`
 */
var DecorationRangeBehavior;
(function (DecorationRangeBehavior) {
    /**
     * TrackedRangeStickiness.AlwaysGrowsWhenTypingAtEdges
     */
    DecorationRangeBehavior[DecorationRangeBehavior["OpenOpen"] = 0] = "OpenOpen";
    /**
     * TrackedRangeStickiness.NeverGrowsWhenTypingAtEdges
     */
    DecorationRangeBehavior[DecorationRangeBehavior["ClosedClosed"] = 1] = "ClosedClosed";
    /**
     * TrackedRangeStickiness.GrowsOnlyWhenTypingBefore
     */
    DecorationRangeBehavior[DecorationRangeBehavior["OpenClosed"] = 2] = "OpenClosed";
    /**
     * TrackedRangeStickiness.GrowsOnlyWhenTypingAfter
     */
    DecorationRangeBehavior[DecorationRangeBehavior["ClosedOpen"] = 3] = "ClosedOpen";
})(DecorationRangeBehavior || (exports.DecorationRangeBehavior = DecorationRangeBehavior = {}));
/**
 * Vertical Lane in the overview ruler of the editor.
 */
var OverviewRulerLane;
(function (OverviewRulerLane) {
    OverviewRulerLane[OverviewRulerLane["Left"] = 1] = "Left";
    OverviewRulerLane[OverviewRulerLane["Center"] = 2] = "Center";
    OverviewRulerLane[OverviewRulerLane["Right"] = 4] = "Right";
    OverviewRulerLane[OverviewRulerLane["Full"] = 7] = "Full";
})(OverviewRulerLane || (exports.OverviewRulerLane = OverviewRulerLane = {}));
var ConfigurationTarget;
(function (ConfigurationTarget) {
    ConfigurationTarget[ConfigurationTarget["Global"] = 1] = "Global";
    ConfigurationTarget[ConfigurationTarget["Workspace"] = 2] = "Workspace";
    ConfigurationTarget[ConfigurationTarget["WorkspaceFolder"] = 3] = "WorkspaceFolder";
    ConfigurationTarget[ConfigurationTarget["Default"] = 4] = "Default";
    ConfigurationTarget[ConfigurationTarget["Memory"] = 5] = "Memory";
})(ConfigurationTarget || (exports.ConfigurationTarget = ConfigurationTarget = {}));
let RelativePattern = class RelativePattern {
    get base() {
        return this._base;
    }
    set base(base) {
        this._base = base;
        this._baseUri = URI.file(base);
    }
    get baseUri() {
        return this._baseUri;
    }
    set baseUri(baseUri) {
        this._baseUri = baseUri;
        this.base = baseUri.fsPath;
    }
    constructor(base, pattern) {
        this.pattern = pattern;
        if (typeof base !== 'string') {
            if (!base || !URI.isUri(base) && !URI.isUri(base.uri)) {
                throw (0, errors_1.illegalArgument)('base');
            }
        }
        if (typeof pattern !== 'string') {
            throw (0, errors_1.illegalArgument)('pattern');
        }
        if (typeof base === 'string') {
            this.baseUri = URI.file(base);
        }
        else if (URI.isUri(base)) {
            this.baseUri = base;
        }
        else {
            this.baseUri = base.uri;
        }
    }
    pathToRelative(from, to) {
        return (0, paths_util_1.relative)(from, to);
    }
};
exports.RelativePattern = RelativePattern;
exports.RelativePattern = RelativePattern = tslib_1.__decorate([
    types_1.es5ClassCompat,
    tslib_1.__metadata("design:paramtypes", [Object, String])
], RelativePattern);
var IndentAction;
(function (IndentAction) {
    IndentAction[IndentAction["None"] = 0] = "None";
    IndentAction[IndentAction["Indent"] = 1] = "Indent";
    IndentAction[IndentAction["IndentOutdent"] = 2] = "IndentOutdent";
    IndentAction[IndentAction["Outdent"] = 3] = "Outdent";
})(IndentAction || (exports.IndentAction = IndentAction = {}));
var SyntaxTokenType;
(function (SyntaxTokenType) {
    function toString(v) {
        switch (v) {
            case SyntaxTokenType.Other: return 'other';
            case SyntaxTokenType.Comment: return 'comment';
            case SyntaxTokenType.String: return 'string';
            case SyntaxTokenType.RegEx: return 'regex';
        }
        return 'other';
    }
    SyntaxTokenType.toString = toString;
})(SyntaxTokenType || (exports.SyntaxTokenType = SyntaxTokenType = {}));
(function (SyntaxTokenType) {
    /**
     * Everything except tokens that are part of comments, string literals and regular expressions.
     */
    SyntaxTokenType[SyntaxTokenType["Other"] = 0] = "Other";
    /**
     * A comment.
     */
    SyntaxTokenType[SyntaxTokenType["Comment"] = 1] = "Comment";
    /**
     * A string literal.
     */
    SyntaxTokenType[SyntaxTokenType["String"] = 2] = "String";
    /**
     * A regular expression.
     */
    SyntaxTokenType[SyntaxTokenType["RegEx"] = 3] = "RegEx";
})(SyntaxTokenType || (exports.SyntaxTokenType = SyntaxTokenType = {}));
let TextEdit = TextEdit_1 = class TextEdit {
    get range() {
        return this._range;
    }
    set range(value) {
        if (value && !Range.isRange(value)) {
            throw (0, errors_1.illegalArgument)('range');
        }
        this._range = value;
    }
    get newText() {
        return this._newText || '';
    }
    set newText(value) {
        if (value && typeof value !== 'string') {
            throw (0, errors_1.illegalArgument)('newText');
        }
        this._newText = value;
    }
    get newEol() {
        return this._newEol;
    }
    set newEol(value) {
        if (value && typeof value !== 'number') {
            throw (0, errors_1.illegalArgument)('newEol');
        }
        this._newEol = value;
    }
    constructor(range, newText) {
        this.range = range;
        this.newText = newText;
    }
    static isTextEdit(thing) {
        if (thing instanceof TextEdit_1) {
            return true;
        }
        if (!thing) {
            return false;
        }
        return Range.isRange(thing.range)
            && typeof thing.newText === 'string';
    }
    static replace(range, newText) {
        return new TextEdit_1(range, newText);
    }
    static insert(position, newText) {
        return TextEdit_1.replace(new Range(position, position), newText);
    }
    static delete(range) {
        return TextEdit_1.replace(range, '');
    }
    static setEndOfLine(eol) {
        const ret = new TextEdit_1(undefined, undefined);
        ret.newEol = eol;
        return ret;
    }
};
exports.TextEdit = TextEdit;
exports.TextEdit = TextEdit = TextEdit_1 = tslib_1.__decorate([
    types_1.es5ClassCompat,
    tslib_1.__metadata("design:paramtypes", [Object, Object])
], TextEdit);
var CompletionTriggerKind;
(function (CompletionTriggerKind) {
    CompletionTriggerKind[CompletionTriggerKind["Invoke"] = 0] = "Invoke";
    CompletionTriggerKind[CompletionTriggerKind["TriggerCharacter"] = 1] = "TriggerCharacter";
    CompletionTriggerKind[CompletionTriggerKind["TriggerForIncompleteCompletions"] = 2] = "TriggerForIncompleteCompletions";
})(CompletionTriggerKind || (exports.CompletionTriggerKind = CompletionTriggerKind = {}));
var CompletionItemKind;
(function (CompletionItemKind) {
    CompletionItemKind[CompletionItemKind["Text"] = 0] = "Text";
    CompletionItemKind[CompletionItemKind["Method"] = 1] = "Method";
    CompletionItemKind[CompletionItemKind["Function"] = 2] = "Function";
    CompletionItemKind[CompletionItemKind["Constructor"] = 3] = "Constructor";
    CompletionItemKind[CompletionItemKind["Field"] = 4] = "Field";
    CompletionItemKind[CompletionItemKind["Variable"] = 5] = "Variable";
    CompletionItemKind[CompletionItemKind["Class"] = 6] = "Class";
    CompletionItemKind[CompletionItemKind["Interface"] = 7] = "Interface";
    CompletionItemKind[CompletionItemKind["Module"] = 8] = "Module";
    CompletionItemKind[CompletionItemKind["Property"] = 9] = "Property";
    CompletionItemKind[CompletionItemKind["Unit"] = 10] = "Unit";
    CompletionItemKind[CompletionItemKind["Value"] = 11] = "Value";
    CompletionItemKind[CompletionItemKind["Enum"] = 12] = "Enum";
    CompletionItemKind[CompletionItemKind["Keyword"] = 13] = "Keyword";
    CompletionItemKind[CompletionItemKind["Snippet"] = 14] = "Snippet";
    CompletionItemKind[CompletionItemKind["Color"] = 15] = "Color";
    CompletionItemKind[CompletionItemKind["File"] = 16] = "File";
    CompletionItemKind[CompletionItemKind["Reference"] = 17] = "Reference";
    CompletionItemKind[CompletionItemKind["Folder"] = 18] = "Folder";
    CompletionItemKind[CompletionItemKind["EnumMember"] = 19] = "EnumMember";
    CompletionItemKind[CompletionItemKind["Constant"] = 20] = "Constant";
    CompletionItemKind[CompletionItemKind["Struct"] = 21] = "Struct";
    CompletionItemKind[CompletionItemKind["Event"] = 22] = "Event";
    CompletionItemKind[CompletionItemKind["Operator"] = 23] = "Operator";
    CompletionItemKind[CompletionItemKind["TypeParameter"] = 24] = "TypeParameter";
    CompletionItemKind[CompletionItemKind["User"] = 25] = "User";
    CompletionItemKind[CompletionItemKind["Issue"] = 26] = "Issue";
})(CompletionItemKind || (exports.CompletionItemKind = CompletionItemKind = {}));
let CompletionItem = class CompletionItem {
    constructor(label, kind) {
        this.label = label;
        this.kind = kind;
    }
};
exports.CompletionItem = CompletionItem;
exports.CompletionItem = CompletionItem = tslib_1.__decorate([
    types_1.es5ClassCompat,
    tslib_1.__metadata("design:paramtypes", [String, Number])
], CompletionItem);
let CompletionList = class CompletionList {
    constructor(items = [], isIncomplete = false) {
        this.items = items;
        this.isIncomplete = isIncomplete;
    }
};
exports.CompletionList = CompletionList;
exports.CompletionList = CompletionList = tslib_1.__decorate([
    types_1.es5ClassCompat,
    tslib_1.__metadata("design:paramtypes", [Array, Boolean])
], CompletionList);
var InlineCompletionTriggerKind;
(function (InlineCompletionTriggerKind) {
    InlineCompletionTriggerKind[InlineCompletionTriggerKind["Invoke"] = 0] = "Invoke";
    InlineCompletionTriggerKind[InlineCompletionTriggerKind["Automatic"] = 1] = "Automatic";
})(InlineCompletionTriggerKind || (exports.InlineCompletionTriggerKind = InlineCompletionTriggerKind = {}));
let InlineCompletionItem = class InlineCompletionItem {
    constructor(insertText, range, command) {
        this.insertText = insertText;
        this.range = range;
        this.command = command;
    }
};
exports.InlineCompletionItem = InlineCompletionItem;
exports.InlineCompletionItem = InlineCompletionItem = tslib_1.__decorate([
    types_1.es5ClassCompat,
    tslib_1.__metadata("design:paramtypes", [String, Range, Object])
], InlineCompletionItem);
let InlineCompletionList = class InlineCompletionList {
    constructor(items) {
        this.commands = undefined;
        this.items = items;
    }
};
exports.InlineCompletionList = InlineCompletionList;
exports.InlineCompletionList = InlineCompletionList = tslib_1.__decorate([
    types_1.es5ClassCompat,
    tslib_1.__metadata("design:paramtypes", [Array])
], InlineCompletionList);
var DiagnosticSeverity;
(function (DiagnosticSeverity) {
    DiagnosticSeverity[DiagnosticSeverity["Error"] = 0] = "Error";
    DiagnosticSeverity[DiagnosticSeverity["Warning"] = 1] = "Warning";
    DiagnosticSeverity[DiagnosticSeverity["Information"] = 2] = "Information";
    DiagnosticSeverity[DiagnosticSeverity["Hint"] = 3] = "Hint";
})(DiagnosticSeverity || (exports.DiagnosticSeverity = DiagnosticSeverity = {}));
var DebugConsoleMode;
(function (DebugConsoleMode) {
    DebugConsoleMode[DebugConsoleMode["Separate"] = 0] = "Separate";
    DebugConsoleMode[DebugConsoleMode["MergeWithParent"] = 1] = "MergeWithParent";
})(DebugConsoleMode || (exports.DebugConsoleMode = DebugConsoleMode = {}));
let Location = Location_1 = class Location {
    constructor(uri, rangeOrPosition) {
        this.uri = uri;
        if (rangeOrPosition instanceof Range) {
            this.range = rangeOrPosition;
        }
        else if (rangeOrPosition instanceof Position) {
            this.range = new Range(rangeOrPosition, rangeOrPosition);
        }
    }
    static isLocation(thing) {
        if (thing instanceof Location_1) {
            return true;
        }
        if (!thing) {
            return false;
        }
        return Range.isRange(thing.range)
            && URI.isUri(thing.uri);
    }
};
exports.Location = Location;
exports.Location = Location = Location_1 = tslib_1.__decorate([
    types_1.es5ClassCompat,
    tslib_1.__metadata("design:paramtypes", [URI, Object])
], Location);
let DiagnosticRelatedInformation = class DiagnosticRelatedInformation {
    constructor(location, message) {
        this.location = location;
        this.message = message;
    }
};
exports.DiagnosticRelatedInformation = DiagnosticRelatedInformation;
exports.DiagnosticRelatedInformation = DiagnosticRelatedInformation = tslib_1.__decorate([
    types_1.es5ClassCompat,
    tslib_1.__metadata("design:paramtypes", [Location, String])
], DiagnosticRelatedInformation);
var DiagnosticTag;
(function (DiagnosticTag) {
    DiagnosticTag[DiagnosticTag["Unnecessary"] = 1] = "Unnecessary";
    DiagnosticTag[DiagnosticTag["Deprecated"] = 2] = "Deprecated";
})(DiagnosticTag || (exports.DiagnosticTag = DiagnosticTag = {}));
var CompletionItemTag;
(function (CompletionItemTag) {
    CompletionItemTag[CompletionItemTag["Deprecated"] = 1] = "Deprecated";
})(CompletionItemTag || (exports.CompletionItemTag = CompletionItemTag = {}));
let Diagnostic = class Diagnostic {
    constructor(range, message, severity = DiagnosticSeverity.Error) {
        this.range = range;
        this.message = message;
        this.severity = severity;
    }
};
exports.Diagnostic = Diagnostic;
exports.Diagnostic = Diagnostic = tslib_1.__decorate([
    types_1.es5ClassCompat,
    tslib_1.__metadata("design:paramtypes", [Range, String, Number])
], Diagnostic);
var MarkerSeverity;
(function (MarkerSeverity) {
    MarkerSeverity[MarkerSeverity["Hint"] = 1] = "Hint";
    MarkerSeverity[MarkerSeverity["Info"] = 2] = "Info";
    MarkerSeverity[MarkerSeverity["Warning"] = 4] = "Warning";
    MarkerSeverity[MarkerSeverity["Error"] = 8] = "Error";
})(MarkerSeverity || (exports.MarkerSeverity = MarkerSeverity = {}));
var MarkerTag;
(function (MarkerTag) {
    MarkerTag[MarkerTag["Unnecessary"] = 1] = "Unnecessary";
    MarkerTag[MarkerTag["Deprecated"] = 2] = "Deprecated";
})(MarkerTag || (exports.MarkerTag = MarkerTag = {}));
var NotebookCellKind;
(function (NotebookCellKind) {
    NotebookCellKind[NotebookCellKind["Markup"] = 1] = "Markup";
    NotebookCellKind[NotebookCellKind["Code"] = 2] = "Code";
})(NotebookCellKind || (exports.NotebookCellKind = NotebookCellKind = {}));
var NotebookCellStatusBarAlignment;
(function (NotebookCellStatusBarAlignment) {
    NotebookCellStatusBarAlignment[NotebookCellStatusBarAlignment["Left"] = 1] = "Left";
    NotebookCellStatusBarAlignment[NotebookCellStatusBarAlignment["Right"] = 2] = "Right";
})(NotebookCellStatusBarAlignment || (exports.NotebookCellStatusBarAlignment = NotebookCellStatusBarAlignment = {}));
var NotebookControllerAffinity;
(function (NotebookControllerAffinity) {
    NotebookControllerAffinity[NotebookControllerAffinity["Default"] = 1] = "Default";
    NotebookControllerAffinity[NotebookControllerAffinity["Preferred"] = 2] = "Preferred";
})(NotebookControllerAffinity || (exports.NotebookControllerAffinity = NotebookControllerAffinity = {}));
var NotebookEditorRevealType;
(function (NotebookEditorRevealType) {
    NotebookEditorRevealType[NotebookEditorRevealType["Default"] = 0] = "Default";
    NotebookEditorRevealType[NotebookEditorRevealType["InCenter"] = 1] = "InCenter";
    NotebookEditorRevealType[NotebookEditorRevealType["InCenterIfOutsideViewport"] = 2] = "InCenterIfOutsideViewport";
    NotebookEditorRevealType[NotebookEditorRevealType["AtTop"] = 3] = "AtTop";
})(NotebookEditorRevealType || (exports.NotebookEditorRevealType = NotebookEditorRevealType = {}));
var NotebookCellExecutionState;
(function (NotebookCellExecutionState) {
    /**
     * The cell is idle.
     */
    NotebookCellExecutionState[NotebookCellExecutionState["Idle"] = 1] = "Idle";
    /**
     * Execution for the cell is pending.
     */
    NotebookCellExecutionState[NotebookCellExecutionState["Pending"] = 2] = "Pending";
    /**
     * The cell is currently executing.
     */
    NotebookCellExecutionState[NotebookCellExecutionState["Executing"] = 3] = "Executing";
})(NotebookCellExecutionState || (exports.NotebookCellExecutionState = NotebookCellExecutionState = {}));
class NotebookKernelSourceAction {
    constructor(label) {
        this.label = label;
    }
}
exports.NotebookKernelSourceAction = NotebookKernelSourceAction;
let NotebookCellData = class NotebookCellData {
    constructor(kind, value, languageId, outputs, metadata, executionSummary) {
        this.kind = kind;
        this.value = value;
        this.languageId = languageId;
        this.outputs = outputs !== null && outputs !== void 0 ? outputs : [];
        this.metadata = metadata;
        this.executionSummary = executionSummary;
    }
};
exports.NotebookCellData = NotebookCellData;
exports.NotebookCellData = NotebookCellData = tslib_1.__decorate([
    types_1.es5ClassCompat,
    tslib_1.__metadata("design:paramtypes", [Number, String, String, Array, Object, Object])
], NotebookCellData);
let NotebookCellOutput = class NotebookCellOutput {
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    constructor(items, idOrMetadata, metadata) {
        this.items = items;
        if (typeof idOrMetadata === 'string') {
            this.outputId = idOrMetadata;
            this.metadata = metadata;
        }
        else {
            this.outputId = coreutils_1.UUID.uuid4();
            this.metadata = idOrMetadata !== null && idOrMetadata !== void 0 ? idOrMetadata : metadata;
        }
    }
};
exports.NotebookCellOutput = NotebookCellOutput;
exports.NotebookCellOutput = NotebookCellOutput = tslib_1.__decorate([
    types_1.es5ClassCompat,
    tslib_1.__metadata("design:paramtypes", [Array, Object, Object])
], NotebookCellOutput);
class NotebookCellOutputItem {
    static text(value, mime) {
        const bytes = tslib_1.__classPrivateFieldGet(_a, _a, "f", _NotebookCellOutputItem_encoder).encode(String(value));
        return new _a(bytes, mime || 'text/plain');
    }
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    static json(value, mime) {
        const jsonStr = JSON.stringify(value, undefined, '\t');
        return _a.text(jsonStr, mime);
    }
    static stdout(value) {
        return _a.text(value, 'application/vnd.code.notebook.stdout');
    }
    static stderr(value) {
        return _a.text(value, 'application/vnd.code.notebook.stderr');
    }
    static error(value) {
        return _a.json(value, 'application/vnd.code.notebook.error');
    }
    constructor(data, mime) {
        this.data = data;
        this.mime = mime;
    }
}
exports.NotebookCellOutputItem = NotebookCellOutputItem;
_a = NotebookCellOutputItem;
_NotebookCellOutputItem_encoder = { value: new TextEncoder() };
let NotebookCellStatusBarItem = class NotebookCellStatusBarItem {
    /**
     * Creates a new NotebookCellStatusBarItem.
     * @param text The text to show for the item.
     * @param alignment Whether the item is aligned to the left or right.
     * @stubbed
     */
    constructor(text, alignment) {
        this.text = text;
        this.alignment = alignment;
    }
};
exports.NotebookCellStatusBarItem = NotebookCellStatusBarItem;
exports.NotebookCellStatusBarItem = NotebookCellStatusBarItem = tslib_1.__decorate([
    types_1.es5ClassCompat,
    tslib_1.__metadata("design:paramtypes", [String, Number])
], NotebookCellStatusBarItem);
let NotebookData = class NotebookData {
    constructor(cells) {
        this.cells = cells;
    }
};
exports.NotebookData = NotebookData;
exports.NotebookData = NotebookData = tslib_1.__decorate([
    types_1.es5ClassCompat,
    tslib_1.__metadata("design:paramtypes", [Array])
], NotebookData);
class NotebookRange {
    static isNotebookRange(thing) {
        if (thing instanceof NotebookRange) {
            return true;
        }
        if (!thing) {
            return false;
        }
        return typeof thing.start === 'number'
            && typeof thing.end === 'number';
    }
    with(change) {
        let newStart = this.start;
        let newEnd = this.end;
        if (change.start !== undefined) {
            newStart = change.start;
        }
        if (change.end !== undefined) {
            newEnd = change.end;
        }
        if (newStart === this.start && newEnd === this.end) {
            return this;
        }
        return new NotebookRange(newStart, newEnd);
    }
    constructor(start, end) {
        this.start = start;
        this.end = end;
    }
}
exports.NotebookRange = NotebookRange;
class SnippetTextEdit {
    static isSnippetTextEdit(thing) {
        return thing instanceof SnippetTextEdit || (0, common_1.isObject)(thing)
            && Range.isRange(thing.range)
            && SnippetString.isSnippetString(thing.snippet);
    }
    static replace(range, snippet) {
        return new SnippetTextEdit(range, snippet);
    }
    static insert(position, snippet) {
        return SnippetTextEdit.replace(new Range(position, position), snippet);
    }
    constructor(range, snippet) {
        this.range = range;
        this.snippet = snippet;
    }
}
exports.SnippetTextEdit = SnippetTextEdit;
let NotebookEdit = NotebookEdit_1 = class NotebookEdit {
    static isNotebookCellEdit(thing) {
        if (thing instanceof NotebookEdit_1) {
            return true;
        }
        if (!thing) {
            return false;
        }
        return NotebookRange.isNotebookRange(thing)
            && Array.isArray(thing.newCells);
    }
    static replaceCells(range, newCells) {
        return new NotebookEdit_1(range, newCells);
    }
    static insertCells(index, newCells) {
        return new NotebookEdit_1(new NotebookRange(index, index), newCells);
    }
    static deleteCells(range) {
        return new NotebookEdit_1(range, []);
    }
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    static updateCellMetadata(index, newCellMetadata) {
        return new NotebookEdit_1(new NotebookRange(index, index), [], newCellMetadata);
    }
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    static updateNotebookMetadata(newNotebookMetadata) {
        return new NotebookEdit_1(new NotebookRange(0, 0), [], undefined, newNotebookMetadata);
    }
    constructor(range, newCells, newCellMetadata, newNotebookMetadata) {
        this.range = range;
        this.newCells = newCells;
        this.newCellMetadata = newCellMetadata;
        this.newNotebookMetadata = newNotebookMetadata;
    }
};
exports.NotebookEdit = NotebookEdit;
exports.NotebookEdit = NotebookEdit = NotebookEdit_1 = tslib_1.__decorate([
    types_1.es5ClassCompat,
    tslib_1.__metadata("design:paramtypes", [NotebookRange, Array, Object, Object])
], NotebookEdit);
class NotebookRendererScript {
    constructor(uri, provides) {
        this.uri = uri;
        this.provides = Array.isArray(provides) ? provides : [provides];
    }
    ;
}
exports.NotebookRendererScript = NotebookRendererScript;
let ParameterInformation = class ParameterInformation {
    constructor(label, documentation) {
        this.label = label;
        this.documentation = documentation;
    }
};
exports.ParameterInformation = ParameterInformation;
exports.ParameterInformation = ParameterInformation = tslib_1.__decorate([
    types_1.es5ClassCompat,
    tslib_1.__metadata("design:paramtypes", [Object, Object])
], ParameterInformation);
let SignatureInformation = class SignatureInformation {
    constructor(label, documentation) {
        this.label = label;
        this.documentation = documentation;
        this.parameters = [];
    }
};
exports.SignatureInformation = SignatureInformation;
exports.SignatureInformation = SignatureInformation = tslib_1.__decorate([
    types_1.es5ClassCompat,
    tslib_1.__metadata("design:paramtypes", [String, Object])
], SignatureInformation);
var SignatureHelpTriggerKind;
(function (SignatureHelpTriggerKind) {
    SignatureHelpTriggerKind[SignatureHelpTriggerKind["Invoke"] = 1] = "Invoke";
    SignatureHelpTriggerKind[SignatureHelpTriggerKind["TriggerCharacter"] = 2] = "TriggerCharacter";
    SignatureHelpTriggerKind[SignatureHelpTriggerKind["ContentChange"] = 3] = "ContentChange";
})(SignatureHelpTriggerKind || (exports.SignatureHelpTriggerKind = SignatureHelpTriggerKind = {}));
let SignatureHelp = class SignatureHelp {
    constructor() {
        this.signatures = [];
    }
};
exports.SignatureHelp = SignatureHelp;
exports.SignatureHelp = SignatureHelp = tslib_1.__decorate([
    types_1.es5ClassCompat,
    tslib_1.__metadata("design:paramtypes", [])
], SignatureHelp);
let Hover = class Hover {
    constructor(contents, range) {
        if (!contents) {
            (0, errors_1.illegalArgument)('contents must be defined');
        }
        if (Array.isArray(contents)) {
            this.contents = contents;
        }
        else {
            this.contents = [contents];
        }
        this.range = range;
    }
};
exports.Hover = Hover;
exports.Hover = Hover = tslib_1.__decorate([
    types_1.es5ClassCompat,
    tslib_1.__metadata("design:paramtypes", [Object, Range])
], Hover);
let EvaluatableExpression = class EvaluatableExpression {
    constructor(range, expression) {
        if (!range) {
            (0, errors_1.illegalArgument)('range must be defined');
        }
        this.range = range;
        this.expression = expression;
    }
};
exports.EvaluatableExpression = EvaluatableExpression;
exports.EvaluatableExpression = EvaluatableExpression = tslib_1.__decorate([
    types_1.es5ClassCompat,
    tslib_1.__metadata("design:paramtypes", [Range, String])
], EvaluatableExpression);
let InlineValueContext = class InlineValueContext {
    constructor(frameId, stoppedLocation) {
        if (!frameId) {
            (0, errors_1.illegalArgument)('frameId must be defined');
        }
        if (!stoppedLocation) {
            (0, errors_1.illegalArgument)('stoppedLocation must be defined');
        }
        this.frameId = frameId;
        this.stoppedLocation = stoppedLocation;
    }
};
exports.InlineValueContext = InlineValueContext;
exports.InlineValueContext = InlineValueContext = tslib_1.__decorate([
    types_1.es5ClassCompat,
    tslib_1.__metadata("design:paramtypes", [Number, Range])
], InlineValueContext);
let InlineValueText = class InlineValueText {
    constructor(range, text) {
        this.type = 'text';
        if (!range) {
            (0, errors_1.illegalArgument)('range must be defined');
        }
        if (!text) {
            (0, errors_1.illegalArgument)('text must be defined');
        }
        this.range = range;
        this.text = text;
    }
};
exports.InlineValueText = InlineValueText;
exports.InlineValueText = InlineValueText = tslib_1.__decorate([
    types_1.es5ClassCompat,
    tslib_1.__metadata("design:paramtypes", [Range, String])
], InlineValueText);
let InlineValueVariableLookup = class InlineValueVariableLookup {
    constructor(range, variableName, caseSensitiveLookup) {
        this.type = 'variable';
        if (!range) {
            (0, errors_1.illegalArgument)('range must be defined');
        }
        this.range = range;
        this.caseSensitiveLookup = caseSensitiveLookup || true;
        this.variableName = variableName;
    }
};
exports.InlineValueVariableLookup = InlineValueVariableLookup;
exports.InlineValueVariableLookup = InlineValueVariableLookup = tslib_1.__decorate([
    types_1.es5ClassCompat,
    tslib_1.__metadata("design:paramtypes", [Range, String, Boolean])
], InlineValueVariableLookup);
let InlineValueEvaluatableExpression = class InlineValueEvaluatableExpression {
    constructor(range, expression) {
        this.type = 'expression';
        if (!range) {
            (0, errors_1.illegalArgument)('range must be defined');
        }
        this.range = range;
        this.expression = expression;
    }
};
exports.InlineValueEvaluatableExpression = InlineValueEvaluatableExpression;
exports.InlineValueEvaluatableExpression = InlineValueEvaluatableExpression = tslib_1.__decorate([
    types_1.es5ClassCompat,
    tslib_1.__metadata("design:paramtypes", [Range, String])
], InlineValueEvaluatableExpression);
var DocumentHighlightKind;
(function (DocumentHighlightKind) {
    DocumentHighlightKind[DocumentHighlightKind["Text"] = 0] = "Text";
    DocumentHighlightKind[DocumentHighlightKind["Read"] = 1] = "Read";
    DocumentHighlightKind[DocumentHighlightKind["Write"] = 2] = "Write";
})(DocumentHighlightKind || (exports.DocumentHighlightKind = DocumentHighlightKind = {}));
let DocumentHighlight = class DocumentHighlight {
    constructor(range, kind) {
        this.range = range;
        this.kind = kind;
    }
};
exports.DocumentHighlight = DocumentHighlight;
exports.DocumentHighlight = DocumentHighlight = tslib_1.__decorate([
    types_1.es5ClassCompat,
    tslib_1.__metadata("design:paramtypes", [Range, Number])
], DocumentHighlight);
let MultiDocumentHighlight = class MultiDocumentHighlight {
    /**
     * Creates a new instance of MultiDocumentHighlight.
     * @param uri The URI of the document containing the highlights.
     * @param highlights The highlights for the document.
     */
    constructor(uri, highlights) {
        this.uri = uri;
        this.highlights = highlights;
    }
};
exports.MultiDocumentHighlight = MultiDocumentHighlight;
exports.MultiDocumentHighlight = MultiDocumentHighlight = tslib_1.__decorate([
    types_1.es5ClassCompat,
    tslib_1.__metadata("design:paramtypes", [URI, Array])
], MultiDocumentHighlight);
let DocumentLink = class DocumentLink {
    constructor(range, target) {
        if (target && !(URI.isUri(target))) {
            throw (0, errors_1.illegalArgument)('target');
        }
        if (!Range.isRange(range) || range.isEmpty) {
            throw (0, errors_1.illegalArgument)('range');
        }
        this.range = range;
        this.target = target;
    }
};
exports.DocumentLink = DocumentLink;
exports.DocumentLink = DocumentLink = tslib_1.__decorate([
    types_1.es5ClassCompat,
    tslib_1.__metadata("design:paramtypes", [Range, Object])
], DocumentLink);
let DocumentDropOrPasteEditKind = DocumentDropOrPasteEditKind_1 = class DocumentDropOrPasteEditKind {
    constructor(value) {
        this.value = value;
    }
    append(...parts) {
        return new DocumentDropOrPasteEditKind_1((this.value ? [this.value, ...parts] : parts).join(DocumentDropOrPasteEditKind_1.sep));
    }
    intersects(other) {
        return this.contains(other) || other.contains(this);
    }
    contains(other) {
        return this.value === other.value || other.value.startsWith(this.value + DocumentDropOrPasteEditKind_1.sep);
    }
};
exports.DocumentDropOrPasteEditKind = DocumentDropOrPasteEditKind;
DocumentDropOrPasteEditKind.Empty = new DocumentDropOrPasteEditKind_1('');
DocumentDropOrPasteEditKind.sep = '.';
exports.DocumentDropOrPasteEditKind = DocumentDropOrPasteEditKind = DocumentDropOrPasteEditKind_1 = tslib_1.__decorate([
    types_1.es5ClassCompat,
    tslib_1.__metadata("design:paramtypes", [String])
], DocumentDropOrPasteEditKind);
let DocumentDropEdit = class DocumentDropEdit {
    constructor(insertText) {
        this.insertText = insertText;
    }
};
exports.DocumentDropEdit = DocumentDropEdit;
exports.DocumentDropEdit = DocumentDropEdit = tslib_1.__decorate([
    types_1.es5ClassCompat,
    tslib_1.__metadata("design:paramtypes", [Object])
], DocumentDropEdit);
let CodeLens = class CodeLens {
    get isResolved() {
        return !!this.command;
    }
    constructor(range, command) {
        this.range = range;
        this.command = command;
    }
};
exports.CodeLens = CodeLens;
exports.CodeLens = CodeLens = tslib_1.__decorate([
    types_1.es5ClassCompat,
    tslib_1.__metadata("design:paramtypes", [Range, Object])
], CodeLens);
var CodeActionTrigger;
(function (CodeActionTrigger) {
    CodeActionTrigger[CodeActionTrigger["Automatic"] = 1] = "Automatic";
    CodeActionTrigger[CodeActionTrigger["Manual"] = 2] = "Manual";
})(CodeActionTrigger || (exports.CodeActionTrigger = CodeActionTrigger = {}));
/**
 * The reason why code actions were requested.
 */
var CodeActionTriggerKind;
(function (CodeActionTriggerKind) {
    /**
     * Code actions were explicitly requested by the user or by an extension.
     */
    CodeActionTriggerKind[CodeActionTriggerKind["Invoke"] = 1] = "Invoke";
    /**
     * Code actions were requested automatically.
     *
     * This typically happens when current selection in a file changes, but can
     * also be triggered when file content changes.
     */
    CodeActionTriggerKind[CodeActionTriggerKind["Automatic"] = 2] = "Automatic";
})(CodeActionTriggerKind || (exports.CodeActionTriggerKind = CodeActionTriggerKind = {}));
let CodeActionKind = CodeActionKind_1 = class CodeActionKind {
    constructor(value) {
        this.value = value;
    }
    append(parts) {
        return new CodeActionKind_1(this.value ? this.value + CodeActionKind_1.sep + parts : parts);
    }
    contains(other) {
        return this.value === other.value || (0, strings_1.startsWithIgnoreCase)(other.value, this.value + CodeActionKind_1.sep);
    }
    intersects(other) {
        return this.contains(other) || other.contains(this);
    }
};
exports.CodeActionKind = CodeActionKind;
CodeActionKind.sep = '.';
CodeActionKind.Empty = new CodeActionKind_1('');
CodeActionKind.QuickFix = CodeActionKind_1.Empty.append('quickfix');
CodeActionKind.Refactor = CodeActionKind_1.Empty.append('refactor');
CodeActionKind.RefactorExtract = CodeActionKind_1.Refactor.append('extract');
CodeActionKind.RefactorInline = CodeActionKind_1.Refactor.append('inline');
CodeActionKind.RefactorMove = CodeActionKind_1.Refactor.append('move');
CodeActionKind.RefactorRewrite = CodeActionKind_1.Refactor.append('rewrite');
CodeActionKind.Source = CodeActionKind_1.Empty.append('source');
CodeActionKind.SourceOrganizeImports = CodeActionKind_1.Source.append('organizeImports');
CodeActionKind.SourceFixAll = CodeActionKind_1.Source.append('fixAll');
CodeActionKind.Notebook = CodeActionKind_1.Empty.append('notebook');
exports.CodeActionKind = CodeActionKind = CodeActionKind_1 = tslib_1.__decorate([
    types_1.es5ClassCompat,
    tslib_1.__metadata("design:paramtypes", [String])
], CodeActionKind);
var TextDocumentSaveReason;
(function (TextDocumentSaveReason) {
    TextDocumentSaveReason[TextDocumentSaveReason["Manual"] = 1] = "Manual";
    TextDocumentSaveReason[TextDocumentSaveReason["AfterDelay"] = 2] = "AfterDelay";
    TextDocumentSaveReason[TextDocumentSaveReason["FocusOut"] = 3] = "FocusOut";
})(TextDocumentSaveReason || (exports.TextDocumentSaveReason = TextDocumentSaveReason = {}));
let CodeAction = class CodeAction {
    constructor(title, kind) {
        this.title = title;
        this.kind = kind;
    }
};
exports.CodeAction = CodeAction;
exports.CodeAction = CodeAction = tslib_1.__decorate([
    types_1.es5ClassCompat,
    tslib_1.__metadata("design:paramtypes", [String, CodeActionKind])
], CodeAction);
let WorkspaceEdit = class WorkspaceEdit {
    constructor() {
        this._edits = new Array();
    }
    renameFile(from, to, options, metadata) {
        this._edits.push({ _type: 1, from, to, options, metadata });
    }
    createFile(uri, options, metadata) {
        this._edits.push({ _type: 1, from: undefined, to: uri, options, metadata });
    }
    deleteFile(uri, options, metadata) {
        this._edits.push({ _type: 1, from: uri, to: undefined, options, metadata });
    }
    replace(uri, range, newText, metadata) {
        this._edits.push({ _type: 2, uri, edit: new TextEdit(range, newText), metadata });
    }
    insert(resource, position, newText, metadata) {
        this.replace(resource, new Range(position, position), newText, metadata);
    }
    delete(resource, range, metadata) {
        this.replace(resource, range, '', metadata);
    }
    has(uri) {
        for (const edit of this._edits) {
            if (edit && edit._type === 2 && edit.uri.toString() === uri.toString()) {
                return true;
            }
        }
        return false;
    }
    set(uri, edits) {
        if (!edits) {
            // remove all text edits for `uri`
            for (let i = 0; i < this._edits.length; i++) {
                const element = this._edits[i];
                if (element &&
                    (element._type === 2 /* FileEditType.Text */ || element._type === 6 /* FileEditType.Snippet */) &&
                    element.uri.toString() === uri.toString()) {
                    this._edits[i] = undefined;
                }
            }
            this._edits = this._edits.filter(e => !!e);
        }
        else {
            // append edit to the end
            for (const editOrTuple of edits) {
                if (!editOrTuple) {
                    continue;
                }
                let edit;
                let metadata;
                if (Array.isArray(editOrTuple)) {
                    edit = editOrTuple[0];
                    metadata = editOrTuple[1];
                }
                else {
                    edit = editOrTuple;
                }
                if (NotebookEdit.isNotebookCellEdit(edit)) {
                    if (edit.newCellMetadata) {
                        this._edits.push({
                            _type: 3 /* FileEditType.Cell */, metadata, uri,
                            edit: { editType: 3 /* CellEditType.Metadata */, index: edit.range.start, metadata: edit.newCellMetadata }
                        });
                    }
                    else if (edit.newNotebookMetadata) {
                        this._edits.push({
                            _type: 3 /* FileEditType.Cell */, metadata, uri,
                            edit: { editType: 5 /* CellEditType.DocumentMetadata */, metadata: edit.newNotebookMetadata }, notebookMetadata: edit.newNotebookMetadata
                        });
                    }
                    else {
                        const start = edit.range.start;
                        const end = edit.range.end;
                        if (start !== end || edit.newCells.length > 0) {
                            this._edits.push({ _type: 5 /* FileEditType.CellReplace */, uri, index: start, count: end - start, cells: edit.newCells, metadata });
                        }
                    }
                }
                else if (SnippetTextEdit.isSnippetTextEdit(edit)) {
                    this._edits.push({ _type: 6 /* FileEditType.Snippet */, uri, range: edit.range, edit, metadata });
                }
                else {
                    this._edits.push({ _type: 2 /* FileEditType.Text */, uri, edit });
                }
            }
        }
    }
    get(uri) {
        const res = [];
        for (const candidate of this._edits) {
            if (candidate && candidate._type === 2 && candidate.uri.toString() === uri.toString()) {
                res.push(candidate.edit);
            }
        }
        if (res.length === 0) {
            return undefined;
        }
        return res;
    }
    entries() {
        const textEdits = new Map();
        for (const candidate of this._edits) {
            if (candidate && candidate._type === 2 /* FileEditType.Text */) {
                let textEdit = textEdits.get(candidate.uri.toString());
                if (!textEdit) {
                    textEdit = [candidate.uri, []];
                    textEdits.set(candidate.uri.toString(), textEdit);
                }
                textEdit[1].push(candidate.edit);
            }
        }
        const result = [];
        textEdits.forEach(v => result.push(v));
        return result;
    }
    // _allEntries(): ([URI, Array<TextEdit | SnippetTextEdit>, theia.WorkspaceEditEntryMetadata] | [URI, URI, FileOperationOptions, WorkspaceEditMetadata])[] {
    //     const res: ([URI, Array<TextEdit | SnippetTextEdit>, theia.WorkspaceEditEntryMetadata] | [URI, URI, FileOperationOptions, WorkspaceEditMetadata])[] = [];
    //     for (const edit of this._edits) {
    //         if (!edit) {
    //             continue;
    //         }
    //         if (edit._type === FileEditType.File) {
    //             res.push([edit.from!, edit.to!, edit.options!, edit.metadata!]);
    //         } else {
    //             res.push([edit.uri, [edit.edit], edit.metadata!]);
    //         }
    //     }
    //     return res;
    // }
    _allEntries() {
        return this._edits;
    }
    get size() {
        return this.entries().length;
    }
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    toJSON() {
        return this.entries();
    }
};
exports.WorkspaceEdit = WorkspaceEdit;
exports.WorkspaceEdit = WorkspaceEdit = tslib_1.__decorate([
    types_1.es5ClassCompat
], WorkspaceEdit);
class DataTransferItem {
    asString() {
        return Promise.resolve(typeof this.value === 'string' ? this.value : JSON.stringify(this.value));
    }
    asFile() {
        return undefined;
    }
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    constructor(value) {
        this.value = value;
    }
}
exports.DataTransferItem = DataTransferItem;
/**
 * A map containing a mapping of the mime type of the corresponding transferred data.
 *
 * Drag and drop controllers that implement {@link TreeDragAndDropController.handleDrag `handleDrag`} can add additional mime types to the
 * data transfer. These additional mime types will only be included in the `handleDrop` when the the drag was initiated from
 * an element in the same drag and drop controller.
 */
let DataTransfer = class DataTransfer {
    constructor() {
        this.items = new Map();
    }
    get(mimeType) {
        return this.items.get(mimeType);
    }
    set(mimeType, value) {
        this.items.set(mimeType, value);
    }
    has(mimeType) {
        return this.items.has(mimeType);
    }
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    forEach(callbackfn, thisArg) {
        this.items.forEach((item, mimetype) => {
            callbackfn.call(thisArg, item, mimetype, this);
        });
    }
    [Symbol.iterator]() {
        return this.items[Symbol.iterator]();
    }
    clear() {
        this.items.clear();
    }
};
exports.DataTransfer = DataTransfer;
exports.DataTransfer = DataTransfer = tslib_1.__decorate([
    types_1.es5ClassCompat
], DataTransfer);
let TreeItem = class TreeItem {
    constructor(arg1, collapsibleState = TreeItemCollapsibleState.None) {
        this.collapsibleState = collapsibleState;
        if (arg1 instanceof URI) {
            this.resourceUri = arg1;
        }
        else {
            this.label = arg1;
        }
    }
};
exports.TreeItem = TreeItem;
exports.TreeItem = TreeItem = tslib_1.__decorate([
    types_1.es5ClassCompat,
    tslib_1.__metadata("design:paramtypes", [Object, Number])
], TreeItem);
var TreeItemCollapsibleState;
(function (TreeItemCollapsibleState) {
    TreeItemCollapsibleState[TreeItemCollapsibleState["None"] = 0] = "None";
    TreeItemCollapsibleState[TreeItemCollapsibleState["Collapsed"] = 1] = "Collapsed";
    TreeItemCollapsibleState[TreeItemCollapsibleState["Expanded"] = 2] = "Expanded";
})(TreeItemCollapsibleState || (exports.TreeItemCollapsibleState = TreeItemCollapsibleState = {}));
var TreeItemCheckboxState;
(function (TreeItemCheckboxState) {
    TreeItemCheckboxState[TreeItemCheckboxState["Unchecked"] = 0] = "Unchecked";
    TreeItemCheckboxState[TreeItemCheckboxState["Checked"] = 1] = "Checked";
})(TreeItemCheckboxState || (exports.TreeItemCheckboxState = TreeItemCheckboxState = {}));
var SymbolTag;
(function (SymbolTag) {
    SymbolTag[SymbolTag["Deprecated"] = 1] = "Deprecated";
})(SymbolTag || (exports.SymbolTag = SymbolTag = {}));
let SymbolInformation = SymbolInformation_1 = class SymbolInformation {
    static validate(candidate) {
        if (!candidate.name) {
            throw new Error('Should provide a name inside candidate field');
        }
    }
    constructor(name, kind, rangeOrContainer, locationOrUri, containerName) {
        this.name = name;
        this.kind = kind;
        this.containerName = containerName;
        if (typeof rangeOrContainer === 'string') {
            this.containerName = rangeOrContainer;
        }
        if (locationOrUri instanceof Location) {
            this.location = locationOrUri;
        }
        else if (rangeOrContainer instanceof Range) {
            this.location = new Location(locationOrUri, rangeOrContainer);
        }
        SymbolInformation_1.validate(this);
    }
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    toJSON() {
        return {
            name: this.name,
            kind: plugin_api_rpc_model_1.SymbolKind[this.kind],
            location: this.location,
            containerName: this.containerName
        };
    }
};
exports.SymbolInformation = SymbolInformation;
exports.SymbolInformation = SymbolInformation = SymbolInformation_1 = tslib_1.__decorate([
    types_1.es5ClassCompat,
    tslib_1.__metadata("design:paramtypes", [String, Number, Object, Object, String])
], SymbolInformation);
let DocumentSymbol = DocumentSymbol_1 = class DocumentSymbol {
    static validate(candidate) {
        if (!candidate.name) {
            throw new Error('Should provide a name inside candidate field');
        }
        if (!candidate.range.contains(candidate.selectionRange)) {
            throw new Error('selectionRange must be contained in fullRange');
        }
        if (candidate.children) {
            candidate.children.forEach(DocumentSymbol_1.validate);
        }
    }
    constructor(name, detail, kind, range, selectionRange) {
        this.name = name;
        this.detail = detail;
        this.kind = kind;
        this.range = range;
        this.selectionRange = selectionRange;
        this.children = [];
        DocumentSymbol_1.validate(this);
    }
};
exports.DocumentSymbol = DocumentSymbol;
exports.DocumentSymbol = DocumentSymbol = DocumentSymbol_1 = tslib_1.__decorate([
    types_1.es5ClassCompat,
    tslib_1.__metadata("design:paramtypes", [String, String, Number, Range, Range])
], DocumentSymbol);
var CommentThreadState;
(function (CommentThreadState) {
    CommentThreadState[CommentThreadState["Unresolved"] = 0] = "Unresolved";
    CommentThreadState[CommentThreadState["Resolved"] = 1] = "Resolved";
})(CommentThreadState || (exports.CommentThreadState = CommentThreadState = {}));
var CommentThreadCollapsibleState;
(function (CommentThreadCollapsibleState) {
    CommentThreadCollapsibleState[CommentThreadCollapsibleState["Collapsed"] = 0] = "Collapsed";
    CommentThreadCollapsibleState[CommentThreadCollapsibleState["Expanded"] = 1] = "Expanded";
})(CommentThreadCollapsibleState || (exports.CommentThreadCollapsibleState = CommentThreadCollapsibleState = {}));
let QuickInputButtons = class QuickInputButtons {
};
exports.QuickInputButtons = QuickInputButtons;
QuickInputButtons.Back = {
    iconPath: {
        id: 'Back',
    },
    tooltip: 'Back'
};
exports.QuickInputButtons = QuickInputButtons = tslib_1.__decorate([
    types_1.es5ClassCompat
], QuickInputButtons);
let TerminalLink = class TerminalLink {
    static validate(candidate) {
        if (typeof candidate.startIndex !== 'number') {
            throw new Error('Should provide a startIndex inside candidate field');
        }
        if (typeof candidate.length !== 'number') {
            throw new Error('Should provide a length inside candidate field');
        }
    }
    constructor(startIndex, length, tooltip) {
        this.startIndex = startIndex;
        this.length = length;
        this.tooltip = tooltip;
    }
};
exports.TerminalLink = TerminalLink;
exports.TerminalLink = TerminalLink = tslib_1.__decorate([
    types_1.es5ClassCompat,
    tslib_1.__metadata("design:paramtypes", [Number, Number, String])
], TerminalLink);
var TerminalLocation;
(function (TerminalLocation) {
    TerminalLocation[TerminalLocation["Panel"] = 1] = "Panel";
    TerminalLocation[TerminalLocation["Editor"] = 2] = "Editor";
})(TerminalLocation || (exports.TerminalLocation = TerminalLocation = {}));
var TerminalOutputAnchor;
(function (TerminalOutputAnchor) {
    TerminalOutputAnchor[TerminalOutputAnchor["Top"] = 0] = "Top";
    TerminalOutputAnchor[TerminalOutputAnchor["Bottom"] = 1] = "Bottom";
})(TerminalOutputAnchor || (exports.TerminalOutputAnchor = TerminalOutputAnchor = {}));
class TerminalProfile {
    /**
     * Creates a new terminal profile.
     * @param options The options that the terminal will launch with.
     */
    constructor(options) {
        this.options = options;
    }
}
exports.TerminalProfile = TerminalProfile;
var TerminalExitReason;
(function (TerminalExitReason) {
    TerminalExitReason[TerminalExitReason["Unknown"] = 0] = "Unknown";
    TerminalExitReason[TerminalExitReason["Shutdown"] = 1] = "Shutdown";
    TerminalExitReason[TerminalExitReason["Process"] = 2] = "Process";
    TerminalExitReason[TerminalExitReason["User"] = 3] = "User";
    TerminalExitReason[TerminalExitReason["Extension"] = 4] = "Extension";
})(TerminalExitReason || (exports.TerminalExitReason = TerminalExitReason = {}));
let FileDecoration = class FileDecoration {
    static validate(d) {
        if (d.badge && d.badge.length !== 1 && d.badge.length !== 2) {
            throw new Error('The \'badge\'-property must be undefined or a short character');
        }
        if (!d.color && !d.badge && !d.tooltip) {
            throw new Error('The decoration is empty');
        }
    }
    constructor(badge, tooltip, color) {
        this.badge = badge;
        this.tooltip = tooltip;
        this.color = color;
    }
};
exports.FileDecoration = FileDecoration;
exports.FileDecoration = FileDecoration = tslib_1.__decorate([
    types_1.es5ClassCompat,
    tslib_1.__metadata("design:paramtypes", [String, String, ThemeColor])
], FileDecoration);
var CommentMode;
(function (CommentMode) {
    CommentMode[CommentMode["Editing"] = 0] = "Editing";
    CommentMode[CommentMode["Preview"] = 1] = "Preview";
})(CommentMode || (exports.CommentMode = CommentMode = {}));
// #region file api
var FileChangeType;
(function (FileChangeType) {
    FileChangeType[FileChangeType["Changed"] = 1] = "Changed";
    FileChangeType[FileChangeType["Created"] = 2] = "Created";
    FileChangeType[FileChangeType["Deleted"] = 3] = "Deleted";
})(FileChangeType || (exports.FileChangeType = FileChangeType = {}));
let FileSystemError = FileSystemError_1 = class FileSystemError extends Error {
    static FileExists(messageOrUri) {
        return new FileSystemError_1(messageOrUri, files_1.FileSystemProviderErrorCode.FileExists, FileSystemError_1.FileExists);
    }
    static FileNotFound(messageOrUri) {
        return new FileSystemError_1(messageOrUri, files_1.FileSystemProviderErrorCode.FileNotFound, FileSystemError_1.FileNotFound);
    }
    static FileNotADirectory(messageOrUri) {
        return new FileSystemError_1(messageOrUri, files_1.FileSystemProviderErrorCode.FileNotADirectory, FileSystemError_1.FileNotADirectory);
    }
    static FileIsADirectory(messageOrUri) {
        return new FileSystemError_1(messageOrUri, files_1.FileSystemProviderErrorCode.FileIsADirectory, FileSystemError_1.FileIsADirectory);
    }
    static NoPermissions(messageOrUri) {
        return new FileSystemError_1(messageOrUri, files_1.FileSystemProviderErrorCode.NoPermissions, FileSystemError_1.NoPermissions);
    }
    static Unavailable(messageOrUri) {
        return new FileSystemError_1(messageOrUri, files_1.FileSystemProviderErrorCode.Unavailable, FileSystemError_1.Unavailable);
    }
    constructor(uriOrMessage, code = files_1.FileSystemProviderErrorCode.Unknown, terminator) {
        var _b;
        super(URI.isUri(uriOrMessage) ? uriOrMessage.toString(true) : uriOrMessage);
        this.code = (_b = terminator === null || terminator === void 0 ? void 0 : terminator.name) !== null && _b !== void 0 ? _b : 'Unknown';
        // mark the error as file system provider error so that
        // we can extract the error code on the receiving side
        (0, files_1.markAsFileSystemProviderError)(this, code);
        // workaround when extending builtin objects and when compiling to ES5, see:
        // https://github.com/Microsoft/TypeScript-wiki/blob/master/Breaking-Changes.md#extending-built-ins-like-error-array-and-map-may-no-longer-work
        if (typeof Object.setPrototypeOf === 'function') {
            Object.setPrototypeOf(this, FileSystemError_1.prototype);
        }
        if (typeof Error.captureStackTrace === 'function' && typeof terminator === 'function') {
            // nice stack traces
            Error.captureStackTrace(this, terminator);
        }
    }
};
exports.FileSystemError = FileSystemError;
exports.FileSystemError = FileSystemError = FileSystemError_1 = tslib_1.__decorate([
    types_1.es5ClassCompat,
    tslib_1.__metadata("design:paramtypes", [Object, String, Function])
], FileSystemError);
// #endregion
var FileType;
(function (FileType) {
    FileType[FileType["Unknown"] = 0] = "Unknown";
    FileType[FileType["File"] = 1] = "File";
    FileType[FileType["Directory"] = 2] = "Directory";
    FileType[FileType["SymbolicLink"] = 64] = "SymbolicLink";
})(FileType || (exports.FileType = FileType = {}));
let ProgressOptions = class ProgressOptions {
    constructor(location, title, cancellable) {
        this.location = location;
    }
};
exports.ProgressOptions = ProgressOptions;
exports.ProgressOptions = ProgressOptions = tslib_1.__decorate([
    types_1.es5ClassCompat,
    tslib_1.__metadata("design:paramtypes", [Number, String, Boolean])
], ProgressOptions);
let Progress = class Progress {
    /**
     * Report a progress update.
     * @param value A progress item, like a message and/or an
     * report on how much work finished
     */
    report(value) {
    }
};
exports.Progress = Progress;
exports.Progress = Progress = tslib_1.__decorate([
    types_1.es5ClassCompat
], Progress);
var ProgressLocation;
(function (ProgressLocation) {
    /**
     * Show progress for the source control viewlet, as overlay for the icon and as progress bar
     * inside the viewlet (when visible). Neither supports cancellation nor discrete progress.
     */
    ProgressLocation[ProgressLocation["SourceControl"] = 1] = "SourceControl";
    /**
     * Show progress in the status bar of the editor. Neither supports cancellation nor discrete progress.
     */
    ProgressLocation[ProgressLocation["Window"] = 10] = "Window";
    /**
     * Show progress as notification with an optional cancel button. Supports to show infinite and discrete progress.
     */
    ProgressLocation[ProgressLocation["Notification"] = 15] = "Notification";
})(ProgressLocation || (exports.ProgressLocation = ProgressLocation = {}));
let ProcessExecution = class ProcessExecution {
    constructor(process, varg1, varg2) {
        if (typeof process !== 'string') {
            throw (0, errors_1.illegalArgument)('process');
        }
        this.executionProcess = process;
        if (varg1 !== undefined) {
            if (Array.isArray(varg1)) {
                this.arguments = varg1;
                this.executionOptions = varg2;
            }
            else {
                this.executionOptions = varg1;
            }
        }
        if (this.arguments === undefined) {
            this.arguments = [];
        }
    }
    get process() {
        return this.executionProcess;
    }
    set process(value) {
        if (typeof value !== 'string') {
            throw (0, errors_1.illegalArgument)('process');
        }
        this.executionProcess = value;
    }
    get args() {
        return this.arguments;
    }
    set args(value) {
        if (!Array.isArray(value)) {
            value = [];
        }
        this.arguments = value;
    }
    get options() {
        return this.executionOptions;
    }
    set options(value) {
        this.executionOptions = value;
    }
    static is(value) {
        const candidate = value;
        return candidate && !!candidate.process;
    }
};
exports.ProcessExecution = ProcessExecution;
exports.ProcessExecution = ProcessExecution = tslib_1.__decorate([
    types_1.es5ClassCompat,
    tslib_1.__metadata("design:paramtypes", [String, Object, Object])
], ProcessExecution);
var QuickPickItemKind;
(function (QuickPickItemKind) {
    QuickPickItemKind[QuickPickItemKind["Separator"] = -1] = "Separator";
    QuickPickItemKind[QuickPickItemKind["Default"] = 0] = "Default";
})(QuickPickItemKind || (exports.QuickPickItemKind = QuickPickItemKind = {}));
var ShellQuoting;
(function (ShellQuoting) {
    ShellQuoting[ShellQuoting["Escape"] = 1] = "Escape";
    ShellQuoting[ShellQuoting["Strong"] = 2] = "Strong";
    ShellQuoting[ShellQuoting["Weak"] = 3] = "Weak";
})(ShellQuoting || (exports.ShellQuoting = ShellQuoting = {}));
var TaskPanelKind;
(function (TaskPanelKind) {
    TaskPanelKind[TaskPanelKind["Shared"] = 1] = "Shared";
    TaskPanelKind[TaskPanelKind["Dedicated"] = 2] = "Dedicated";
    TaskPanelKind[TaskPanelKind["New"] = 3] = "New";
})(TaskPanelKind || (exports.TaskPanelKind = TaskPanelKind = {}));
var TaskRevealKind;
(function (TaskRevealKind) {
    TaskRevealKind[TaskRevealKind["Always"] = 1] = "Always";
    TaskRevealKind[TaskRevealKind["Silent"] = 2] = "Silent";
    TaskRevealKind[TaskRevealKind["Never"] = 3] = "Never";
})(TaskRevealKind || (exports.TaskRevealKind = TaskRevealKind = {}));
let ShellExecution = class ShellExecution {
    constructor(arg0, arg1, arg2) {
        if (Array.isArray(arg1) || typeof arg1 === 'string') {
            if (!arg0) {
                throw (0, errors_1.illegalArgument)('command can\'t be undefined or null');
            }
            if (typeof arg0 !== 'string' && typeof arg0.value !== 'string') {
                throw (0, errors_1.illegalArgument)('command');
            }
            this.shellCommand = arg0;
            this.arguments = arg1;
            this.shellOptions = arg2;
        }
        else {
            if (typeof arg0 !== 'string') {
                throw (0, errors_1.illegalArgument)('commandLine');
            }
            this.shellCommandLine = arg0;
            this.shellOptions = arg1;
        }
    }
    get commandLine() {
        return this.shellCommandLine;
    }
    set commandLine(value) {
        if (typeof value !== 'string') {
            throw (0, errors_1.illegalArgument)('commandLine');
        }
        this.shellCommandLine = value;
    }
    get command() {
        return this.shellCommand;
    }
    set command(value) {
        if (typeof value !== 'string' && typeof value.value !== 'string') {
            throw (0, errors_1.illegalArgument)('command');
        }
        this.shellCommand = value;
    }
    get args() {
        return this.arguments;
    }
    set args(value) {
        this.arguments = value || [];
    }
    get options() {
        return this.shellOptions;
    }
    set options(value) {
        this.shellOptions = value;
    }
    static is(value) {
        const candidate = value;
        return candidate && (!!candidate.commandLine || !!candidate.command);
    }
};
exports.ShellExecution = ShellExecution;
exports.ShellExecution = ShellExecution = tslib_1.__decorate([
    types_1.es5ClassCompat,
    tslib_1.__metadata("design:paramtypes", [Object, Object, Object])
], ShellExecution);
let CustomExecution = class CustomExecution {
    constructor(callback) {
        this._callback = callback;
    }
    set callback(value) {
        this._callback = value;
    }
    get callback() {
        return this._callback;
    }
    static is(value) {
        const candidate = value;
        return candidate && (!!candidate._callback);
    }
};
exports.CustomExecution = CustomExecution;
exports.CustomExecution = CustomExecution = tslib_1.__decorate([
    types_1.es5ClassCompat,
    tslib_1.__metadata("design:paramtypes", [Function])
], CustomExecution);
let TaskGroup = TaskGroup_1 = class TaskGroup {
    static from(value) {
        switch (value) {
            case 'clean':
                return TaskGroup_1.Clean;
            case 'build':
                return TaskGroup_1.Build;
            case 'rebuild':
                return TaskGroup_1.Rebuild;
            case 'test':
                return TaskGroup_1.Test;
            default:
                return undefined;
        }
    }
    constructor(id, label, isDefault) {
        this.id = id;
        this.isDefault = !!isDefault;
    }
};
exports.TaskGroup = TaskGroup;
TaskGroup.Clean = new TaskGroup_1('clean', 'Clean');
TaskGroup.Build = new TaskGroup_1('build', 'Build');
TaskGroup.Rebuild = new TaskGroup_1('rebuild', 'Rebuild');
TaskGroup.Test = new TaskGroup_1('test', 'Test');
exports.TaskGroup = TaskGroup = TaskGroup_1 = tslib_1.__decorate([
    types_1.es5ClassCompat,
    tslib_1.__metadata("design:paramtypes", [String, String, Object])
], TaskGroup);
var TaskScope;
(function (TaskScope) {
    TaskScope[TaskScope["Global"] = 1] = "Global";
    TaskScope[TaskScope["Workspace"] = 2] = "Workspace";
})(TaskScope || (exports.TaskScope = TaskScope = {}));
let Task = class Task {
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    constructor(...args) {
        let taskDefinition;
        let scope;
        let name;
        let source;
        let execution;
        let problemMatchers;
        if (typeof args[1] === 'string') {
            [
                taskDefinition,
                name,
                source,
                execution,
                problemMatchers,
            ] = args;
        }
        else {
            [
                taskDefinition,
                scope,
                name,
                source,
                execution,
                problemMatchers,
            ] = args;
        }
        this.definition = taskDefinition;
        this.scope = scope;
        this.name = name;
        this.source = source;
        this.execution = execution;
        if (typeof problemMatchers === 'string') {
            this.taskProblemMatchers = [problemMatchers];
            this.hasTaskProblemMatchers = true;
        }
        else if (Array.isArray(problemMatchers)) {
            this.taskProblemMatchers = problemMatchers;
            this.hasTaskProblemMatchers = true;
        }
        else {
            this.taskProblemMatchers = [];
            this.hasTaskProblemMatchers = false;
        }
        this.isTaskBackground = false;
        this.presentationOptions = Object.create(null);
        this.taskRunOptions = Object.create(null);
    }
    get definition() {
        return this.taskDefinition;
    }
    set definition(value) {
        if (value === undefined || value === null) {
            throw (0, errors_1.illegalArgument)('Kind can\'t be undefined or null');
        }
        this.taskDefinition = value;
    }
    get scope() {
        return this.taskScope;
    }
    set scope(value) {
        if (value === null) {
            value = undefined;
        }
        this.taskScope = value;
    }
    get name() {
        return this.taskName;
    }
    set name(value) {
        if (typeof value !== 'string') {
            throw (0, errors_1.illegalArgument)('name');
        }
        this.taskName = value;
    }
    get execution() {
        return this.taskExecution;
    }
    set execution(value) {
        if (value === null) {
            value = undefined;
        }
        this.taskExecution = value;
    }
    get problemMatchers() {
        return this.taskProblemMatchers;
    }
    set problemMatchers(value) {
        if (!Array.isArray(value)) {
            this.taskProblemMatchers = [];
            this.hasTaskProblemMatchers = false;
            return;
        }
        this.taskProblemMatchers = value;
        this.hasTaskProblemMatchers = true;
    }
    get hasProblemMatchers() {
        return this.hasTaskProblemMatchers;
    }
    get isBackground() {
        return this.isTaskBackground;
    }
    set isBackground(value) {
        if (value !== true && value !== false) {
            value = false;
        }
        this.isTaskBackground = value;
    }
    get source() {
        return this.taskSource;
    }
    set source(value) {
        if (typeof value !== 'string' || value.length === 0) {
            throw (0, errors_1.illegalArgument)('source must be a string of length > 0');
        }
        this.taskSource = value;
    }
    get group() {
        return this.taskGroup;
    }
    set group(value) {
        if (value === undefined || value === null) {
            this.taskGroup = undefined;
            return;
        }
        this.taskGroup = value;
    }
    get presentationOptions() {
        return this.taskPresentationOptions;
    }
    set presentationOptions(value) {
        if (value === null || value === undefined) {
            value = Object.create(null);
        }
        this.taskPresentationOptions = value;
    }
    get runOptions() {
        return this.taskRunOptions;
    }
    set runOptions(value) {
        if (value === null || value === undefined) {
            value = Object.create(null);
        }
        this.taskRunOptions = value;
    }
};
exports.Task = Task;
exports.Task = Task = tslib_1.__decorate([
    types_1.es5ClassCompat,
    tslib_1.__metadata("design:paramtypes", [Object])
], Task);
let Task2 = class Task2 extends Task {
};
exports.Task2 = Task2;
exports.Task2 = Task2 = tslib_1.__decorate([
    types_1.es5ClassCompat
], Task2);
let DebugAdapterExecutable = class DebugAdapterExecutable {
    /**
     * Creates a description for a debug adapter based on an executable program.
     *
     * @param command The command or executable path that implements the debug adapter.
     * @param args Optional arguments to be passed to the command or executable.
     * @param options Optional options to be used when starting the command or executable.
     */
    constructor(command, args, options) {
        this.command = command;
        this.args = args;
        this.options = options;
    }
};
exports.DebugAdapterExecutable = DebugAdapterExecutable;
exports.DebugAdapterExecutable = DebugAdapterExecutable = tslib_1.__decorate([
    types_1.es5ClassCompat,
    tslib_1.__metadata("design:paramtypes", [String, Array, Object])
], DebugAdapterExecutable);
(function (DebugAdapterExecutable) {
    function is(adapter) {
        return !!adapter && 'command' in adapter;
    }
    DebugAdapterExecutable.is = is;
})(DebugAdapterExecutable || (exports.DebugAdapterExecutable = DebugAdapterExecutable = {}));
/**
 * Represents a debug adapter running as a socket based server.
 */
let DebugAdapterServer = class DebugAdapterServer {
    /**
     * Create a description for a debug adapter running as a socket based server.
     */
    constructor(port, host) {
        this.port = port;
        this.host = host;
    }
};
exports.DebugAdapterServer = DebugAdapterServer;
exports.DebugAdapterServer = DebugAdapterServer = tslib_1.__decorate([
    types_1.es5ClassCompat,
    tslib_1.__metadata("design:paramtypes", [Number, String])
], DebugAdapterServer);
(function (DebugAdapterServer) {
    function is(adapter) {
        return !!adapter && 'port' in adapter;
    }
    DebugAdapterServer.is = is;
})(DebugAdapterServer || (exports.DebugAdapterServer = DebugAdapterServer = {}));
/**
 * Represents a debug adapter running as a Named Pipe (on Windows)/UNIX Domain Socket (on non-Windows) based server.
 */
let DebugAdapterNamedPipeServer = class DebugAdapterNamedPipeServer {
    /**
     * Create a description for a debug adapter running as a Named Pipe (on Windows)/UNIX Domain Socket (on non-Windows) based server.
     */
    constructor(path) {
        this.path = path;
    }
};
exports.DebugAdapterNamedPipeServer = DebugAdapterNamedPipeServer;
exports.DebugAdapterNamedPipeServer = DebugAdapterNamedPipeServer = tslib_1.__decorate([
    types_1.es5ClassCompat,
    tslib_1.__metadata("design:paramtypes", [String])
], DebugAdapterNamedPipeServer);
(function (DebugAdapterNamedPipeServer) {
    function is(adapter) {
        return !!adapter && 'path' in adapter;
    }
    DebugAdapterNamedPipeServer.is = is;
})(DebugAdapterNamedPipeServer || (exports.DebugAdapterNamedPipeServer = DebugAdapterNamedPipeServer = {}));
/**
 * A debug adapter descriptor for an inline implementation.
 */
let DebugAdapterInlineImplementation = class DebugAdapterInlineImplementation {
    /**
     * Create a descriptor for an inline implementation of a debug adapter.
     */
    constructor(impl) {
        this.implementation = impl;
    }
};
exports.DebugAdapterInlineImplementation = DebugAdapterInlineImplementation;
exports.DebugAdapterInlineImplementation = DebugAdapterInlineImplementation = tslib_1.__decorate([
    types_1.es5ClassCompat,
    tslib_1.__metadata("design:paramtypes", [Object])
], DebugAdapterInlineImplementation);
(function (DebugAdapterInlineImplementation) {
    function is(adapter) {
        return !!adapter && 'implementation' in adapter;
    }
    DebugAdapterInlineImplementation.is = is;
})(DebugAdapterInlineImplementation || (exports.DebugAdapterInlineImplementation = DebugAdapterInlineImplementation = {}));
var LogLevel;
(function (LogLevel) {
    LogLevel[LogLevel["Off"] = 0] = "Off";
    LogLevel[LogLevel["Trace"] = 1] = "Trace";
    LogLevel[LogLevel["Debug"] = 2] = "Debug";
    LogLevel[LogLevel["Info"] = 3] = "Info";
    LogLevel[LogLevel["Warning"] = 4] = "Warning";
    LogLevel[LogLevel["Error"] = 5] = "Error";
})(LogLevel || (exports.LogLevel = LogLevel = {}));
/**
 * The base class of all breakpoint types.
 */
let Breakpoint = class Breakpoint {
    constructor(enabled, condition, hitCondition, logMessage, id) {
        this.enabled = enabled || false;
        this.condition = condition;
        this.hitCondition = hitCondition;
        this.logMessage = logMessage;
        this._id = id;
    }
    /**
     * The unique ID of the breakpoint.
     */
    get id() {
        if (!this._id) {
            this._id = coreutils_1.UUID.uuid4();
        }
        return this._id;
    }
};
exports.Breakpoint = Breakpoint;
exports.Breakpoint = Breakpoint = tslib_1.__decorate([
    types_1.es5ClassCompat,
    tslib_1.__metadata("design:paramtypes", [Boolean, String, String, String, String])
], Breakpoint);
/**
 * A breakpoint specified by a source location.
 */
let SourceBreakpoint = class SourceBreakpoint extends Breakpoint {
    /**
     * Create a new breakpoint for a source location.
     */
    constructor(location, enabled, condition, hitCondition, logMessage, id) {
        super(enabled, condition, hitCondition, logMessage, id);
        this.location = location;
    }
};
exports.SourceBreakpoint = SourceBreakpoint;
exports.SourceBreakpoint = SourceBreakpoint = tslib_1.__decorate([
    types_1.es5ClassCompat,
    tslib_1.__metadata("design:paramtypes", [Location, Boolean, String, String, String, String])
], SourceBreakpoint);
/**
 * A breakpoint specified by a function name.
 */
let FunctionBreakpoint = class FunctionBreakpoint extends Breakpoint {
    /**
     * Create a new function breakpoint.
     */
    constructor(functionName, enabled, condition, hitCondition, logMessage, id) {
        super(enabled, condition, hitCondition, logMessage, id);
        this.functionName = functionName;
    }
};
exports.FunctionBreakpoint = FunctionBreakpoint;
exports.FunctionBreakpoint = FunctionBreakpoint = tslib_1.__decorate([
    types_1.es5ClassCompat,
    tslib_1.__metadata("design:paramtypes", [String, Boolean, String, String, String, String])
], FunctionBreakpoint);
class DebugThread {
    constructor(session, threadId) {
        this.session = session;
        this.threadId = threadId;
    }
}
exports.DebugThread = DebugThread;
class DebugStackFrame {
    constructor(session, threadId, frameId) {
        this.session = session;
        this.threadId = threadId;
        this.frameId = frameId;
    }
}
exports.DebugStackFrame = DebugStackFrame;
let Color = class Color {
    constructor(red, green, blue, alpha) {
        this.red = red;
        this.green = green;
        this.blue = blue;
        this.alpha = alpha;
    }
};
exports.Color = Color;
exports.Color = Color = tslib_1.__decorate([
    types_1.es5ClassCompat,
    tslib_1.__metadata("design:paramtypes", [Number, Number, Number, Number])
], Color);
let ColorInformation = class ColorInformation {
    constructor(range, color) {
        if (color && !(color instanceof Color)) {
            throw (0, errors_1.illegalArgument)('color');
        }
        if (!Range.isRange(range)) {
            throw (0, errors_1.illegalArgument)('range');
        }
        this.range = range;
        this.color = color;
    }
};
exports.ColorInformation = ColorInformation;
exports.ColorInformation = ColorInformation = tslib_1.__decorate([
    types_1.es5ClassCompat,
    tslib_1.__metadata("design:paramtypes", [Range, Color])
], ColorInformation);
let ColorPresentation = class ColorPresentation {
    constructor(label) {
        if (!label || typeof label !== 'string') {
            throw (0, errors_1.illegalArgument)('label');
        }
        this.label = label;
    }
};
exports.ColorPresentation = ColorPresentation;
exports.ColorPresentation = ColorPresentation = tslib_1.__decorate([
    types_1.es5ClassCompat,
    tslib_1.__metadata("design:paramtypes", [String])
], ColorPresentation);
var ColorFormat;
(function (ColorFormat) {
    ColorFormat[ColorFormat["RGB"] = 0] = "RGB";
    ColorFormat[ColorFormat["HEX"] = 1] = "HEX";
    ColorFormat[ColorFormat["HSL"] = 2] = "HSL";
})(ColorFormat || (exports.ColorFormat = ColorFormat = {}));
let InlayHintLabelPart = class InlayHintLabelPart {
    constructor(value) {
        this.value = value;
    }
};
exports.InlayHintLabelPart = InlayHintLabelPart;
exports.InlayHintLabelPart = InlayHintLabelPart = tslib_1.__decorate([
    types_1.es5ClassCompat,
    tslib_1.__metadata("design:paramtypes", [String])
], InlayHintLabelPart);
let InlayHint = class InlayHint {
    constructor(position, label, kind) {
        this.position = position;
        this.label = label;
        this.kind = kind;
    }
};
exports.InlayHint = InlayHint;
exports.InlayHint = InlayHint = tslib_1.__decorate([
    types_1.es5ClassCompat,
    tslib_1.__metadata("design:paramtypes", [Function, Object, Number])
], InlayHint);
var InlayHintKind;
(function (InlayHintKind) {
    InlayHintKind[InlayHintKind["Type"] = 1] = "Type";
    InlayHintKind[InlayHintKind["Parameter"] = 2] = "Parameter";
})(InlayHintKind || (exports.InlayHintKind = InlayHintKind = {}));
let FoldingRange = class FoldingRange {
    constructor(start, end, kind) {
        this.start = start;
        this.end = end;
        this.kind = kind;
    }
};
exports.FoldingRange = FoldingRange;
exports.FoldingRange = FoldingRange = tslib_1.__decorate([
    types_1.es5ClassCompat,
    tslib_1.__metadata("design:paramtypes", [Number, Number, Number])
], FoldingRange);
var FoldingRangeKind;
(function (FoldingRangeKind) {
    FoldingRangeKind[FoldingRangeKind["Comment"] = 1] = "Comment";
    FoldingRangeKind[FoldingRangeKind["Imports"] = 2] = "Imports";
    FoldingRangeKind[FoldingRangeKind["Region"] = 3] = "Region";
})(FoldingRangeKind || (exports.FoldingRangeKind = FoldingRangeKind = {}));
let SelectionRange = class SelectionRange {
    constructor(range, parent) {
        this.range = range;
        this.parent = parent;
        if (parent && !parent.range.contains(this.range)) {
            throw new Error('Invalid argument: parent must contain this range');
        }
    }
};
exports.SelectionRange = SelectionRange;
exports.SelectionRange = SelectionRange = tslib_1.__decorate([
    types_1.es5ClassCompat,
    tslib_1.__metadata("design:paramtypes", [Range, SelectionRange])
], SelectionRange);
/**
 * Enumeration of the supported operating systems.
 */
var OperatingSystem;
(function (OperatingSystem) {
    OperatingSystem["Windows"] = "Windows";
    OperatingSystem["Linux"] = "Linux";
    OperatingSystem["OSX"] = "OSX";
})(OperatingSystem || (exports.OperatingSystem = OperatingSystem = {}));
/** The areas of the application shell where webview panel can reside. */
var WebviewPanelTargetArea;
(function (WebviewPanelTargetArea) {
    WebviewPanelTargetArea["Main"] = "main";
    WebviewPanelTargetArea["Left"] = "left";
    WebviewPanelTargetArea["Right"] = "right";
    WebviewPanelTargetArea["Bottom"] = "bottom";
})(WebviewPanelTargetArea || (exports.WebviewPanelTargetArea = WebviewPanelTargetArea = {}));
/**
 * Possible kinds of UI that can use extensions.
 */
var UIKind;
(function (UIKind) {
    /**
     * Extensions are accessed from a desktop application.
     */
    UIKind[UIKind["Desktop"] = 1] = "Desktop";
    /**
     * Extensions are accessed from a web browser.
     */
    UIKind[UIKind["Web"] = 2] = "Web";
})(UIKind || (exports.UIKind = UIKind = {}));
let CallHierarchyItem = CallHierarchyItem_1 = class CallHierarchyItem {
    constructor(kind, name, detail, uri, range, selectionRange) {
        this.kind = kind;
        this.name = name;
        this.detail = detail;
        this.uri = uri;
        this.range = range;
        this.selectionRange = selectionRange;
    }
    static isCallHierarchyItem(thing) {
        if (thing instanceof CallHierarchyItem_1) {
            return true;
        }
        if (!thing) {
            return false;
        }
        return typeof thing.kind === 'number' &&
            typeof thing.name === 'string' &&
            URI.isUri(thing.uri) &&
            Range.isRange(thing.range) &&
            Range.isRange(thing.selectionRange);
    }
};
exports.CallHierarchyItem = CallHierarchyItem;
exports.CallHierarchyItem = CallHierarchyItem = CallHierarchyItem_1 = tslib_1.__decorate([
    types_1.es5ClassCompat,
    tslib_1.__metadata("design:paramtypes", [Number, String, String, URI, Range, Range])
], CallHierarchyItem);
let CallHierarchyIncomingCall = class CallHierarchyIncomingCall {
    constructor(item, fromRanges) {
        this.fromRanges = fromRanges;
        this.from = item;
    }
};
exports.CallHierarchyIncomingCall = CallHierarchyIncomingCall;
exports.CallHierarchyIncomingCall = CallHierarchyIncomingCall = tslib_1.__decorate([
    types_1.es5ClassCompat,
    tslib_1.__metadata("design:paramtypes", [CallHierarchyItem, Array])
], CallHierarchyIncomingCall);
let CallHierarchyOutgoingCall = class CallHierarchyOutgoingCall {
    constructor(item, fromRanges) {
        this.fromRanges = fromRanges;
        this.to = item;
    }
};
exports.CallHierarchyOutgoingCall = CallHierarchyOutgoingCall;
exports.CallHierarchyOutgoingCall = CallHierarchyOutgoingCall = tslib_1.__decorate([
    types_1.es5ClassCompat,
    tslib_1.__metadata("design:paramtypes", [CallHierarchyItem, Array])
], CallHierarchyOutgoingCall);
let TypeHierarchyItem = TypeHierarchyItem_1 = class TypeHierarchyItem {
    constructor(kind, name, detail, uri, range, selectionRange) {
        this.kind = kind;
        this.name = name;
        this.detail = detail;
        this.uri = uri;
        this.range = range;
        this.selectionRange = selectionRange;
    }
    static isTypeHierarchyItem(thing) {
        if (thing instanceof TypeHierarchyItem_1) {
            return true;
        }
        if (!thing) {
            return false;
        }
        return typeof thing.kind === 'number' &&
            typeof thing.name === 'string' &&
            URI.isUri(thing.uri) &&
            Range.isRange(thing.range) &&
            Range.isRange(thing.selectionRange);
    }
};
exports.TypeHierarchyItem = TypeHierarchyItem;
exports.TypeHierarchyItem = TypeHierarchyItem = TypeHierarchyItem_1 = tslib_1.__decorate([
    types_1.es5ClassCompat,
    tslib_1.__metadata("design:paramtypes", [Number, String, String, URI, Range, Range])
], TypeHierarchyItem);
var LanguageStatusSeverity;
(function (LanguageStatusSeverity) {
    LanguageStatusSeverity[LanguageStatusSeverity["Information"] = 0] = "Information";
    LanguageStatusSeverity[LanguageStatusSeverity["Warning"] = 1] = "Warning";
    LanguageStatusSeverity[LanguageStatusSeverity["Error"] = 2] = "Error";
})(LanguageStatusSeverity || (exports.LanguageStatusSeverity = LanguageStatusSeverity = {}));
let LinkedEditingRanges = class LinkedEditingRanges {
    constructor(ranges, wordPattern) {
        this.ranges = ranges;
        this.wordPattern = wordPattern;
    }
};
exports.LinkedEditingRanges = LinkedEditingRanges;
exports.LinkedEditingRanges = LinkedEditingRanges = tslib_1.__decorate([
    types_1.es5ClassCompat,
    tslib_1.__metadata("design:paramtypes", [Array, RegExp])
], LinkedEditingRanges);
// Copied from https://github.com/microsoft/vscode/blob/1.72.2/src/vs/workbench/api/common/extHostTypes.ts
var TestResultState;
(function (TestResultState) {
    TestResultState[TestResultState["Queued"] = 1] = "Queued";
    TestResultState[TestResultState["Running"] = 2] = "Running";
    TestResultState[TestResultState["Passed"] = 3] = "Passed";
    TestResultState[TestResultState["Failed"] = 4] = "Failed";
    TestResultState[TestResultState["Skipped"] = 5] = "Skipped";
    TestResultState[TestResultState["Errored"] = 6] = "Errored";
})(TestResultState || (exports.TestResultState = TestResultState = {}));
var TestRunProfileKind;
(function (TestRunProfileKind) {
    TestRunProfileKind[TestRunProfileKind["Run"] = 1] = "Run";
    TestRunProfileKind[TestRunProfileKind["Debug"] = 2] = "Debug";
    TestRunProfileKind[TestRunProfileKind["Coverage"] = 3] = "Coverage";
})(TestRunProfileKind || (exports.TestRunProfileKind = TestRunProfileKind = {}));
let TestTag = class TestTag {
    constructor(id) {
        this.id = id;
    }
};
exports.TestTag = TestTag;
exports.TestTag = TestTag = tslib_1.__decorate([
    types_1.es5ClassCompat,
    tslib_1.__metadata("design:paramtypes", [String])
], TestTag);
let nextTestRunId = 0;
let TestRunRequest = class TestRunRequest {
    constructor(include = undefined, exclude = undefined, profile = undefined, continuous = undefined, preserveFocus = true) {
        this.include = include;
        this.exclude = exclude;
        this.profile = profile;
        this.continuous = continuous;
        this.preserveFocus = preserveFocus;
        this.testRunId = nextTestRunId++;
    }
};
exports.TestRunRequest = TestRunRequest;
exports.TestRunRequest = TestRunRequest = tslib_1.__decorate([
    types_1.es5ClassCompat,
    tslib_1.__metadata("design:paramtypes", [Object, Object, Object, Object, Boolean])
], TestRunRequest);
let TestMessage = TestMessage_1 = class TestMessage {
    static diff(message, expected, actual) {
        const msg = new TestMessage_1(message);
        msg.expectedOutput = expected;
        msg.actualOutput = actual;
        return msg;
    }
    constructor(message) {
        this.message = message;
    }
};
exports.TestMessage = TestMessage;
exports.TestMessage = TestMessage = TestMessage_1 = tslib_1.__decorate([
    types_1.es5ClassCompat,
    tslib_1.__metadata("design:paramtypes", [Object])
], TestMessage);
let TestCoverageCount = class TestCoverageCount {
    constructor(covered, total) {
        this.covered = covered;
        this.total = total;
    }
};
exports.TestCoverageCount = TestCoverageCount;
exports.TestCoverageCount = TestCoverageCount = tslib_1.__decorate([
    types_1.es5ClassCompat,
    tslib_1.__metadata("design:paramtypes", [Number, Number])
], TestCoverageCount);
let FileCoverage = FileCoverage_1 = class FileCoverage {
    static fromDetails(uri, details) {
        const statements = new TestCoverageCount(0, 0);
        const branches = new TestCoverageCount(0, 0);
        const decl = new TestCoverageCount(0, 0);
        for (const detail of details) {
            if (detail instanceof StatementCoverage) {
                statements.total += 1;
                statements.covered += detail.executed ? 1 : 0;
                for (const branch of detail.branches) {
                    branches.total += 1;
                    branches.covered += branch.executed ? 1 : 0;
                }
            }
            else {
                decl.total += 1;
                decl.covered += detail.executed ? 1 : 0;
            }
        }
        const coverage = new FileCoverage_1(uri, statements, branches.total > 0 ? branches : undefined, decl.total > 0 ? decl : undefined);
        coverage.detailedCoverage = details;
        return coverage;
    }
    constructor(uri, statementCoverage, branchCoverage, declarationCoverage) {
        this.uri = uri;
        this.statementCoverage = statementCoverage;
        this.branchCoverage = branchCoverage;
        this.declarationCoverage = declarationCoverage;
    }
};
exports.FileCoverage = FileCoverage;
exports.FileCoverage = FileCoverage = FileCoverage_1 = tslib_1.__decorate([
    types_1.es5ClassCompat,
    tslib_1.__metadata("design:paramtypes", [Function, TestCoverageCount,
        TestCoverageCount,
        TestCoverageCount])
], FileCoverage);
let StatementCoverage = class StatementCoverage {
    constructor(executed, location, branches = []) {
        this.executed = executed;
        this.location = location;
        this.branches = branches;
    }
};
exports.StatementCoverage = StatementCoverage;
exports.StatementCoverage = StatementCoverage = tslib_1.__decorate([
    types_1.es5ClassCompat,
    tslib_1.__metadata("design:paramtypes", [Object, Object, Array])
], StatementCoverage);
class BranchCoverage {
    constructor(executed, location, label) {
        this.executed = executed;
        this.location = location;
        this.label = label;
    }
}
exports.BranchCoverage = BranchCoverage;
let DeclarationCoverage = class DeclarationCoverage {
    constructor(name, executed, location) {
        this.name = name;
        this.executed = executed;
        this.location = location;
    }
};
exports.DeclarationCoverage = DeclarationCoverage;
exports.DeclarationCoverage = DeclarationCoverage = tslib_1.__decorate([
    types_1.es5ClassCompat,
    tslib_1.__metadata("design:paramtypes", [String, Object, Object])
], DeclarationCoverage);
let TimelineItem = class TimelineItem {
    constructor(label, timestamp) {
        this.label = label;
        this.timestamp = timestamp;
    }
};
exports.TimelineItem = TimelineItem;
exports.TimelineItem = TimelineItem = tslib_1.__decorate([
    types_1.es5ClassCompat,
    tslib_1.__metadata("design:paramtypes", [String, Number])
], TimelineItem);
// #region Semantic Coloring
let SemanticTokensLegend = class SemanticTokensLegend {
    constructor(tokenTypes, tokenModifiers = []) {
        this.tokenTypes = tokenTypes;
        this.tokenModifiers = tokenModifiers;
    }
};
exports.SemanticTokensLegend = SemanticTokensLegend;
exports.SemanticTokensLegend = SemanticTokensLegend = tslib_1.__decorate([
    types_1.es5ClassCompat,
    tslib_1.__metadata("design:paramtypes", [Array, Array])
], SemanticTokensLegend);
function isStrArrayOrUndefined(arg) {
    return typeof arg === 'undefined' || (0, common_1.isStringArray)(arg);
}
let SemanticTokensBuilder = SemanticTokensBuilder_1 = class SemanticTokensBuilder {
    constructor(legend) {
        this._prevLine = 0;
        this._prevChar = 0;
        this._dataIsSortedAndDeltaEncoded = true;
        this._data = [];
        this._dataLen = 0;
        this._tokenTypeStrToInt = new Map();
        this._tokenModifierStrToInt = new Map();
        this._hasLegend = false;
        if (legend) {
            this._hasLegend = true;
            for (let i = 0, len = legend.tokenTypes.length; i < len; i++) {
                this._tokenTypeStrToInt.set(legend.tokenTypes[i], i);
            }
            for (let i = 0, len = legend.tokenModifiers.length; i < len; i++) {
                this._tokenModifierStrToInt.set(legend.tokenModifiers[i], i);
            }
        }
    }
    push(arg0, arg1, arg2, arg3, arg4) {
        if (typeof arg0 === 'number' && typeof arg1 === 'number' && typeof arg2 === 'number' && typeof arg3 === 'number' &&
            (typeof arg4 === 'number' || typeof arg4 === 'undefined')) {
            if (typeof arg4 === 'undefined') {
                arg4 = 0;
            }
            // 1st overload
            return this._pushEncoded(arg0, arg1, arg2, arg3, arg4);
        }
        if (Range.isRange(arg0) && typeof arg1 === 'string' && isStrArrayOrUndefined(arg2)) {
            // 2nd overload
            return this._push(arg0, arg1, arg2);
        }
        throw (0, errors_1.illegalArgument)();
    }
    _push(range, tokenType, tokenModifiers) {
        if (!this._hasLegend) {
            throw new Error('Legend must be provided in constructor');
        }
        if (range.start.line !== range.end.line) {
            throw new Error('`range` cannot span multiple lines');
        }
        if (!this._tokenTypeStrToInt.has(tokenType)) {
            throw new Error('`tokenType` is not in the provided legend');
        }
        const line = range.start.line;
        const char = range.start.character;
        const length = range.end.character - range.start.character;
        const nTokenType = this._tokenTypeStrToInt.get(tokenType);
        let nTokenModifiers = 0;
        if (tokenModifiers) {
            for (const tokenModifier of tokenModifiers) {
                if (!this._tokenModifierStrToInt.has(tokenModifier)) {
                    throw new Error('`tokenModifier` is not in the provided legend');
                }
                const nTokenModifier = this._tokenModifierStrToInt.get(tokenModifier);
                nTokenModifiers |= (1 << nTokenModifier) >>> 0;
            }
        }
        this._pushEncoded(line, char, length, nTokenType, nTokenModifiers);
    }
    _pushEncoded(line, char, length, tokenType, tokenModifiers) {
        if (this._dataIsSortedAndDeltaEncoded && (line < this._prevLine || (line === this._prevLine && char < this._prevChar))) {
            // push calls were ordered and are no longer ordered
            this._dataIsSortedAndDeltaEncoded = false;
            // Remove delta encoding from data
            const tokenCount = (this._data.length / 5) | 0;
            let prevLine = 0;
            let prevChar = 0;
            for (let i = 0; i < tokenCount; i++) {
                // eslint-disable-next-line @typescript-eslint/no-shadow
                let line = this._data[5 * i];
                // eslint-disable-next-line @typescript-eslint/no-shadow
                let char = this._data[5 * i + 1];
                if (line === 0) {
                    // on the same line as previous token
                    line = prevLine;
                    char += prevChar;
                }
                else {
                    // on a different line than previous token
                    line += prevLine;
                }
                this._data[5 * i] = line;
                this._data[5 * i + 1] = char;
                prevLine = line;
                prevChar = char;
            }
        }
        let pushLine = line;
        let pushChar = char;
        if (this._dataIsSortedAndDeltaEncoded && this._dataLen > 0) {
            pushLine -= this._prevLine;
            if (pushLine === 0) {
                pushChar -= this._prevChar;
            }
        }
        this._data[this._dataLen++] = pushLine;
        this._data[this._dataLen++] = pushChar;
        this._data[this._dataLen++] = length;
        this._data[this._dataLen++] = tokenType;
        this._data[this._dataLen++] = tokenModifiers;
        this._prevLine = line;
        this._prevChar = char;
    }
    static _sortAndDeltaEncode(data) {
        const pos = [];
        const tokenCount = (data.length / 5) | 0;
        for (let i = 0; i < tokenCount; i++) {
            pos[i] = i;
        }
        pos.sort((a, b) => {
            const aLine = data[5 * a];
            const bLine = data[5 * b];
            if (aLine === bLine) {
                const aChar = data[5 * a + 1];
                const bChar = data[5 * b + 1];
                return aChar - bChar;
            }
            return aLine - bLine;
        });
        const result = new Uint32Array(data.length);
        let prevLine = 0;
        let prevChar = 0;
        for (let i = 0; i < tokenCount; i++) {
            const srcOffset = 5 * pos[i];
            const line = data[srcOffset + 0];
            const char = data[srcOffset + 1];
            const length = data[srcOffset + 2];
            const tokenType = data[srcOffset + 3];
            const tokenModifiers = data[srcOffset + 4];
            const pushLine = line - prevLine;
            const pushChar = (pushLine === 0 ? char - prevChar : char);
            const dstOffset = 5 * i;
            result[dstOffset + 0] = pushLine;
            result[dstOffset + 1] = pushChar;
            result[dstOffset + 2] = length;
            result[dstOffset + 3] = tokenType;
            result[dstOffset + 4] = tokenModifiers;
            prevLine = line;
            prevChar = char;
        }
        return result;
    }
    build(resultId) {
        if (!this._dataIsSortedAndDeltaEncoded) {
            return new SemanticTokens(SemanticTokensBuilder_1._sortAndDeltaEncode(this._data), resultId);
        }
        return new SemanticTokens(new Uint32Array(this._data), resultId);
    }
};
exports.SemanticTokensBuilder = SemanticTokensBuilder;
exports.SemanticTokensBuilder = SemanticTokensBuilder = SemanticTokensBuilder_1 = tslib_1.__decorate([
    types_1.es5ClassCompat,
    tslib_1.__metadata("design:paramtypes", [SemanticTokensLegend])
], SemanticTokensBuilder);
let SemanticTokens = class SemanticTokens {
    constructor(data, resultId) {
        this.resultId = resultId;
        this.data = data;
    }
};
exports.SemanticTokens = SemanticTokens;
exports.SemanticTokens = SemanticTokens = tslib_1.__decorate([
    types_1.es5ClassCompat,
    tslib_1.__metadata("design:paramtypes", [Uint32Array, String])
], SemanticTokens);
let SemanticTokensEdit = class SemanticTokensEdit {
    constructor(start, deleteCount, data) {
        this.start = start;
        this.deleteCount = deleteCount;
        this.data = data;
    }
};
exports.SemanticTokensEdit = SemanticTokensEdit;
exports.SemanticTokensEdit = SemanticTokensEdit = tslib_1.__decorate([
    types_1.es5ClassCompat,
    tslib_1.__metadata("design:paramtypes", [Number, Number, Uint32Array])
], SemanticTokensEdit);
let SemanticTokensEdits = class SemanticTokensEdits {
    constructor(edits, resultId) {
        this.resultId = resultId;
        this.edits = edits;
    }
};
exports.SemanticTokensEdits = SemanticTokensEdits;
exports.SemanticTokensEdits = SemanticTokensEdits = tslib_1.__decorate([
    types_1.es5ClassCompat,
    tslib_1.__metadata("design:paramtypes", [Array, String])
], SemanticTokensEdits);
var InputBoxValidationSeverity;
(function (InputBoxValidationSeverity) {
    InputBoxValidationSeverity[InputBoxValidationSeverity["Info"] = 1] = "Info";
    InputBoxValidationSeverity[InputBoxValidationSeverity["Warning"] = 2] = "Warning";
    InputBoxValidationSeverity[InputBoxValidationSeverity["Error"] = 3] = "Error";
})(InputBoxValidationSeverity || (exports.InputBoxValidationSeverity = InputBoxValidationSeverity = {}));
// #endregion
// #region Tab Inputs
class TextTabInput {
    constructor(uri) {
        this.uri = uri;
    }
}
exports.TextTabInput = TextTabInput;
class TextDiffTabInput {
    constructor(original, modified) {
        this.original = original;
        this.modified = modified;
    }
}
exports.TextDiffTabInput = TextDiffTabInput;
class TextMergeTabInput {
    constructor(base, input1, input2, result) {
        this.base = base;
        this.input1 = input1;
        this.input2 = input2;
        this.result = result;
    }
}
exports.TextMergeTabInput = TextMergeTabInput;
class CustomEditorTabInput {
    constructor(uri, viewType) {
        this.uri = uri;
        this.viewType = viewType;
    }
}
exports.CustomEditorTabInput = CustomEditorTabInput;
class WebviewEditorTabInput {
    constructor(viewType) {
        this.viewType = viewType;
    }
}
exports.WebviewEditorTabInput = WebviewEditorTabInput;
class TelemetryTrustedValue {
    constructor(value) {
        this.value = value;
    }
}
exports.TelemetryTrustedValue = TelemetryTrustedValue;
class TelemetryLogger {
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    logUsage(eventName, data) { }
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    logError(eventNameOrError, data) { }
    dispose() { }
    constructor(sender, options) {
        this.sender = sender;
        this.options = options;
    }
}
exports.TelemetryLogger = TelemetryLogger;
class NotebookEditorTabInput {
    constructor(uri, notebookType) {
        this.uri = uri;
        this.notebookType = notebookType;
    }
}
exports.NotebookEditorTabInput = NotebookEditorTabInput;
class NotebookDiffEditorTabInput {
    constructor(original, modified, notebookType) {
        this.original = original;
        this.modified = modified;
        this.notebookType = notebookType;
    }
}
exports.NotebookDiffEditorTabInput = NotebookDiffEditorTabInput;
class TerminalEditorTabInput {
    constructor() { }
}
exports.TerminalEditorTabInput = TerminalEditorTabInput;
class InteractiveWindowInput {
    constructor(uri, inputBoxUri) {
        this.uri = uri;
        this.inputBoxUri = inputBoxUri;
    }
}
exports.InteractiveWindowInput = InteractiveWindowInput;
// #endregion
// #region DocumentPaste
class DocumentPasteEditKind {
    constructor(value) {
        this.value = value;
    }
    /** @stubbed */
    append(...parts) {
        return CodeActionKind.Empty;
    }
    ;
    /** @stubbed */
    intersects(other) {
        return false;
    }
    /** @stubbed */
    contains(other) {
        return false;
    }
}
exports.DocumentPasteEditKind = DocumentPasteEditKind;
DocumentPasteEditKind.Empty = new DocumentPasteEditKind('');
let DocumentPasteEdit = class DocumentPasteEdit {
    constructor(insertText, title, kind) {
        this.insertText = insertText;
        this.title = title;
        this.kind = kind;
    }
};
exports.DocumentPasteEdit = DocumentPasteEdit;
exports.DocumentPasteEdit = DocumentPasteEdit = tslib_1.__decorate([
    types_1.es5ClassCompat,
    tslib_1.__metadata("design:paramtypes", [Object, String, DocumentDropOrPasteEditKind])
], DocumentPasteEdit);
/**
 * The reason why paste edits were requested.
 */
var DocumentPasteTriggerKind;
(function (DocumentPasteTriggerKind) {
    /**
     * Pasting was requested as part of a normal paste operation.
     */
    DocumentPasteTriggerKind[DocumentPasteTriggerKind["Automatic"] = 0] = "Automatic";
    /**
     * Pasting was requested by the user with the `paste as` command.
     */
    DocumentPasteTriggerKind[DocumentPasteTriggerKind["PasteAs"] = 1] = "PasteAs";
})(DocumentPasteTriggerKind || (exports.DocumentPasteTriggerKind = DocumentPasteTriggerKind = {}));
// #endregion
// #region DocumentPaste
var EditSessionIdentityMatch;
(function (EditSessionIdentityMatch) {
    EditSessionIdentityMatch[EditSessionIdentityMatch["Complete"] = 100] = "Complete";
    EditSessionIdentityMatch[EditSessionIdentityMatch["Partial"] = 50] = "Partial";
    EditSessionIdentityMatch[EditSessionIdentityMatch["None"] = 0] = "None";
})(EditSessionIdentityMatch || (exports.EditSessionIdentityMatch = EditSessionIdentityMatch = {}));
// #endregion
// #region terminalQuickFixProvider
class TerminalQuickFixTerminalCommand {
    /**
     * @stubbed
     */
    constructor(terminalCommand, shouldExecute) { }
}
exports.TerminalQuickFixTerminalCommand = TerminalQuickFixTerminalCommand;
class TerminalQuickFixOpener {
    /**
     * @stubbed
     */
    constructor(uri) { }
}
exports.TerminalQuickFixOpener = TerminalQuickFixOpener;
// #region Chat
class ChatRequestTurn {
    constructor(prompt, command, references, participant) {
        this.prompt = prompt;
        this.command = command;
        this.participant = participant;
        this.references = references;
    }
    ;
}
exports.ChatRequestTurn = ChatRequestTurn;
class ChatResponseTurn {
    constructor(response, result, participant) {
        this.response = response;
        this.result = result;
        this.participant = participant;
    }
}
exports.ChatResponseTurn = ChatResponseTurn;
class ChatResponseAnchorPart {
    constructor(value, title) { }
}
exports.ChatResponseAnchorPart = ChatResponseAnchorPart;
class ChatResponseProgressPart {
    constructor(value) { }
}
exports.ChatResponseProgressPart = ChatResponseProgressPart;
class ChatResponseReferencePart {
    constructor(value, iconPath) { }
}
exports.ChatResponseReferencePart = ChatResponseReferencePart;
class ChatResponseCommandButtonPart {
    constructor(value) { }
}
exports.ChatResponseCommandButtonPart = ChatResponseCommandButtonPart;
class ChatResponseMarkdownPart {
    constructor(value) {
    }
}
exports.ChatResponseMarkdownPart = ChatResponseMarkdownPart;
class ChatResponseFileTreePart {
    constructor(value, baseUri) { }
}
exports.ChatResponseFileTreePart = ChatResponseFileTreePart;
var ChatResultFeedbackKind;
(function (ChatResultFeedbackKind) {
    ChatResultFeedbackKind[ChatResultFeedbackKind["Unhelpful"] = 0] = "Unhelpful";
    ChatResultFeedbackKind[ChatResultFeedbackKind["Helpful"] = 1] = "Helpful";
})(ChatResultFeedbackKind || (exports.ChatResultFeedbackKind = ChatResultFeedbackKind = {}));
var LanguageModelChatMessageRole;
(function (LanguageModelChatMessageRole) {
    LanguageModelChatMessageRole[LanguageModelChatMessageRole["User"] = 1] = "User";
    LanguageModelChatMessageRole[LanguageModelChatMessageRole["Assistant"] = 2] = "Assistant";
})(LanguageModelChatMessageRole || (exports.LanguageModelChatMessageRole = LanguageModelChatMessageRole = {}));
class LanguageModelChatMessage {
    static User(content, name) {
        return new LanguageModelChatMessage(LanguageModelChatMessageRole.User, content, name);
    }
    static Assistant(content, name) {
        return new LanguageModelChatMessage(LanguageModelChatMessageRole.Assistant, content, name);
    }
    constructor(role, content, name) {
        this.role = role;
        this.content = content;
        this.name = name;
    }
}
exports.LanguageModelChatMessage = LanguageModelChatMessage;
class LanguageModelError extends Error {
    static NoPermissions(message) {
        return new LanguageModelError(message, LanguageModelError.NoPermissions.name);
    }
    static Blocked(message) {
        return new LanguageModelError(message, LanguageModelError.Blocked.name);
    }
    static NotFound(message) {
        return new LanguageModelError(message, LanguageModelError.NotFound.name);
    }
    constructor(message, code) {
        super(message);
        this.name = 'LanguageModelError';
        this.code = code !== null && code !== void 0 ? code : '';
    }
}
exports.LanguageModelError = LanguageModelError;
// #endregion


/***/ }),

/***/ "../node_modules/path-browserify/index.js":
/*!************************************************!*\
  !*** ../node_modules/path-browserify/index.js ***!
  \************************************************/
/***/ ((module) => {

"use strict";
// 'path' module extracted from Node.js v8.11.1 (only the posix part)
// transplited with Babel

// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.



function assertPath(path) {
  if (typeof path !== 'string') {
    throw new TypeError('Path must be a string. Received ' + JSON.stringify(path));
  }
}

// Resolves . and .. elements in a path with directory names
function normalizeStringPosix(path, allowAboveRoot) {
  var res = '';
  var lastSegmentLength = 0;
  var lastSlash = -1;
  var dots = 0;
  var code;
  for (var i = 0; i <= path.length; ++i) {
    if (i < path.length)
      code = path.charCodeAt(i);
    else if (code === 47 /*/*/)
      break;
    else
      code = 47 /*/*/;
    if (code === 47 /*/*/) {
      if (lastSlash === i - 1 || dots === 1) {
        // NOOP
      } else if (lastSlash !== i - 1 && dots === 2) {
        if (res.length < 2 || lastSegmentLength !== 2 || res.charCodeAt(res.length - 1) !== 46 /*.*/ || res.charCodeAt(res.length - 2) !== 46 /*.*/) {
          if (res.length > 2) {
            var lastSlashIndex = res.lastIndexOf('/');
            if (lastSlashIndex !== res.length - 1) {
              if (lastSlashIndex === -1) {
                res = '';
                lastSegmentLength = 0;
              } else {
                res = res.slice(0, lastSlashIndex);
                lastSegmentLength = res.length - 1 - res.lastIndexOf('/');
              }
              lastSlash = i;
              dots = 0;
              continue;
            }
          } else if (res.length === 2 || res.length === 1) {
            res = '';
            lastSegmentLength = 0;
            lastSlash = i;
            dots = 0;
            continue;
          }
        }
        if (allowAboveRoot) {
          if (res.length > 0)
            res += '/..';
          else
            res = '..';
          lastSegmentLength = 2;
        }
      } else {
        if (res.length > 0)
          res += '/' + path.slice(lastSlash + 1, i);
        else
          res = path.slice(lastSlash + 1, i);
        lastSegmentLength = i - lastSlash - 1;
      }
      lastSlash = i;
      dots = 0;
    } else if (code === 46 /*.*/ && dots !== -1) {
      ++dots;
    } else {
      dots = -1;
    }
  }
  return res;
}

function _format(sep, pathObject) {
  var dir = pathObject.dir || pathObject.root;
  var base = pathObject.base || (pathObject.name || '') + (pathObject.ext || '');
  if (!dir) {
    return base;
  }
  if (dir === pathObject.root) {
    return dir + base;
  }
  return dir + sep + base;
}

var posix = {
  // path.resolve([from ...], to)
  resolve: function resolve() {
    var resolvedPath = '';
    var resolvedAbsolute = false;
    var cwd;

    for (var i = arguments.length - 1; i >= -1 && !resolvedAbsolute; i--) {
      var path;
      if (i >= 0)
        path = arguments[i];
      else {
        if (cwd === undefined)
          cwd = process.cwd();
        path = cwd;
      }

      assertPath(path);

      // Skip empty entries
      if (path.length === 0) {
        continue;
      }

      resolvedPath = path + '/' + resolvedPath;
      resolvedAbsolute = path.charCodeAt(0) === 47 /*/*/;
    }

    // At this point the path should be resolved to a full absolute path, but
    // handle relative paths to be safe (might happen when process.cwd() fails)

    // Normalize the path
    resolvedPath = normalizeStringPosix(resolvedPath, !resolvedAbsolute);

    if (resolvedAbsolute) {
      if (resolvedPath.length > 0)
        return '/' + resolvedPath;
      else
        return '/';
    } else if (resolvedPath.length > 0) {
      return resolvedPath;
    } else {
      return '.';
    }
  },

  normalize: function normalize(path) {
    assertPath(path);

    if (path.length === 0) return '.';

    var isAbsolute = path.charCodeAt(0) === 47 /*/*/;
    var trailingSeparator = path.charCodeAt(path.length - 1) === 47 /*/*/;

    // Normalize the path
    path = normalizeStringPosix(path, !isAbsolute);

    if (path.length === 0 && !isAbsolute) path = '.';
    if (path.length > 0 && trailingSeparator) path += '/';

    if (isAbsolute) return '/' + path;
    return path;
  },

  isAbsolute: function isAbsolute(path) {
    assertPath(path);
    return path.length > 0 && path.charCodeAt(0) === 47 /*/*/;
  },

  join: function join() {
    if (arguments.length === 0)
      return '.';
    var joined;
    for (var i = 0; i < arguments.length; ++i) {
      var arg = arguments[i];
      assertPath(arg);
      if (arg.length > 0) {
        if (joined === undefined)
          joined = arg;
        else
          joined += '/' + arg;
      }
    }
    if (joined === undefined)
      return '.';
    return posix.normalize(joined);
  },

  relative: function relative(from, to) {
    assertPath(from);
    assertPath(to);

    if (from === to) return '';

    from = posix.resolve(from);
    to = posix.resolve(to);

    if (from === to) return '';

    // Trim any leading backslashes
    var fromStart = 1;
    for (; fromStart < from.length; ++fromStart) {
      if (from.charCodeAt(fromStart) !== 47 /*/*/)
        break;
    }
    var fromEnd = from.length;
    var fromLen = fromEnd - fromStart;

    // Trim any leading backslashes
    var toStart = 1;
    for (; toStart < to.length; ++toStart) {
      if (to.charCodeAt(toStart) !== 47 /*/*/)
        break;
    }
    var toEnd = to.length;
    var toLen = toEnd - toStart;

    // Compare paths to find the longest common path from root
    var length = fromLen < toLen ? fromLen : toLen;
    var lastCommonSep = -1;
    var i = 0;
    for (; i <= length; ++i) {
      if (i === length) {
        if (toLen > length) {
          if (to.charCodeAt(toStart + i) === 47 /*/*/) {
            // We get here if `from` is the exact base path for `to`.
            // For example: from='/foo/bar'; to='/foo/bar/baz'
            return to.slice(toStart + i + 1);
          } else if (i === 0) {
            // We get here if `from` is the root
            // For example: from='/'; to='/foo'
            return to.slice(toStart + i);
          }
        } else if (fromLen > length) {
          if (from.charCodeAt(fromStart + i) === 47 /*/*/) {
            // We get here if `to` is the exact base path for `from`.
            // For example: from='/foo/bar/baz'; to='/foo/bar'
            lastCommonSep = i;
          } else if (i === 0) {
            // We get here if `to` is the root.
            // For example: from='/foo'; to='/'
            lastCommonSep = 0;
          }
        }
        break;
      }
      var fromCode = from.charCodeAt(fromStart + i);
      var toCode = to.charCodeAt(toStart + i);
      if (fromCode !== toCode)
        break;
      else if (fromCode === 47 /*/*/)
        lastCommonSep = i;
    }

    var out = '';
    // Generate the relative path based on the path difference between `to`
    // and `from`
    for (i = fromStart + lastCommonSep + 1; i <= fromEnd; ++i) {
      if (i === fromEnd || from.charCodeAt(i) === 47 /*/*/) {
        if (out.length === 0)
          out += '..';
        else
          out += '/..';
      }
    }

    // Lastly, append the rest of the destination (`to`) path that comes after
    // the common path parts
    if (out.length > 0)
      return out + to.slice(toStart + lastCommonSep);
    else {
      toStart += lastCommonSep;
      if (to.charCodeAt(toStart) === 47 /*/*/)
        ++toStart;
      return to.slice(toStart);
    }
  },

  _makeLong: function _makeLong(path) {
    return path;
  },

  dirname: function dirname(path) {
    assertPath(path);
    if (path.length === 0) return '.';
    var code = path.charCodeAt(0);
    var hasRoot = code === 47 /*/*/;
    var end = -1;
    var matchedSlash = true;
    for (var i = path.length - 1; i >= 1; --i) {
      code = path.charCodeAt(i);
      if (code === 47 /*/*/) {
          if (!matchedSlash) {
            end = i;
            break;
          }
        } else {
        // We saw the first non-path separator
        matchedSlash = false;
      }
    }

    if (end === -1) return hasRoot ? '/' : '.';
    if (hasRoot && end === 1) return '//';
    return path.slice(0, end);
  },

  basename: function basename(path, ext) {
    if (ext !== undefined && typeof ext !== 'string') throw new TypeError('"ext" argument must be a string');
    assertPath(path);

    var start = 0;
    var end = -1;
    var matchedSlash = true;
    var i;

    if (ext !== undefined && ext.length > 0 && ext.length <= path.length) {
      if (ext.length === path.length && ext === path) return '';
      var extIdx = ext.length - 1;
      var firstNonSlashEnd = -1;
      for (i = path.length - 1; i >= 0; --i) {
        var code = path.charCodeAt(i);
        if (code === 47 /*/*/) {
            // If we reached a path separator that was not part of a set of path
            // separators at the end of the string, stop now
            if (!matchedSlash) {
              start = i + 1;
              break;
            }
          } else {
          if (firstNonSlashEnd === -1) {
            // We saw the first non-path separator, remember this index in case
            // we need it if the extension ends up not matching
            matchedSlash = false;
            firstNonSlashEnd = i + 1;
          }
          if (extIdx >= 0) {
            // Try to match the explicit extension
            if (code === ext.charCodeAt(extIdx)) {
              if (--extIdx === -1) {
                // We matched the extension, so mark this as the end of our path
                // component
                end = i;
              }
            } else {
              // Extension does not match, so our result is the entire path
              // component
              extIdx = -1;
              end = firstNonSlashEnd;
            }
          }
        }
      }

      if (start === end) end = firstNonSlashEnd;else if (end === -1) end = path.length;
      return path.slice(start, end);
    } else {
      for (i = path.length - 1; i >= 0; --i) {
        if (path.charCodeAt(i) === 47 /*/*/) {
            // If we reached a path separator that was not part of a set of path
            // separators at the end of the string, stop now
            if (!matchedSlash) {
              start = i + 1;
              break;
            }
          } else if (end === -1) {
          // We saw the first non-path separator, mark this as the end of our
          // path component
          matchedSlash = false;
          end = i + 1;
        }
      }

      if (end === -1) return '';
      return path.slice(start, end);
    }
  },

  extname: function extname(path) {
    assertPath(path);
    var startDot = -1;
    var startPart = 0;
    var end = -1;
    var matchedSlash = true;
    // Track the state of characters (if any) we see before our first dot and
    // after any path separator we find
    var preDotState = 0;
    for (var i = path.length - 1; i >= 0; --i) {
      var code = path.charCodeAt(i);
      if (code === 47 /*/*/) {
          // If we reached a path separator that was not part of a set of path
          // separators at the end of the string, stop now
          if (!matchedSlash) {
            startPart = i + 1;
            break;
          }
          continue;
        }
      if (end === -1) {
        // We saw the first non-path separator, mark this as the end of our
        // extension
        matchedSlash = false;
        end = i + 1;
      }
      if (code === 46 /*.*/) {
          // If this is our first dot, mark it as the start of our extension
          if (startDot === -1)
            startDot = i;
          else if (preDotState !== 1)
            preDotState = 1;
      } else if (startDot !== -1) {
        // We saw a non-dot and non-path separator before our dot, so we should
        // have a good chance at having a non-empty extension
        preDotState = -1;
      }
    }

    if (startDot === -1 || end === -1 ||
        // We saw a non-dot character immediately before the dot
        preDotState === 0 ||
        // The (right-most) trimmed path component is exactly '..'
        preDotState === 1 && startDot === end - 1 && startDot === startPart + 1) {
      return '';
    }
    return path.slice(startDot, end);
  },

  format: function format(pathObject) {
    if (pathObject === null || typeof pathObject !== 'object') {
      throw new TypeError('The "pathObject" argument must be of type Object. Received type ' + typeof pathObject);
    }
    return _format('/', pathObject);
  },

  parse: function parse(path) {
    assertPath(path);

    var ret = { root: '', dir: '', base: '', ext: '', name: '' };
    if (path.length === 0) return ret;
    var code = path.charCodeAt(0);
    var isAbsolute = code === 47 /*/*/;
    var start;
    if (isAbsolute) {
      ret.root = '/';
      start = 1;
    } else {
      start = 0;
    }
    var startDot = -1;
    var startPart = 0;
    var end = -1;
    var matchedSlash = true;
    var i = path.length - 1;

    // Track the state of characters (if any) we see before our first dot and
    // after any path separator we find
    var preDotState = 0;

    // Get non-dir info
    for (; i >= start; --i) {
      code = path.charCodeAt(i);
      if (code === 47 /*/*/) {
          // If we reached a path separator that was not part of a set of path
          // separators at the end of the string, stop now
          if (!matchedSlash) {
            startPart = i + 1;
            break;
          }
          continue;
        }
      if (end === -1) {
        // We saw the first non-path separator, mark this as the end of our
        // extension
        matchedSlash = false;
        end = i + 1;
      }
      if (code === 46 /*.*/) {
          // If this is our first dot, mark it as the start of our extension
          if (startDot === -1) startDot = i;else if (preDotState !== 1) preDotState = 1;
        } else if (startDot !== -1) {
        // We saw a non-dot and non-path separator before our dot, so we should
        // have a good chance at having a non-empty extension
        preDotState = -1;
      }
    }

    if (startDot === -1 || end === -1 ||
    // We saw a non-dot character immediately before the dot
    preDotState === 0 ||
    // The (right-most) trimmed path component is exactly '..'
    preDotState === 1 && startDot === end - 1 && startDot === startPart + 1) {
      if (end !== -1) {
        if (startPart === 0 && isAbsolute) ret.base = ret.name = path.slice(1, end);else ret.base = ret.name = path.slice(startPart, end);
      }
    } else {
      if (startPart === 0 && isAbsolute) {
        ret.name = path.slice(1, startDot);
        ret.base = path.slice(1, end);
      } else {
        ret.name = path.slice(startPart, startDot);
        ret.base = path.slice(startPart, end);
      }
      ret.ext = path.slice(startDot, end);
    }

    if (startPart > 0) ret.dir = path.slice(0, startPart - 1);else if (isAbsolute) ret.dir = '/';

    return ret;
  },

  sep: '/',
  delimiter: ':',
  win32: null,
  posix: null
};

posix.posix = posix;

module.exports = posix;


/***/ })

}]);
//# sourceMappingURL=vendors-node_modules_theia_debug_lib_common_debug-uri-utils_js-node_modules_theia_plugin-ext_-28ca15.js.map